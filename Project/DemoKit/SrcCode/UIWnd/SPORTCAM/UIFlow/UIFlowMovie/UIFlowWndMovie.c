//This source code is generated by UI Designer Studio.

#include "UIFramework.h"
#include "UIFrameworkExt.h"
#include "NVTToolCommand.h"
#include "UIFlowWndMovieRes.c"
#include "UIFlow.h"
#include "Audio.h"
#include "md_api.h"
#include "FileSysTsk.h"
#include "ImageApp_CamMovie.h"
#include "ImageApp_CamPhoto.h" //for NVTEVT_CALLBACK, NVTEVT_CB_ZOOM, NVTEVT_ALGMSG_PREVIEW_STABLE
#if (CALIBRATION_FUNC == ENABLE)
#include "EngineerMode.h"
#endif
#include "DxOutput.h"
#include    "stdio.h"
#include    "GPS.h"

#if USE_FILEDB
#include "FileDB.h"
#include "NameRule_FileDB.h"
#endif
#include "UIFlow.h"
#include "GSensor.h"
#include "display.h"
//#NT#2016/03/02#Lincy Lin -begin
//#NT#Support object tracking function
#if MOVIE_OT_FUNC
#include "NvtOt.h"
#endif
//#NT#2016/03/02#Lincy Lin -end

//#NT#2016/05/23#David Tsai -begin
//#NT# Support tampering detection function
//#NT#2016/10/14#Yuzhe Bian -begin
//#NT# Support trip-wire detection & trip-zone detection function
#if MOVIE_BC_FUNC || MOVIE_TD_FUNC || MOVIE_TWD_FUNC || MOVIE_TZD_FUNC
#include "BC_lib.h"
#endif
//#NT#2016/10/14#Yuzhe Bian -end


#if MOVIE_TD_FUNC
#include "TD_lib.h"
#endif
//#NT#2016/05/23#David Tsai -end

//#NT#2016/10/14#Yuzhe Bian -begin
//#NT# Support trip-wire detection & trip-zone detection function
#if MOVIE_TWD_FUNC
#include "TWD_lib.h"
#endif
#if MOVIE_TZD_FUNC
#include "TZD_lib.h"
#endif
//#NT#2016/10/14#Yuzhe Bian -end

//#NT#2016/04/22#Nestor Yang -begin
//#NT# Support Driver Drowsiness Detection(DDD)
#if MOVIE_DDD_FUNC
#include "DDD_lib.h"
#include "MovieStamp.h"
#endif
//#NT#2016/04/22#Nestor Yang -end
//#NT#2016/06/28#KCHong -begin
//#NT#DbgLog in GPS section
#if (LOG_DBGINFO_IN_GPS_SECTION == ENABLE)
#include "mp4log.h"
#endif
//#NT#2016/06/28#KCHong -end

//#NT#2016/07/06#CC Chao -begin
#if MOVIE_TSR_FUNC_
#include "tsr_lib.h"
#include "TSD_DSP_lib.h"
#endif
//#NT#2016/07/06#CC Chao -end
#if _ADAS_DSP_FUNC_
#include "ADAS_DSP_Lib.h"
#endif


//#NT#2016/09/30#Yang Jin -begin
//#NT# Support Face Tracking Grading(FTG)
#if MOVIE_FTG_FUNC
#include "ftg_lib.h"
#endif
//#NT#2016/09/30#Yang Jin -end

#if defined(YQCONFIG_UART_TO_MTK_SUPPORT)
#include "UART_TO_MTK.h"
#endif
#define __MODULE__          UIFlowWndMovie
//#define __DBGLVL__ 0        //OFF mode, show nothing
#define __DBGLVL__ 1        //ERROR mode, show err, wrn only
//#define __DBGLVL__ 2        //TRACE mode, show err, wrn, ind, msg and func and ind, msg and func can be filtering by __DBGFLT__ settings
#define __DBGFLT__ "*"      //*=All
#include "DebugModule.h"

#if defined(YQCONFIG_ANDROID_SYSTEM_SUPPORT)
#include "Sensor.h"
#include "DxCommon.h"
#include "DxDisplay.h"
#include "UICfgDefault.h"
#include "ImageUnit_ImagePipe.h"/*ZMD*/
#endif
#if defined(YQCONFIG_YUANEDOG_SUPPORT)
#include "GxUSB.h"
#include "UsbDevDef.h"
#endif
//#NT#2016/09/29#KCHong -begin
//#NT#The GPS related variables should not depend on ADAS.
#if 1//(GPS_FUNCTION == ENABLE)
extern FLOAT g_CurSpeed;
extern BOOL g_GPSLinked;
extern BOOL g_GPSStatus;
#endif
//#NT#2016/09/29#KCHong -end
#if defined(YQCONFIG_UART_TO_MTK_SUPPORT) && defined(YQCONFIG_ANDROID_SYSTEM_SUPPORT)
UINT32 g_FCDistance = 0;
#endif


BOOL ParkingCaptrueFlag=FALSE;

#if defined(YQCONFIG_UART_TO_MCU_SUPPORT)
extern UIMenuStoreInfo  currentInfo;
#endif
//#NT#2016/09/20#Bob Huang -begin
//#NT#Support HDMI Display with 3DNR Out
#if (_3DNROUT_FUNC == ENABLE)
extern BOOL     gb3DNROut;
#endif
//#NT#2016/09/20#Bob Huang -end
#if defined(YQCONFIG_ANDROID_SYSTEM_SUPPORT)
typedef enum
{
    UIFLOW_MOVIE_TOUCH_KEY_NONE,
    UIFLOW_MOVIE_TOUCH_KEY_RECORD,
    UIFLOW_MOVIE_TOUCH_KEY_PLAYBACK,
    UIFLOW_MOVIE_TOUCH_KEY_MENU,
    UIFLOW_MOVIE_TOUCH_KEY_SNAPESHOT,
    UIFLOW_MOVIE_TOUCH_KEY_RETURN,
    UIFLOW_MOVIE_TOUCH_KEY_PIPDISPLAY,
    UIFLOW_MOVIE_TOUCH_KEY_LOCKFILE,
    UIFLOW_MOVIE_TOUCH_KEY_AUDIOSWITCH,
    UIFLOW_MOVIE_TOUCH_KEY_PIPDISPLAY2,
    UIFLOW_MOVIE_TOUCH_KEY_MAX
} UIFLOW_MOVIE_TOUCH_KEY;
static UIFLOW_MOVIE_TOUCH_KEY uiMovieKeyPressed=UIFLOW_MOVIE_TOUCH_KEY_NONE;
#if defined(AUDIO_MIC_SWITCH_SUPPORT) && (AUDIO_MIC_SWITCH_SUPPORT==ENABLE)
BOOL gbAudioReordSwitch = TRUE;//pgl 20160628 add
#endif
UINT32 g_MTKSetADASEnSpeed=40;
CHAR MTKMenuSetting[32]= {0};
CHAR MTKMenuSettingTmp[32]= {0};

BOOL gbMovieTouchUIDisplayEn=TRUE;
static UINT32 guiMovieTouchUIDisplayCounter=0;
BOOL SetMovieRecordingFlag=FALSE;
BOOL gbGsensorTrig=FALSE;
BOOL gbTrigUartTransmitFile=FALSE;
BOOL gbTrigCaptrueEndFlag=FALSE;
BOOL gbNTRequireAndroid=TRUE;
BOOL gbMovieRecordingFlag=FALSE;
BOOL gbMovieRecFormatFlag=FALSE;
BOOL gbDualDispalyFlag=FALSE;
BOOL gbTransmitSecondSensor=FALSE;
#endif

#define  LDWS_NONE_   0x00
#define  LDWS_RIGHT_   (1<<1)
#define  LDWS_LEFT_   (1<<2)
#define  FCW_WARNING   (1<<3)
#define  STOP2GO_STOP   (1<<4)
#define  STOP2GO_GO   (1<<5)
#define  WORKING_MODE  (1<<6)
//---------------------UIFlowWndMovieCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie)
CTRL_LIST_ITEM(UIFlowWndMovie_Panel_Normal_Display)
#if defined(YQCONFIG_ANDROID_SYSTEM_SUPPORT)
CTRL_LIST_ITEM(UIFlowWndMovie_ADAS_DrawingLine)
CTRL_LIST_ITEM(UIFlowWndMovie_ALG_Draw)
#endif
CTRL_LIST_ITEM(UIFlowWndMovie_ADAS_Alert_Display)
#if defined(YQCONFIG_ANDROID_SYSTEM_SUPPORT)
CTRL_LIST_ITEM(UIFlowWndMovie_Static_Speed)
CTRL_LIST_ITEM(UIFlowWndMovie_Static_Distance)
#endif
CTRL_LIST_END

//----------------------UIFlowWndMovieCtrl Event---------------------------
INT32 UIFlowWndMovie_OnOpen(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnClose(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnUpdateInfo(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyNext(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeySelect(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyMenu(VControl *, UINT32, UINT32 *);
//INT32 UIFlowWndMovie_OnKeyEnter(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyDown(VControl *, UINT32, UINT32 *);
//INT32 UIFlowWndMovie_OnKeyRight(VControl *, UINT32, UINT32 *);
//INT32 UIFlowWndMovie_OnKeyLeft(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnChildClose(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyShutter2(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyZoomin(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyZoomout(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyUp(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyPlayBack(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnBattery(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnBatteryLow(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyMode(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnMovieFinish(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnMovieOneSec(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnMovieFull(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnMovieWrError(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnStorageSlow(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray);
INT32 UIFlowWndMovie_OnLoopRecFull(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnEMRCompleted(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnPreviewStable(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnOZoomStepChange(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnDZoomStepChange(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnStorageInit(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnStorageChange(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnTimer(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnACPlug(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnACUnplug(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnCustom1(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnADASShowAlarm(VControl *, UINT32, UINT32 *);        //#NT#2016/03/25#New ADAS#KCHong
#if defined(YQCONFIG_UART_TO_MTK_SUPPORT) && defined(YQCONFIG_ANDROID_SYSTEM_SUPPORT)
INT32 UIFlowWndMovie_OnTouchPanelKey(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnMTKMenuSetting(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnMTKGpsInfo(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnCustom2(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_GsensorTrig(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_StartMovieRecord(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_StopMovieRecord(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_FormatCard(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_Capture(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_TransmitFinish(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnAdasSetting(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray);//pgl adas_switch_cmd add 20160429
INT32 UIFlowWndMovie_MTK_Change_DiaplayMode(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray);//pgl adas_switch_cmd add 20160429
#endif
//#NT#2016/06/23#Niven Cho -begin
//#NT#Enter calibration by cgi event or command event
INT32 UIFlowWndMovie_OnKeyCalibration(VControl *, UINT32, UINT32 *);
//#NT#2016/06/23#Niven Cho -end
//#NT#2016/07/20#Brain Yen -begin
//#NT#Add for DDD alarm
INT32 UIFlowWndMovie_OnDDDShowAlarm(VControl *, UINT32 , UINT32 *);
//#NT#2016/07/20#Brain Yen -end
EVENT_BEGIN(UIFlowWndMovie)
EVENT_ITEM(NVTEVT_OPEN_WINDOW,UIFlowWndMovie_OnOpen)
EVENT_ITEM(NVTEVT_CLOSE_WINDOW,UIFlowWndMovie_OnClose)
EVENT_ITEM(NVTEVT_UPDATE_INFO,UIFlowWndMovie_OnUpdateInfo)
#if (_KEY_METHOD_ == _KEY_METHOD_4KEY_)
EVENT_ITEM(NVTEVT_KEY_NEXT,UIFlowWndMovie_OnKeyDown)     // Down Key
EVENT_ITEM(NVTEVT_KEY_SELECT,UIFlowWndMovie_OnKeyNext)     // OK Key
EVENT_ITEM(NVTEVT_KEY_SHUTTER2,UIFlowWndMovie_OnKeySelect)    // REC key
#else
EVENT_ITEM(NVTEVT_KEY_NEXT,UIFlowWndMovie_OnKeyNext)        // Right Key
EVENT_ITEM(NVTEVT_KEY_SELECT,UIFlowWndMovie_OnKeySelect)    // Enter key
#endif
EVENT_ITEM(NVTEVT_KEY_MENU,UIFlowWndMovie_OnKeyMenu)
//EVENT_ITEM(NVTEVT_KEY_ENTER,UIFlowWndMovie_OnKeyEnter)
EVENT_ITEM(NVTEVT_KEY_DOWN,UIFlowWndMovie_OnKeyDown)
#if defined(YQCONFIG_ANDROID_SYSTEM_SUPPORT)
EVENT_ITEM(NVTEVT_KEY_UP,UIFlowWndMovie_OnKeyUp)
EVENT_ITEM(NVTEVT_KEY_CUSTOM1,UIFlowWndMovie_OnCustom1)
EVENT_ITEM(NVTEVT_KEY_CUSTOM2,UIFlowWndMovie_OnCustom2)
#endif
//EVENT_ITEM(NVTEVT_KEY_LEFT,UIFlowWndMovie_OnKeyLeft)
//EVENT_ITEM(NVTEVT_KEY_RIGHT,UIFlowWndMovie_OnKeyRight)
EVENT_ITEM(NVTEVT_CHILD_CLOSE,UIFlowWndMovie_OnChildClose)
EVENT_ITEM(NVTEVT_KEY_SHUTTER2,UIFlowWndMovie_OnKeyShutter2)
EVENT_ITEM(NVTEVT_KEY_ZOOMIN,UIFlowWndMovie_OnKeyZoomin)
EVENT_ITEM(NVTEVT_KEY_ZOOMOUT,UIFlowWndMovie_OnKeyZoomout)
EVENT_ITEM(NVTEVT_KEY_UP,UIFlowWndMovie_OnKeyUp)
EVENT_ITEM(NVTEVT_KEY_PLAYBACK,UIFlowWndMovie_OnKeyPlayBack)
EVENT_ITEM(NVTEVT_BATTERY,UIFlowWndMovie_OnBattery)
EVENT_ITEM(NVTEVT_BATTERY_LOW,UIFlowWndMovie_OnBatteryLow)
EVENT_ITEM(NVTEVT_KEY_MODE,UIFlowWndMovie_OnKeyMode)
EVENT_ITEM(NVTEVT_CB_MOVIE_REC_FINISH,UIFlowWndMovie_OnMovieFinish)
EVENT_ITEM(NVTEVT_CB_MOVIE_REC_ONE_SEC,UIFlowWndMovie_OnMovieOneSec)
EVENT_ITEM(NVTEVT_CB_MOVIE_OVERTIME,UIFlowWndMovie_OnMovieFull) // the same handling as storage full (may need to show special message)
EVENT_ITEM(NVTEVT_CB_MOVIE_FULL,UIFlowWndMovie_OnMovieFull)
EVENT_ITEM(NVTEVT_CB_MOVIE_WR_ERROR,UIFlowWndMovie_OnMovieWrError)
EVENT_ITEM(NVTEVT_CB_MOVIE_SLOW,UIFlowWndMovie_OnStorageSlow)
EVENT_ITEM(NVTEVT_CB_MOVIE_LOOPREC_FULL,UIFlowWndMovie_OnLoopRecFull)
EVENT_ITEM(NVTEVT_CB_EMR_COMPLETED,UIFlowWndMovie_OnEMRCompleted)
//EVENT_ITEM(IPL_CBMSG_PREVIEWSTABLE,UIFlowWndMovie_OnPreviewStable)
EVENT_ITEM(NVTEVT_CALLBACK,UIFlowWndMovie_OnPreviewStable)
EVENT_ITEM(NVTEVT_CB_OZOOMSTEPCHG,UIFlowWndMovie_OnOZoomStepChange)
EVENT_ITEM(NVTEVT_CB_ZOOM,UIFlowWndMovie_OnDZoomStepChange)
EVENT_ITEM(NVTEVT_STORAGE_INIT,UIFlowWndMovie_OnStorageInit)
EVENT_ITEM(NVTEVT_STORAGE_CHANGE,UIFlowWndMovie_OnStorageChange)
EVENT_ITEM(NVTEVT_TIMER,UIFlowWndMovie_OnTimer)
EVENT_ITEM(NVTEVT_AC_Plug,UIFlowWndMovie_OnACPlug)
EVENT_ITEM(NVTEVT_AC_UnPlug,UIFlowWndMovie_OnACUnplug)
EVENT_ITEM(NVTEVT_KEY_CUSTOM1,UIFlowWndMovie_OnCustom1)
EVENT_ITEM(NVTEVT_CB_ADAS_SHOWALARM, UIFlowWndMovie_OnADASShowAlarm)      //#NT#2016/03/25#New ADAS#KCHong
//#NT#2016/06/23#Niven Cho -begin
//#NT#Enter calibration by cgi event or command event
EVENT_ITEM(NVTEVT_KEY_CALIBRATION,UIFlowWndMovie_OnKeyCalibration)
//#NT#2016/06/23#Niven Cho -end
//#NT#2016/07/20#Brain Yen -begin
//#NT#Add for DDD alarm
EVENT_ITEM(NVTEVT_CB_DDD_SHOWALARM,UIFlowWndMovie_OnDDDShowAlarm)
//#NT#2016/07/20#Brain Yen -end
#if defined(YQCONFIG_UART_TO_MTK_SUPPORT) && defined(YQCONFIG_ANDROID_SYSTEM_SUPPORT)
EVENT_ITEM(NVTEVT_TOUCHPANEL_KEY,UIFlowWndMovie_OnTouchPanelKey)
EVENT_ITEM(NVTEVT_MTK_MENU_SETTING,UIFlowWndMovie_OnMTKMenuSetting)
EVENT_ITEM(NVTEVT_MTK_GPSINFO,UIFlowWndMovie_OnMTKGpsInfo)
EVENT_ITEM(NVTEVT_GSENSOR_TRIG,UIFlowWndMovie_GsensorTrig)
EVENT_ITEM(NVTEVT_MTK_STARTREC,UIFlowWndMovie_StartMovieRecord)
EVENT_ITEM(NVTEVT_MTK_STOPREC,UIFlowWndMovie_StopMovieRecord)
EVENT_ITEM(NVTEVT_MTK_FORMATCARD,UIFlowWndMovie_FormatCard)
EVENT_ITEM(NVTEVT_MTK_CAPTURE,UIFlowWndMovie_Capture)
EVENT_ITEM(NVTEVT_MTK_TRANSMIT_FINISH,UIFlowWndMovie_TransmitFinish)
EVENT_ITEM(NVTEVT_MTK_ADAS_SWITCH,UIFlowWndMovie_OnAdasSetting)
EVENT_ITEM(NVTEVT_MTK_CHANGE_DIAPLAYMODE,UIFlowWndMovie_MTK_Change_DiaplayMode)
#endif
EVENT_END

// Movie mode key mask
#define MOVIE_KEY_PRESS_MASK        (FLGKEY_SHUTTER2|FLGKEY_RIGHT|FLGKEY_LEFT|FLGKEY_CUSTOM1|FLGKEY_UP|FLGKEY_DOWN)
#define MOVIE_KEY_RELEASE_MASK      (FLGKEY_SHUTTER2|FLGKEY_RIGHT|FLGKEY_LEFT|FLGKEY_CUSTOM1|FLGKEY_UP|FLGKEY_DOWN)

//-----------------------------------------------------------------------------------------
static BOOL    g_uiRecordIngMotionDet = TRUE;
#if _ADAS_FUNC_
UINT32 g_uiAdasAlertSecCnt = 0;
#endif
static UINT32  gUIMotionDetTimerID = NULL_TIMER;
static UINT32  g_uiDateTimerID = NULL_TIMER;
static UINT32  g_uiMaskKeyPress      = MOVIE_KEY_PRESS_MASK;
static UINT32  g_uiMaskKeyRelease    = MOVIE_KEY_RELEASE_MASK;
//static UINT32 g_uiMaskKeyContinue   = MOVIE_KEY_CONTINUE_MASK;
static volatile BOOL g_bRedLEDOn = FALSE;
static volatile BOOL g_ACPlug = FALSE;
static volatile BOOL g_PreviewStable = FALSE;
static volatile BOOL g_PreviewStable_Record = FALSE;
BOOL g_bSpeLockFun = FALSE;
_ALIGNED(4)  GPSDATA gpsdata={0};
#if defined(YQCONFIG_ANDROID_SYSTEM_SUPPORT)
void UIFlowwndMovieSetNeedToRecordFlag(BOOL En)
{
    gbMovieRecordingFlag=En;
    //gbAutoRecord=En;
}
#endif
#if MOVIE_DDD_FUNC
static char strTmp[50]={0};
#endif
//#NT#2016/06/08#Lincy Lin -begin
//#NT#Implement generic OSD and video drawing mechanism for ALG function
static void UIFlowWndMovie_ALG_ClearDraw(void);
//#NT#2016/06/08#Lincy Lin -end
#if defined(YQCONFIG_ANDROID_SYSTEM_SUPPORT)
void UIFlowWndMovie_LockFile(void)
{
    if(gbGsensorTrig==TRUE)
        return NVTEVT_CONSUME;
    switch(gMovData.State)
    {
    case MOV_ST_REC:
    case MOV_ST_REC|MOV_ST_ZOOM:
        MovRec_SetCrash();
        gbGsensorTrig=TRUE;
        FlowMovie_IconDrawLockFile();
        debug_msg(("====> MovRec_SetCrash() !\r\n"));
        break;
    }
    return NVTEVT_CONSUME;
}
BOOL UIFlowwndDeleteFWFile(void)
{
    char        *fileName;
    UINT32 ret;
    FST_FILE filehdl;

    fileName = "A:\\FW96663A.bin";
    filehdl = FileSys_OpenFile(fileName, FST_OPEN_READ);
    if (filehdl!=NULL)
    {
        FileSys_CloseFile(filehdl);
        ret=FileSys_DeleteFile(fileName);
        if(FST_STA_OK ==ret)
        {
            debug_msg("---UIFlowwndDelete A FWFile..OK\r\n");
            //return TRUE;
        }
        else
        {
            debug_msg("---UIFlowwndDelete A FWFile..NG\r\n");
            //return FALSE;
        }
    }
    else
    {
        //FileSys_CloseFile(filehdl);
        debug_msg("---UIFlowwndDelete A FWFile..NO A FILE\r\n");
        //return FALSE;
    }

    fileName = "A:\\FW96663T.bin";
    filehdl = FileSys_OpenFile(fileName, FST_OPEN_READ);
    if (filehdl!=NULL)
    {
        FileSys_CloseFile(filehdl);
        ret=FileSys_DeleteFile(fileName);
        if(FST_STA_OK ==ret)
        {
            debug_msg("---UIFlowwndDelete T FWFile..OK\r\n");
            return TRUE;
        }
        else
        {
            debug_msg("---UIFlowwndDelete T FWFile..NG\r\n");
            return FALSE;
        }
    }
    else
    {
        //FileSys_CloseFile(filehdl);
        debug_msg("---UIFlowwndDelete T FWFile..NO T FILE\r\n");
        return FALSE;
    }
}


void FlowMovie_OnExcuseMtkMenuItem(BOOL Flag)
{
    static BOOL gbneed2changmode=FALSE;

//***************************NT96663 movie record resolution begin*************************************
    debug_msg("====>Flag: %d ,%d ,%d ,%d ,%d ,%d ,%d ,%d\r\n",UI_GetData(FL_MOVIE_SIZE),UI_GetData(FL_MOVIE_CYCLIC_REC),\
              UI_GetData(FL_MOVIE_WDR),UI_GetData(FL_MOVIE_MOTION_DET),\
              UI_GetData(FL_GSENSOR),UI_GetData(FL_MOVIE_PARKING),\
              UI_GetData(FL_MOVIE_ADAS_CAL),UI_GetData(FL_MOVIE_AUDIO));

    if((SysGetFlag(FL_MOVIE_SIZE)==MOVIE_SIZE_DUAL_1920x1080P30_1920x1080P30)||(SysGetFlag(FL_MOVIE_SIZE)==MOVIE_SIZE_FRONT_1920x1080P30)\
            ||(SysGetFlag(FL_MOVIE_SIZE)==MOVIE_SIZE_FRONT_1280x720P30))
    {
        if(MTKMenuSetting[MENU_MOVIE_RESOLUTION]==MOVIE_SIZE_DUAL_1920x1080P30_1920x1080P30)
        {
            debug_msg("====>[%d]movie resolution dual 1080P ok..%d..%d..\r\n",DrvSensor_DetPlugIn(SENSOR_ID_2),UI_GetData(FL_DUAL_CAM),UI_GetData(FL_DUAL_CAM_MENU));
            if(DrvSensor_DetPlugIn(SENSOR_ID_2)==1)
            {
                /*
                if(UI_GetData(FL_DUAL_CAM_MENU)!=DUALCAM_BOTH)
                {
                	 UI_SetData(FL_DUAL_CAM_MENU,DUALCAM_BOTH);
                	 UI_SetData(FL_DUAL_CAM,DUALCAM_BOTH);
                               Ux_PostEvent(NVTEVT_EXE_DUALCAM, 1, UI_GetData(FL_DUAL_CAM_MENU));
                               //PipView_SetStyle(UI_GetData(FL_DUAL_CAM));
                }
                */
                UI_SetData(FL_MOVIE_SIZE,MTKMenuSetting[MENU_MOVIE_RESOLUTION]);
                UI_SetData(FL_MOVIE_SIZE_MENU,MTKMenuSetting[MENU_MOVIE_RESOLUTION]);
                gbneed2changmode=TRUE;
            }
            else
            {
                /*
                if(UI_GetData(FL_DUAL_CAM_MENU)!=DUALCAM_FRONT)
                {
                	 UI_SetData(FL_DUAL_CAM_MENU,DUALCAM_FRONT);
                	 UI_SetData(FL_DUAL_CAM,DUALCAM_FRONT);
                               Ux_PostEvent(NVTEVT_EXE_DUALCAM, 1, UI_GetData(FL_DUAL_CAM_MENU));
                	 //PipView_SetStyle(UI_GetData(FL_DUAL_CAM));
                }
                */
                UI_SetData(FL_MOVIE_SIZE,MOVIE_SIZE_FRONT_1920x1080P30);
                UI_SetData(FL_MOVIE_SIZE_MENU,MOVIE_SIZE_FRONT_1920x1080P30);
                gbneed2changmode=TRUE;
            }
        }
        else
        {
            /*
            if(UI_GetData(FL_DUAL_CAM_MENU)!=DUALCAM_FRONT)
            {
            	 UI_SetData(FL_DUAL_CAM_MENU,DUALCAM_FRONT);
            	 UI_SetData(FL_DUAL_CAM,DUALCAM_FRONT);
                           Ux_PostEvent(NVTEVT_EXE_DUALCAM, 1, UI_GetData(FL_DUAL_CAM_MENU));
                    //PipView_SetStyle(UI_GetData(FL_DUAL_CAM));
            }
            */
            if((MTKMenuSetting[MENU_MOVIE_RESOLUTION]==MOVIE_SIZE_FRONT_1920x1080P30)||(MTKMenuSetting[MENU_MOVIE_RESOLUTION]==MOVIE_SIZE_FRONT_1280x720P30))
            {
                UI_SetData(FL_MOVIE_SIZE,MTKMenuSetting[MENU_MOVIE_RESOLUTION]);
                UI_SetData(FL_MOVIE_SIZE_MENU,MTKMenuSetting[MENU_MOVIE_RESOLUTION]);
            }
            else
            {
                UI_SetData(FL_MOVIE_SIZE,MOVIE_SIZE_FRONT_1920x1080P30);
                UI_SetData(FL_MOVIE_SIZE_MENU,MOVIE_SIZE_FRONT_1920x1080P30);
            }
            gbneed2changmode=TRUE;
        }
    }
    else
    {
        debug_msg("====>movie resolution out of rang..fail..use default setting\r\n");
        /*
        if(UI_GetData(FL_DUAL_CAM_MENU)!=DUALCAM_FRONT)
        {
        	 UI_SetData(FL_DUAL_CAM_MENU,DUALCAM_FRONT);
        	 UI_SetData(FL_DUAL_CAM,DUALCAM_FRONT);
                       Ux_PostEvent(NVTEVT_EXE_DUALCAM, 1, UI_GetData(FL_DUAL_CAM_MENU));
                       //PipView_SetStyle(UI_GetData(FL_DUAL_CAM));
        }
        */
        UI_SetData(FL_MOVIE_SIZE,MOVIE_SIZE_FRONT_1920x1080P30);
        UI_SetData(FL_MOVIE_SIZE_MENU,MOVIE_SIZE_FRONT_1920x1080P30);
    }
//***************************NT96663 movie record resolution end*************************************


//***************************NT96663 movie cycle record  begin*******************************
    if((MTKMenuSetting[MENU_MOVIE_CYCLE_RECORD]>=MOVIE_CYCLICREC_OFF)&&(MTKMenuSetting[MENU_MOVIE_CYCLE_RECORD]<MOVIE_CYCLICREC_ID_MAX))
    {
        UI_SetData(FL_MOVIE_CYCLIC_REC,MTKMenuSetting[MENU_MOVIE_CYCLE_RECORD]);
    }
    else
    {
        UI_SetData(FL_MOVIE_CYCLIC_REC,DEFAULT_MOVIE_CYCLICREC);
    }

//***************************NT96663 movie cycle record  end*******************************



//********************************NT96663 movie wdr  begin********************************
    if((MTKMenuSetting[MENU_MOVIE_HDR]>=MOVIE_WDR_OFF)&&(MTKMenuSetting[MENU_MOVIE_HDR]<MOVIE_WDR_ID_MAX))
    {
        UI_SetData(FL_MOVIE_WDR,MTKMenuSetting[MENU_MOVIE_HDR]);
    }
    else
    {
        UI_SetData(FL_MOVIE_WDR,DEFAULT_MOVIE_WDR);
    }
//********************************NT96663 movie wdr  end********************************


//********************************NT96663 movie gsensor  begin********************************
    if((MTKMenuSetting[MENU_MOVIE_GSENSOR]>=0)&&(MTKMenuSetting[MENU_MOVIE_GSENSOR]<4))
    {
        if(MTKMenuSetting[MENU_MOVIE_GSENSOR]==1)
        {
            SysSetFlag(FL_GSENSOR, GSENSOR_LOW);
        }
        else if(MTKMenuSetting[MENU_MOVIE_GSENSOR]==2)
        {
            SysSetFlag(FL_GSENSOR, GSENSOR_MED);
        }
        else if(MTKMenuSetting[MENU_MOVIE_GSENSOR]==3)
        {
            SysSetFlag(FL_GSENSOR, GSENSOR_HIGH);
        }
        else
        {
            SysSetFlag(FL_GSENSOR, GSENSOR_OFF);
        }
    }
    else
    {
        SysSetFlag(FL_GSENSOR, DEFAULT_GSENSOR);
    }
//********************************NT96663 movie gsensor  end********************************


//********************************NT96663 movie parking mode  begin********************************

    if((MTKMenuSetting[MENU_MOVIE_PARKINGMODE]>=0)&&(MTKMenuSetting[MENU_MOVIE_PARKINGMODE]<2))
    {
        if(MTKMenuSetting[MENU_MOVIE_PARKINGMODE]==1)
            SysSetFlag(FL_MOVIE_PARKING, PARKINGMODE_ON);
        else
            SysSetFlag(FL_MOVIE_PARKING, PARKINGMODE_OFF);
    }
    else
    {
        SysSetFlag(FL_MOVIE_PARKING, DEFAULT_PARKING_MODE);
    }
//********************************NT96663 movie parking mode  end********************************

//********************************NT96663 movie adas  begin********************************
    if((MTKMenuSetting[MENU_MOVIE_ADAS]>=0)&&(MTKMenuSetting[MENU_MOVIE_ADAS]<2))
    {
        if(MTKMenuSetting[MENU_MOVIE_ADAS]==MOVIE_ADAS_CAL_ON)
        {
            if((UI_GetData(FL_MOVIE_SIZE_MENU)==MOVIE_SIZE_FRONT_2880x2160P24)||(UI_GetData(FL_MOVIE_SIZE_MENU)==MOVIE_SIZE_FRONT_2560x1440P30)||\
                    (UI_GetData(FL_MOVIE_SIZE_MENU)==MOVIE_SIZE_FRONT_1280x720P120))
            {
                debug_msg("please check second sensor adas..\r\n");
            }
            else
            {
                UI_SetData(FL_MOVIE_ADAS_CAL,MTKMenuSetting[MENU_MOVIE_ADAS]);
            }
        }
        else
        {
            UI_SetData(FL_MOVIE_ADAS_CAL,MTKMenuSetting[MENU_MOVIE_ADAS]);
        }

    }
    else
    {
        UI_SetData(FL_MOVIE_ADAS_CAL,DEFAULT_ADAS);
    }
//********************************NT96663 movie adas  end********************************
    #if defined(AUDIO_MIC_SWITCH_SUPPORT) && (AUDIO_MIC_SWITCH_SUPPORT==ENABLE)

//pgl 20160628 add for movie audio recorder switch settings beg
    if((MTKMenuSetting[MENU_AUDIO_RECORD_SWITCH]>=0)&&(MTKMenuSetting[MENU_AUDIO_RECORD_SWITCH]<2))
    {
        if(MTKMenuSetting[MENU_AUDIO_RECORD_SWITCH]==1)
        {
            SysSetFlag(FL_MOVIE_AUDIO, MOVIE_AUDIO_ON);
            debug_msg("^G---MOVIE_AUDIO_ON---\r\n");
        }
        else
        {
            SysSetFlag(FL_MOVIE_AUDIO, MOVIE_AUDIO_OFF);
            debug_msg("^G---MOVIE_AUDIO_OFF---\r\n");
        }
    }
    else
    {
        SysSetFlag(FL_MOVIE_AUDIO, DEFAULT_MOVIE_AUDIO);
    }
//pgl 20160628 add for movie audio recorder switch settings end
    #endif
    Save_MenuInfo();

    if (gUIMotionDetTimerID!=NULL_TIMER)
    {
        GxTimer_StopTimer(&gUIMotionDetTimerID);
        gUIMotionDetTimerID = NULL_TIMER;
    }

    if (g_uiDateTimerID != NULL_TIMER)
    {
        GxTimer_StopTimer(&g_uiDateTimerID);
        g_uiDateTimerID = NULL_TIMER;
    }

    MTKMenuSettingTmp[MENU_MOVIE_RESOLUTION]=UI_GetData(FL_MOVIE_SIZE);
    MTKMenuSettingTmp[MENU_MOVIE_CYCLE_RECORD]=UI_GetData(FL_MOVIE_CYCLIC_REC);
    MTKMenuSettingTmp[MENU_MOVIE_HDR]=UI_GetData(FL_MOVIE_WDR);
    //MTKMenuSettingTmp[MENU_MOVIE_MOTION_DET]=UI_GetData(FL_MOVIE_MOTION_DET);
    MTKMenuSettingTmp[MENU_MOVIE_GSENSOR]=UI_GetData(FL_GSENSOR);
    MTKMenuSettingTmp[MENU_MOVIE_PARKINGMODE]=UI_GetData(FL_MOVIE_PARKING);
    MTKMenuSettingTmp[MENU_MOVIE_ADAS]=UI_GetData(FL_MOVIE_ADAS_CAL);
    #if defined(AUDIO_MIC_SWITCH_SUPPORT) && (AUDIO_MIC_SWITCH_SUPPORT==ENABLE)
    MTKMenuSettingTmp[MENU_AUDIO_RECORD_SWITCH]=UI_GetData(FL_MOVIE_AUDIO) ;
    #endif
    if(Flag==TRUE)
    {
        gbMovieRecordingFlag=TRUE;
    }
    SetMovieRecordingFlag=FALSE;

    debug_msg("====>Flag: %d ,%d ,%d ,%d ,%d ,%d ,%d ,%d\r\n",UI_GetData(FL_MOVIE_SIZE),UI_GetData(FL_MOVIE_CYCLIC_REC),\
              UI_GetData(FL_MOVIE_WDR),UI_GetData(FL_MOVIE_MOTION_DET),\
              UI_GetData(FL_GSENSOR),UI_GetData(FL_MOVIE_PARKING),\
              UI_GetData(FL_MOVIE_ADAS_CAL),UI_GetData(FL_MOVIE_AUDIO));

    /* add begin by ZMD, 2016-08-25, ?-??им????им??: ?a???им22?????*/
    // Ux_PostEvent(NVTEVT_SYSTEM_MODE, 1, System_GetState(SYS_STATE_CURRMODE));
    //Ux_SendEvent(0, NVTEVT_SYSTEM_MODE, 1, PRIMARY_MODE_MOVIE);
    Ux_SendEvent(0, NVTEVT_SYSTEM_MODE, 1, System_GetState(SYS_STATE_CURRMODE));
    /* add end by ZMD, 2016-08-25 */
}

void FlowMovie_OnCheckMtkMenuItem()
{
    static UINT32 recordingTime=0;
    static BOOL MenultemFlag=FALSE;
    static UINT32 CounterTemp=0;
    if((UI_GetData(FL_MOVIE_SIZE) != MTKMenuSettingTmp[MENU_MOVIE_RESOLUTION])
            ||(UI_GetData(FL_MOVIE_CYCLIC_REC) != MTKMenuSettingTmp[MENU_MOVIE_CYCLE_RECORD])
            ||(UI_GetData(FL_MOVIE_WDR) != MTKMenuSettingTmp[MENU_MOVIE_HDR])
            ||(UI_GetData(FL_GSENSOR) != MTKMenuSettingTmp[MENU_MOVIE_GSENSOR])
            ||(UI_GetData(FL_MOVIE_PARKING) != MTKMenuSettingTmp[MENU_MOVIE_PARKINGMODE])
            ||(UI_GetData(FL_MOVIE_ADAS_CAL) != MTKMenuSettingTmp[MENU_MOVIE_ADAS])
        #if defined(AUDIO_MIC_SWITCH_SUPPORT) && (AUDIO_MIC_SWITCH_SUPPORT==ENABLE)
            ||(UI_GetData(FL_MOVIE_AUDIO) != MTKMenuSettingTmp[MENU_AUDIO_RECORD_SWITCH])
        #endif
      )//pgl 20160628 add for audio recorder switch
    {

        if((UI_GetData(FL_MOVIE_SIZE) != MTKMenuSettingTmp[MENU_MOVIE_RESOLUTION]))//pgl 20160628 add for audio recorder switch
        {
            debug_msg("^G MENU_MOVIE_RESOLUTION--%d--%d--\r\n",UI_GetData(FL_MOVIE_SIZE),MTKMenuSettingTmp[MENU_MOVIE_RESOLUTION]);
        }
        if((UI_GetData(FL_MOVIE_CYCLIC_REC) != MTKMenuSettingTmp[MENU_MOVIE_CYCLE_RECORD]))//pgl 20160628 add for audio recorder switch
        {
            debug_msg("^G MENU_MOVIE_CYCLE_RECORD--%d--%d--\r\n",UI_GetData(FL_MOVIE_CYCLIC_REC),MTKMenuSettingTmp[MENU_MOVIE_CYCLE_RECORD]);
        }
        if((UI_GetData(FL_MOVIE_WDR) != MTKMenuSettingTmp[MENU_MOVIE_HDR]))//pgl 20160628 add for audio recorder switch
        {
            debug_msg("^G MENU_MOVIE_HDR--%d--%d--\r\n",UI_GetData(FL_MOVIE_WDR),MTKMenuSettingTmp[MENU_MOVIE_HDR]);
        }
        if((UI_GetData(FL_MOVIE_MOTION_DET) != MTKMenuSettingTmp[MENU_MOVIE_MOTION_DET]))//pgl 20160628 add for audio recorder switch
        {
            debug_msg("^G MENU_MOVIE_MOTION_DET--%d--%d--\r\n",UI_GetData(FL_MOVIE_MOTION_DET),MTKMenuSettingTmp[MENU_MOVIE_MOTION_DET]);
        }
        if((UI_GetData(FL_GSENSOR) != MTKMenuSettingTmp[MENU_MOVIE_GSENSOR]))//pgl 20160628 add for audio recorder switch
        {
            debug_msg("^G MENU_MOVIE_GSENSOR--%d--%d--\r\n",UI_GetData(FL_GSENSOR),MTKMenuSettingTmp[MENU_MOVIE_GSENSOR]);
        }
        if((UI_GetData(FL_MOVIE_PARKING) != MTKMenuSettingTmp[MENU_MOVIE_PARKINGMODE]))//pgl 20160628 add for audio recorder switch
        {
            debug_msg("^G MENU_MOVIE_PARKINGMODE--%d--%d--\r\n",UI_GetData(FL_MOVIE_PARKING),MTKMenuSettingTmp[MENU_MOVIE_PARKINGMODE]);
        }
        if((UI_GetData(FL_MOVIE_ADAS_CAL) != MTKMenuSettingTmp[MENU_MOVIE_ADAS]))//pgl 20160628 add for audio recorder switch
        {
            debug_msg("^G MENU_MOVIE_ADAS--%d--%d--\r\n",UI_GetData(FL_MOVIE_ADAS_CAL),MTKMenuSettingTmp[MENU_MOVIE_ADAS]);
        }

        #if defined(AUDIO_MIC_SWITCH_SUPPORT) && (AUDIO_MIC_SWITCH_SUPPORT==ENABLE)
        if((UI_GetData(FL_MOVIE_AUDIO) != MTKMenuSettingTmp[MENU_AUDIO_RECORD_SWITCH]))//pgl 20160628 add for audio recorder switch
        {
            debug_msg("^G MENU_AUDIO_RECORD_SWITCH--%d--%d--\r\n",UI_GetData(FL_MOVIE_AUDIO),MTKMenuSettingTmp[MENU_AUDIO_RECORD_SWITCH]);
        }
        #endif


        CounterTemp++;
        if(CounterTemp>=5)
        {
            CounterTemp=0;
            MenultemFlag=TRUE;
        }
    }
    else
    {
        CounterTemp=0;
    }

    if(MenultemFlag==TRUE)
    {
        switch (gMovData.State)
        {
        case MOV_ST_VIEW:
        case MOV_ST_VIEW|MOV_ST_ZOOM:
            debug_msg("FlowMovie_OnCheckMtkMenuItem--00--:%d..\r\n",SetMovieRecordingFlag);
            if((g_PreviewStable_Record==FALSE)||(gbMovieRecordingFlag==TRUE))
            {
                g_PreviewStable_Record=TRUE;
                gbMovieRecordingFlag=FALSE;
                SetMovieRecordingFlag=TRUE;
            }
            FlowMovie_OnExcuseMtkMenuItem(SetMovieRecordingFlag);
            MenultemFlag=FALSE;
            break;
        case MOV_ST_REC:
        case MOV_ST_REC|MOV_ST_ZOOM:
            debug_msg("FlowMovie_OnCheckMtkMenuItem--11--:%d..\r\n",FlowMovie_GetRecCurrTime());
            if(FlowMovie_GetRecCurrTime() >= 1)
            {
                SetMovieRecordingFlag=TRUE;
                Ux_PostEvent(NVTEVT_KEY_SHUTTER2 , 1, NVTEVT_KEY_PRESS); //stop movie record first
            }
            else
                break;
        }
    }
}
#endif
/* modify end by ZMD, 2017-02-14 */
#if (USE_FILEDB==DISABLE)
static void UIFlowWndMovie_DeleteEmptyFolder(void)
{
 SDCFDIRINFO dirinfo;
 char   path[DCF_FULL_FILE_PATH_LEN];
 UINT32 uiMaxFolderID,uiPrevMaxFolderID;
 UINT32 uiStrlen;
 BOOL ret;


    uiMaxFolderID = DCF_GetDBInfo(DCF_INFO_MAX_DIR_ID);
    // check if folder has file
    ret = DCF_GetDirInfo(uiMaxFolderID,&dirinfo);
    if (ret)
    {
        while (dirinfo.uiNumOfDcfObj==0)
        {
            DCF_GetDirPath(uiMaxFolderID,path);
            uiStrlen = strlen(path);
            path[uiStrlen-1] = '\0';
            if (FileSys_DeleteDir(path) != FST_STA_OK)
            {
                debug_msg("FileSys_DeleteDir failed\r\n");
            }

            DCF_Refresh();

            uiPrevMaxFolderID = uiMaxFolderID;
            // search another Max Empty folder ID
            uiMaxFolderID = DCF_GetDBInfo(DCF_INFO_MAX_DIR_ID);

            // break if getting max folder id is always same
            if (uiPrevMaxFolderID == uiMaxFolderID)
                break;
            // check if folder has file
            ret = DCF_GetDirInfo(uiMaxFolderID,&dirinfo);

            if (ret==FALSE)
              break;
        }
    }
}
#endif

INT32 UIFlowWndMovie_OnExeRecord(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32 uiKeyAct;
    UINT32 uiState;
    BOOL   CheckStorageErr = FALSE;


    // flush key event first
    Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);

    // if HDMI is inserted, DRAM size is not enough for movie recording
    if (UI_GetData(FL_MOVIE_SIZE) == MOVIE_SIZE_FRONT_2880x2160P24)
    {
        if (KeyScan_GetPlugDev() == PLUG_HDMI)
            return NVTEVT_CONSUME;
    }

    if(System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_SAFE)
    {
        if (UI_GetData(FL_CardStatus) == CARD_REMOVED)
        {
            Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD,FLOWWRNMSG_TIMER_2SEC);
            return NVTEVT_CONSUME;
        }
    }
    else if (System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_NORMAL)
    {
         if (GxStrg_GetDeviceCtrl(0, CARD_READONLY)) // card lock
         {
            Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_CARD_LOCKED,FLOWWRNMSG_TIMER_2SEC);
            return NVTEVT_CONSUME;
         }

         if (!GxStrg_GetDeviceCtrl(0, CARD_INSERT)) // card insert
         {
            Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD,FLOWWRNMSG_TIMER_2SEC);
            return NVTEVT_CONSUME;
         }
    }

    if (paramNum>=3)
    {
        uiState = paramArray[2];
    }
    else
    {
        uiState = 0;
    }

    uiKeyAct = paramNum ? paramArray[0] : 0;

    switch (uiKeyAct)
    {
    case NVTEVT_KEY_PRESS:
        //#NT#2016/03/07#KCHong -begin
        //#NT#Low power timelapse function
        #if (TIMELAPSE_LPR_FUNCTION == ENABLE)
        if ((MovieTLLPR_Process(TIMELAPSE_FROM_UI) & TL_FLOW_MASK) == TL_FLOW_LPR)     // TimelapseLPR module will handle recording process
        {
            // For TimelapseLPR OSD display test
            UxCtrl_SetDirty(&UIFlowWndMovieCtrl, TRUE);
            break;
        }
        #endif
        //#NT#2016/03/07#KCHong -end

        switch (gMovData.State)
        {
        case MOV_ST_VIEW:
            //#NT#2016/09/20#Bob Huang -begin
            //#NT#Support HDMI Display with 3DNR Out
            #if (_3DNROUT_FUNC == ENABLE)
            if (MovRec_GetStatus() == MOVREC_STATUS_OPENED_NOT_RECORD || gb3DNROut)
            #else
            if (MovRec_GetStatus() == MOVREC_STATUS_OPENED_NOT_RECORD)
            #endif
            //#NT#2016/09/20#Bob Huang -end
            {
                gMovData.State= MOV_ST_REC;
                if(System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_SAFE)
                {
                    //#NT#2015/08/05#KS Hung -begin
                    //#NT#Even if the DCIM folder is not exist, FileSys_ScanDir stiil return FST_STA_OK.
                    //#NT#When the card is full and it sets cyclic record, it still can't record.
                    //#NT#MediaRec library will automatically delete the files of Car DV folder.
                    //#NT#if the files can't be deleted, it will have LOOPREC_FULL event in the callback.
                    if (SysGetFlag(FL_MOVIE_CYCLIC_REC) == MOVIE_CYCLICREC_OFF)
                    {
                        CheckStorageErr = FlowMovie_IsStorageErr(TRUE);
                    }
                    else
                    {
                        CheckStorageErr = FlowMovie_IsStorageErr(FALSE);
                    }
                    //#NT#2015/08/05#KS Hung -end

                    if (CheckStorageErr == TRUE)
                    {
                        gMovData.State= MOV_ST_WARNING_MENU;
                        gMovData.SysTimeCount = 0;
                        return NVTEVT_CONSUME;
                    }
                }
                if(GetBatteryLevel() == BATTERY_EXHAUSTED)
                {
                    debug_err(("UIFlowWndMovie_OnExeRecord: Battery is too low!\r\n"));
                    return NVTEVT_CONSUME;
                }
                if (FlowMovie_GetSelfTimerID() != NULL_TIMER)
                {
                    FlowMovie_StopRecSelfTimer();
                    return NVTEVT_CONSUME;
                }
                if (SysGetFlag(FL_MOVIE_MOTION_DET) == MOVIE_MOTIONDET_ON)
                    g_uiRecordIngMotionDet = TRUE;
                else
                    g_uiRecordIngMotionDet = FALSE;

                FlowMovie_StartRec();
                #if defined(YQCONFIG_ANDROID_SYSTEM_SUPPORT)
                FlowMovie_UpdateIcons(TRUE);
                #endif

                // start USB detect timer again
                if (g_ACPlug == TRUE)
                    SxTimer_SetFuncActive(SX_TIMER_DET_USB_ID, TRUE);
                }
            break;
        case MOV_ST_REC:
        case MOV_ST_REC|MOV_ST_ZOOM:
            UxCtrl_SetShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl, FALSE);
            #if _ADAS_FUNC_
            g_uiAdasAlertSecCnt = 0;
            #endif

            // Isiah, implement YUV merge mode of recording func.
            //if (FlowMovie_GetRecCurrTime() >= 1)
            {
                // Mask key during movie stop flow.
                Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);
                Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);
                FlowMovie_StopRec();

                // update ui window icon
                FlowMovie_UpdateIcons(TRUE);

                if (uiState==UIFlowWndMovie_Restart_Rec)
                {
                    // Enable key if user pressed shutter2 key to stop recording.
                    Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);

                    #if (_KEY_METHOD_ == _KEY_METHOD_4KEY_)
                    Ux_PostEvent(NVTEVT_KEY_SHUTTER2 , 1, NVTEVT_KEY_PRESS);
                    #else
                    Ux_PostEvent(NVTEVT_KEY_SELECT, 1, NVTEVT_KEY_PRESS);
                    #endif
                }
                else
                {
                    if (SysGetFlag(FL_MOVIE_MOTION_DET) == MOVIE_MOTIONDET_ON)
                    {
                        if (g_uiRecordIngMotionDet == TRUE)
                        {
                            g_uiRecordIngMotionDet = FALSE;
                            //#NT#2016/11/01#Adam Su -begin
                            //#NT#fix mantis issue 0106933
                            UI_SetData(FL_MOVIE_MOTION_DET, MOVIE_MOTIONDET_OFF);
                            //#NT#2016/11/01#Adam Su -end
                        }
                    }
                }
            }
            break;
        }
        break;
    }
    #if (_KEY_METHOD_ == _KEY_METHOD_4KEY_)
    Ux_DefaultEvent(pCtrl,NVTEVT_KEY_SHUTTER2,paramNum,paramArray);
    #else
    Ux_DefaultEvent(pCtrl,NVTEVT_KEY_SELECT,paramNum,paramArray);
    #endif
    return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnExeZoomIn(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiKeyAct;

    uiKeyAct = paramNum ? paramArray[0] : 0;

    debug_ind(("[UIFlowWndMovie_OnExeZoomIn][%d]\n\r", uiKeyAct));

    switch (uiKeyAct)
    {
    case NVTEVT_KEY_PRESS:
    case NVTEVT_KEY_CONTINUE:
        if (0)//((Photo_GetDZoomIdx()-10) > UI_DZOOM_IDX_MAX)
        {
            Ux_SendEvent(&CustomPhotoObjCtrl,NVTEVT_EXE_ZOOM,2, UI_ZOOM_CTRL_STOP, UI_GetData(FL_Dzoom));
            gMovData.State &= ~MOV_ST_ZOOM;
            return NVTEVT_PASS;
        }
        switch (gMovData.State)
        {
        case MOV_ST_VIEW:
        case MOV_ST_REC:
        case MOV_ST_VIEW | MOV_ST_ZOOM:
        case MOV_ST_REC | MOV_ST_ZOOM:
            /* set Digital Zoom interface */
            UI_SetData(FL_ZoomIFIndex,ZOOM_IF_DIGITAL);

            gMovData.State |= MOV_ST_ZOOM;
            Ux_SendEvent(&CustomPhotoObjCtrl,NVTEVT_EXE_ZOOM,2, UI_ZOOM_CTRL_IN, UI_GetData(FL_Dzoom));
            break;
        }
        break;

    case NVTEVT_KEY_RELEASE:
        switch (gMovData.State)
        {
        case MOV_ST_VIEW | MOV_ST_ZOOM:
        case MOV_ST_REC | MOV_ST_ZOOM:
            Ux_SendEvent(&CustomPhotoObjCtrl,NVTEVT_EXE_ZOOM,2, UI_ZOOM_CTRL_STOP, UI_GetData(FL_Dzoom));
            gMovData.State &= ~MOV_ST_ZOOM;
            break;
        }
        break;
    }
    return NVTEVT_PASS;
}

INT32 UIFlowWndMovie_OnExeZoomOut(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiKeyAct;

    uiKeyAct = paramNum ? paramArray[0] : 0;

    debug_ind(("[UIFlowWndMovie_OnExeZoomOut][%d]\n\r", uiKeyAct));

    switch (uiKeyAct)
    {
    case NVTEVT_KEY_PRESS:
    case NVTEVT_KEY_CONTINUE:
        switch (gMovData.State)
        {
        case MOV_ST_VIEW:
        case MOV_ST_REC:
        case MOV_ST_VIEW | MOV_ST_ZOOM:
        case MOV_ST_REC | MOV_ST_ZOOM:
             /* set Digital Zoom interface */
             UI_SetData(FL_ZoomIFIndex,ZOOM_IF_DIGITAL);

             gMovData.State |= MOV_ST_ZOOM;
             Ux_SendEvent(&CustomPhotoObjCtrl,NVTEVT_EXE_ZOOM,2, UI_ZOOM_CTRL_OUT, UI_GetData(FL_Dzoom));
            break;
        }
        break;

    case NVTEVT_KEY_RELEASE:
        switch (gMovData.State)
        {
        case MOV_ST_VIEW | MOV_ST_ZOOM:
        case MOV_ST_REC | MOV_ST_ZOOM:
            Ux_SendEvent(&CustomPhotoObjCtrl,NVTEVT_EXE_ZOOM,2, UI_ZOOM_CTRL_STOP, UI_GetData(FL_Dzoom));
            gMovData.State &= ~MOV_ST_ZOOM;
            break;
        }
        break;
    }
    return NVTEVT_PASS;
}


void UIFlowWndMovie_Initparam(void)
{
    // The same effect as Photo mode
    Ux_SendEvent(&CustomPhotoObjCtrl,   NVTEVT_EXE_WB,                  1,  SysGetFlag(FL_WB));

    // The other settings
    Ux_SendEvent(&CustomPhotoObjCtrl,   NVTEVT_EXE_COLOR,               1,  MOVIE_COLOR_NORMAL);

    /* Video resolution setting must be set after other IQ settings */
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIESIZE,           1,  SysGetFlag(FL_MOVIE_SIZE));

    /* Cyclic recording/record with mute or sound/DateImptint/Motion Detect */
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_CYCLIC_REC,          1,  SysGetFlag(FL_MOVIE_CYCLIC_REC));
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOTION_DET,          1,  SysGetFlag(FL_MOVIE_MOTION_DET));
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_DATE_IMPRINT,  1,  SysGetFlag(FL_MOVIE_DATEIMPRINT));
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_AUDIO,         1,  SysGetFlag(FL_MOVIE_AUDIO));
    Ux_SendEvent(&CustomPhotoObjCtrl,   NVTEVT_EXE_EV,                  1,  SysGetFlag(FL_EV));
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_MCTF,          1,  SysGetFlag(FL_MovieMCTFIndex));
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_WDR,           1,  SysGetFlag(FL_MOVIE_WDR));
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_HDR,           1,  SysGetFlag(FL_MOVIE_HDR));
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_GSENSOR,             1,  SysGetFlag(FL_GSENSOR));
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_SENSOR_ROTATE, 1,  SysGetFlag(FL_MOVIE_SENSOR_ROTATE));
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_IR_CUT,        1,  SysGetFlag(FL_MOVIE_IR_CUT));
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_PROTECT_AUTO,  1,  SysGetFlag(FL_MOVIE_URGENT_PROTECT_AUTO));
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_PROTECT_MANUAL,1,  SysGetFlag(FL_MOVIE_URGENT_PROTECT_MANUAL));
    #if defined(YQCONFIG_ANDROID_SYSTEM_SUPPORT)
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_LDWS,          1,  SysGetFlag(FL_MOVIE_ADAS_CAL));
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_FCW,           1,  SysGetFlag(FL_MOVIE_ADAS_CAL));
    #else
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_LDWS,          1,  SysGetFlag(FL_MOVIE_LDWS));
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_FCW,           1,  SysGetFlag(FL_MOVIE_FCW));
    #endif
    Ux_SendEvent(&UISetupObjCtrl,       NVTEVT_EXE_FREQ,                1,  SysGetFlag(FL_FREQUENCY));

//#NT#2016/10/13#Brain Yen -begin
//#NT#Set rear sensor is mono in Subei project
    #if (_MODEL_DSC_ == _MODEL_SUBEI_TFH9_)
        IPL_AlgSetUIInfo(1, IPL_SEL_IMAGEEFFECT, SEL_IMAGEEFFECT_BW);
    #endif
//#NT#2016/10/13#Brain Yen -end
}

static BOOL g_bDelayUpdateIcon = FALSE;

INT32 UIFlowWndMovie_OnOpen(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    #if defined(YQCONFIG_ANDROID_SYSTEM_SUPPORT)
    UINT8   uiResqData[16]= {0};
    static BOOL firstPowerOn=TRUE;
    #endif
    static BOOL gbParkingModeTrigFlag=TRUE;
    //#NT#2016/03/07#KCHong -begin
    //#NT#Low power timelapse function, do not show OSD if boot from alarm
    #if (TIMELAPSE_LPR_FUNCTION == ENABLE)
    if (MovieTLLPR_CheckHWRTStatus() == TL_HWRT_BOOT_ALARM)
    {
        UxCtrl_SetAllChildShow(pCtrl, FALSE);
        return NVTEVT_CONSUME;
    }
    #endif
    //#NT#2016/03/07#KCHong -end
   

    //#NT#2015/07/17#KS Hung -begin
    //#NT#For ADAS
    UxCtrl_SetShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl, FALSE);
    UxCtrl_SetShow(&UIFlowWndMovie_Panel_Normal_DisplayCtrl, TRUE);
    //#NT#2015/07/17#KS Hung -end

    Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);
    /* Init window key mask variables & set key and key released mask */
    g_uiMaskKeyPress = MOVIE_KEY_PRESS_MASK;
    g_uiMaskKeyRelease = MOVIE_KEY_RELEASE_MASK;
    Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);
    Input_SetKeyMask(KEY_RELEASE, g_uiMaskKeyPress);
    Input_SetKeyMask(KEY_CONTINUE, g_uiMaskKeyPress);

    #if (GSENSOR_FUNCTION == ENABLE)
    if(UI_GetData(FL_MOVIE_SIZE) == MOVIE_SIZE_FRONT_640x480P240
        && UI_GetData(FL_GSENSOR) != GSENSOR_OFF)
    {
        UI_SetData(FL_GSENSOR,GSENSOR_OFF);
        DBG_ERR("G-Sensor is not support on fps=240, because i2c is too busy.\r\n");
    }
    //MUST open before UIFlowWndMovie_Initparam, because Initparam call GSensor_SetSensitivity.
    GSensor_open();
    #endif

    if(System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_SAFE)
    {
        #if USE_FILEDB
        if (UI_GetData(FL_IsUseFileDB))
        {
           Ux_SendEvent(&UISetupObjCtrl,NVTEVT_FILEID_RESET,0);
        }
        #endif
    }
    UIFlowWndMovie_Initparam();

    if(System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_SAFE)
    {
        #if(ONVIF_PROFILE_S!=ENABLE) //No File System
        if(UIStorageCheck(STORAGE_CHECK_ERROR, NULL) == TRUE)
        {
            #if defined(YQCONFIG_ANDROID_SYSTEM_SUPPORT)
            Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD, FLOWWRNMSG_TIMER_2SEC);
            #else
           Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD, FLOWWRNMSG_TIMER_KEEP);
            #endif
        }
        #endif
    }

    // update g_uiRecordIngMotionDet flag
    if (gUIMotionDetTimerID == NULL_TIMER)
    {
        gUIMotionDetTimerID = GxTimer_StartTimer(TIMER_HALF_SEC, NVTEVT_05SEC_TIMER, CONTINUE);
    }

    if (g_uiDateTimerID == NULL_TIMER)
    {
        g_uiDateTimerID = GxTimer_StartTimer(TIMER_ONE_SEC, NVTEVT_1SEC_TIMER, CONTINUE);
    }

    // Enable Motion Detect function in starting up movie mode
    if (SysGetFlag(FL_MOVIE_MOTION_DET) == MOVIE_MOTIONDET_ON)
        g_uiRecordIngMotionDet = TRUE;
    else
        g_uiRecordIngMotionDet = FALSE;

    // delete empty folder
    #if (USE_FILEDB==DISABLE)
    UIFlowWndMovie_DeleteEmptyFolder();
    #endif

    Ux_DefaultEvent(pCtrl,NVTEVT_OPEN_WINDOW,paramNum,paramArray);

#if ((POWERON_FAST_WIFI != ENABLE) && (POWERON_FAST_RECORD == ENABLE))
    if(System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_NORMAL)
    {
        // fast record
        UINT32 paramArray[1] = {NVTEVT_KEY_PRESS};
        UIFlowWndMovie_OnExeRecord(pCtrl, 1, paramArray);
    }

    if(System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_SAFE)
    {
        FlowMovie_UpdateIcons(TRUE);
    }
    else
    {
        FlowMovie_UpdateIcons(FALSE);
        UI_SetDisplayFlip(FALSE);
        g_bDelayUpdateIcon = TRUE;
    }
#else
    FlowMovie_UpdateIcons(TRUE);
#endif

    #if defined(YQCONFIG_UART_TO_MTK_SUPPORT) && defined(YQCONFIG_ANDROID_SYSTEM_SUPPORT)
    Display_SetEnable(LAYER_VDO1, TRUE);
    MTKMenuSettingTmp[MENU_MOVIE_RESOLUTION]=UI_GetData(FL_MOVIE_SIZE);
    MTKMenuSettingTmp[MENU_MOVIE_CYCLE_RECORD]=UI_GetData(FL_MOVIE_CYCLIC_REC);
    MTKMenuSettingTmp[MENU_MOVIE_HDR]=UI_GetData(FL_MOVIE_WDR);
    MTKMenuSettingTmp[MENU_MOVIE_GSENSOR]=UI_GetData(FL_GSENSOR);
    MTKMenuSettingTmp[MENU_MOVIE_PARKINGMODE]=UI_GetData(FL_MOVIE_PARKING);
    MTKMenuSettingTmp[MENU_MOVIE_ADAS]=UI_GetData(FL_MOVIE_ADAS_CAL);
    #if defined(AUDIO_MIC_SWITCH_SUPPORT) && (AUDIO_MIC_SWITCH_SUPPORT==ENABLE)
    MTKMenuSettingTmp[MENU_AUDIO_RECORD_SWITCH]=UI_GetData(FL_MOVIE_AUDIO) ;
    #endif
    if((GxSystem_GetPowerOnSource() == GX_PWRON_SRC_PWR_VBAT))
    {
        if(gbParkingModeTrigFlag==TRUE)
        {
            /* modify begin by ZMD, 2017-03-09 */
            #if defined(YQCONFIG_PARKING_MODE_SUPPORT)
            if(GxUSB_GetIsUSBPlug()==FALSE)
            {
                ParkingCaptrueFlag=TRUE;
                // GxTimer_StopTimer(&gUIMotionDetTimerID);
                //GxTimer_StopTimer(&g_uiDateTimerID);
                //System_PowerOff(SYS_POWEROFF_NORMAL);
            }
            else
            {
                debug_msg("====>USB Det pin is high ,do not power down..keep going..\r\n");
                //UIFlowWndMovie_OnDeleteOld();
            }
            debug_msg("Power On by Gsensor...\r\n");
            gbParkingModeTrigFlag=FALSE;
            //gbNeedToPowerOff=TRUE;
            uiResqData[0]= 0;
            MTKComposeCMDRspFrame(0, CMD_GSENSOR_TRIG,(UINT8 *)&uiResqData, 1);
            //Here we need to set P_GPIO7 10ms,then clear P_GPIO7 to tell Android 663 is G-sensor powerOn.
            #if defined(YQCONFIG_GPIO_GSENSOR_POWERON_ANDROID_SUPPORT)
            GPIO_GSENSOR_POWERON_ANDROID();		//yliu
            #endif

            #else

            if(GxUSB_GetIsUSBPlug()==FALSE)
            {
                GxTimer_StopTimer(&gUIMotionDetTimerID);
                GxTimer_StopTimer(&g_uiDateTimerID);
                System_PowerOff(SYS_POWEROFF_NORMAL);
            }
            else
            {
                debug_msg("====>USB Det pin is high ,do not power down..keep going..\r\n");
                //UIFlowWndMovie_OnDeleteOld();
            }
            #endif
            /* modify end by ZMD, 2017-03-09 */
        }
    }
    else
    {
        #if 1 //#stephen mark -20160421
        if(firstPowerOn==TRUE)
        {
            firstPowerOn=FALSE;
            UIFlowwndDeleteFWFile();
        }
        #endif
        //UIFlowWndMovie_OnDeleteOld();
    }
    #endif
   
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnClose(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{

    //#NT#2016/06/08#Lincy Lin -begin
    //#NT#Implement generic OSD and video drawing mechanism for ALG function
    UIFlowWndMovie_ALG_ClearDraw();
    //#NT#2016/06/08#Lincy Lin -end
    switch (gMovData.State)
    {
    case MOV_ST_REC:
    case MOV_ST_REC|MOV_ST_ZOOM:
        if (FlowMovie_GetRecCurrTime() <= 1)
        {
            Delay_DelayMs(1000);
        }
        FlowMovie_StopRec();
        Ux_SendEvent(&UIFlowWndMovieCtrl,NVTEVT_CB_MOVIE_FINISH,0);
        break;
    }

    g_bRedLEDOn = FALSE;
    //KeyScan_TurnOffLED(KEYSCAN_LED_RED);

    if (gUIMotionDetTimerID!=NULL_TIMER)
    {
        GxTimer_StopTimer(&gUIMotionDetTimerID);
    }

    if (g_uiDateTimerID != NULL_TIMER)
    {
        GxTimer_StopTimer(&g_uiDateTimerID);
    }

    #if defined(YQCONFIG_ANDROID_SYSTEM_SUPPORT)||defined(YQCONFIG_PARKING_MODE_SUPPORT)
    #else
    #if (GSENSOR_FUNCTION == ENABLE)
    GSensor_close();
    #endif
    #endif

    Ux_DefaultEvent(pCtrl,NVTEVT_CLOSE_WINDOW,paramNum,paramArray);
    return NVTEVT_CONSUME;
}
//#NT#2016/06/08#Lincy Lin -begin
//#NT#Implement generic OSD and video drawing mechanism for ALG function
static void UIFlowWndMovie_OnALGEnd(void)
{
    UxCtrl_SetShow(&UIFlowWndMovie_ALG_DrawCtrl,TRUE);
    /* Redraw all window OSD */
    UxCtrl_SetDirty(&UIFlowWndMovieCtrl, TRUE);
}
//#NT#2016/06/08#Lincy Lin -end
INT32 UIFlowWndMovie_OnUpdateInfo(VControl * pCtrl, UINT32 paramNum, UINT32 * paramArray)
{
    if (paramNum == 0)
        return NVTEVT_CONSUME;
    switch (paramArray[0])
    {
        //#NT#2016/06/08#Lincy Lin -begin
        //#NT#Implement generic OSD and video drawing mechanism for ALG function
        case UIAPPPHOTO_CB_ALGEND:
            UIFlowWndMovie_OnALGEnd();
            break;
        //#NT#2016/06/08#Lincy Lin -end
        #if (YQCONFIG_ANDROID_SYSTEM_SUPPORT)
    case NVTEVT_EXE_UPDATEUIINFO:
        guiMovieTouchUIDisplayCounter=0;
        gbMovieTouchUIDisplayEn=TRUE;
        FlowMovie_UpdateIcons(TRUE);
        break;
    case NVTEVT_EXE_UPDATEUIINFO1:
        guiMovieTouchUIDisplayCounter=0;
        gbMovieTouchUIDisplayEn=FALSE;
        FlowMovie_UpdateIcons(FALSE);
        break;
        #endif
        default:
            DBG_ERR("Unknown CB %d\r\n",paramArray[0]);
    }

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnKeyNext(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    // next key
    UINT32  uiKeyAct;
    UINT32  uiSoundMask;
    UINT32  uiWidth  = GetMovieSizeWidth(UI_GetData(FL_MOVIE_SIZE));

    uiKeyAct = paramArray[0];

    switch (uiKeyAct)
    {
      case NVTEVT_KEY_PRESS:
        switch(gMovData.State)
        {
        case MOV_ST_VIEW:
        case MOV_ST_VIEW|MOV_ST_ZOOM:
            // stope timer when entering menu
            if (gUIMotionDetTimerID!=NULL_TIMER)
            {
                GxTimer_StopTimer(&gUIMotionDetTimerID);
            }

            if (g_uiDateTimerID != NULL_TIMER)
            {
                GxTimer_StopTimer(&g_uiDateTimerID);
            }

            // Enable shutter2 sound (Select key as OK key in menu)
            uiSoundMask = Input_GetKeySoundMask(KEY_PRESS);
            uiSoundMask |= FLGKEY_ENTER;
            Input_SetKeySoundMask(KEY_PRESS, uiSoundMask);
            Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);

            // Open common mix (Item + Option) menu
            Ux_OpenWindow((VControl *)(&MenuCommonItemCtrl), 0);
            gMovData.State = MOV_ST_MENU;
            break;
        case MOV_ST_REC:
        case MOV_ST_REC|MOV_ST_ZOOM:
            if (SysGetFlag(FL_MOVIE_URGENT_PROTECT_MANUAL)==MOVIE_URGENT_PROTECT_MANUAL_ON)
            {
#if (MOVIE_MULTI_RECORD_FUNC)
                if(GetMovieRecType_2p(UI_GetData(FL_MOVIE_SIZE))==MOVIE_REC_TYPE_DUAL
                    || GetMovieRecType_2p(UI_GetData(FL_MOVIE_SIZE))==MOVIE_REC_TYPE_CLONE)
                {
                   DBG_DUMP("dual record, only support set crash\r\n");
				   MovRec_SetCrash();
                   Ux_DefaultEvent(pCtrl,NVTEVT_KEY_NEXT,paramNum,paramArray);
                   return NVTEVT_CONSUME;
                }
#endif

                if ((uiWidth <= 1920) && (UI_GetData(FL_MOVIE_CYCLIC_REC) != MOVIE_CYCLICREC_OFF))
                {
                    DBG_DUMP("process flash video record!!!\r\n");
                    MovRec_StopFlash(0);
                }
                else
                {
                    DBG_DUMP("Set Crash!!!\r\n");
                    MovRec_SetCrash();
                }
            }
            else if (SysGetFlag(FL_MOVIE_PIM)==MOVIE_PIM_ON)
            {
                UINT32 uiJpegWidth, uiJpegHeight, uiDAR, uiMovieSize;

                FlowMovie_DrawPIM(TRUE);
                {
                    uiMovieSize = UI_GetData(FL_MOVIE_SIZE);
                    uiJpegWidth = GetMovieSizeWidth(uiMovieSize);
                    uiJpegHeight = GetMovieSizeHeight(uiMovieSize);
                    uiDAR = GetMovieDispAspectRatio(uiMovieSize);
                }
                if (uiDAR == VIDENC_DAR_16_9)
                {
                    uiJpegWidth = (uiJpegHeight * 16) / 9;
                }

                Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_REC_RAWENC, 2, uiJpegWidth, uiJpegHeight);
            }
            break;
        }
        break;
    }
    Ux_DefaultEvent(pCtrl,NVTEVT_KEY_NEXT,paramNum,paramArray);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnKeySelect(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiKeyAct;

    // Similar to Shutter2 key
    uiKeyAct = paramArray[0];
    switch(uiKeyAct)
    {
        case NVTEVT_KEY_PRESS:
        {
            /*
            if (gMovData.State==MOV_ST_VIEW)
            {
                gMovData.State=MOV_ST_REC;

            }
            else if (gMovData.State==MOV_ST_REC)
            {
                gMovData.State=MOV_ST_VIEW;
                // update ui window icon
                FlowMovie_UpdateIcons(TRUE);
            }
            */
            UIFlowWndMovie_OnExeRecord(pCtrl,paramNum,paramArray);
        }
        break;
    }
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnKeyMenu(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiKeyAct;
    UINT32  uiSoundMask;

    uiKeyAct = paramArray[0];

    switch (uiKeyAct)
    {
      case NVTEVT_KEY_PRESS:
        switch(gMovData.State)
        {
        case MOV_ST_VIEW:
        case MOV_ST_VIEW|MOV_ST_ZOOM:
            // stope timer when entering menu
            if (gUIMotionDetTimerID!=NULL_TIMER)
            {
                GxTimer_StopTimer(&gUIMotionDetTimerID);
            }

            if (g_uiDateTimerID != NULL_TIMER)
            {
                GxTimer_StopTimer(&g_uiDateTimerID);
            }
            // enable shutter2 sound (shutter2 as OK key in menu)
            uiSoundMask = Input_GetKeySoundMask(KEY_PRESS);
            uiSoundMask |= FLGKEY_ENTER;
            Input_SetKeySoundMask(KEY_PRESS, uiSoundMask);

            Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);
            // Open common mix (Item + Option) menu
            Ux_OpenWindow((VControl *)(&MenuCommonItemCtrl), 0);
            gMovData.State = MOV_ST_MENU;
            break;
        }
        break;
    }
    Ux_DefaultEvent(pCtrl,NVTEVT_KEY_MENU,paramNum,paramArray);
    return NVTEVT_CONSUME;
}
//INT32 UIFlowWndMovie_OnKeyEnter(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
//{
//    return NVTEVT_CONSUME;
    //return UIFlowWndMovie_OnExeRecord(pCtrl,paramNum,paramArray);
//}
INT32 UIFlowWndMovie_OnKeyDown(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if ( (_MODEL_DSC_ == _MODEL_WiFiSDV_) || (_MODEL_DSC_ == _MODEL_FIREFLY_) || (_MODEL_DSC_ == _MODEL_FIREFLY_665_))
    return UIFlowWndMovie_OnExeRecord(pCtrl,paramNum,paramArray);
#endif
    return NVTEVT_CONSUME;
}
#if 0
INT32 UIFlowWndMovie_OnKeyLeft(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiKeyAct;
    UINT32  uiEV;

    uiKeyAct = paramNum ? paramArray[0] : 0;

    switch (uiKeyAct)
    {
    case NVTEVT_KEY_PRESS:
         switch(gMovData.State)
         {
            case MOV_ST_VIEW:
            case MOV_ST_VIEW|MOV_ST_ZOOM:
                uiEV = SysGetFlag(FL_EV);
                if (uiEV==EV_N20)
                {
                    SysSetFlag(FL_EV,EV_P20);
                } else {
                    SysSetFlag(FL_EV,++uiEV);
                }
                Ux_SendEvent(&CustomMovieObjCtrl,NVTEVT_EXE_MOVIE_EV,1, SysGetFlag(FL_EV));
                FlowMovie_IconDrawEV(&UIFlowWndMovie_StatusICN_EVCtrl);
            break;
            case MOV_ST_REC:
                if(SysGetFlag(FL_MOVIE_CYCLIC_REC) != MOVIE_CYCLICREC_OFF && FlowMovie_GetRecCurrTime() >= 1)
                {
                    #if (0)//(PRJ == APC3)
                        g_bSpeLockFun = TRUE;
                        FlowMovie_StopRec();
                        Ux_SendEvent(pCtrl,NVTEVT_CB_MOVIE_FINISH,1,UIFlowWndMovie_Restart_Rec);
                    #endif
                }
            break;
         }
        break;
    }

    return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnKeyRight(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
 UINT32  uiKeyAct;

    uiKeyAct = paramArray[0];

    switch(uiKeyAct)
    {
     case NVTEVT_KEY_PRESS:
         switch(gMovData.State)
         {
            case MOV_ST_REC:
            case MOV_ST_REC|MOV_ST_ZOOM:
                {
                    UINT32 uiJpegWidth, uiJpegHeight, uiDAR, uiMovieSize;

                    FlowMovie_DrawPIM(TRUE);
                    {
                        uiMovieSize = UI_GetData(FL_MOVIE_SIZE);
                        uiJpegWidth = GetMovieSizeWidth(uiMovieSize);
                        uiJpegHeight = GetMovieSizeHeight(uiMovieSize);
                        uiDAR = GetMovieDispAspectRatio(uiMovieSize);
                    }
                    if (uiDAR == VIDENC_DAR_16_9)
                    {
                        uiJpegWidth = (uiJpegHeight * 16) / 9;
                    }
                    Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_REC_RAWENC, 2, uiJpegWidth, uiJpegHeight);
                }
                break;
         }
         break;
      // Enter menu
      default:
        Ux_PostEvent(NVTEVT_KEY_MENU, 1, NVTEVT_KEY_PRESS);
        break;
    }

    return NVTEVT_CONSUME;
}
#endif
INT32 UIFlowWndMovie_OnChildClose(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiSoundMask;

    switch (gMovData.State)
    {
    case MOV_ST_WARNING_MENU:
         if(paramNum > 0)
            {
                if(paramArray[0] == NVTRET_ENTER_MENU)
                {
                    /* Create Menu window */
                    gMovData.State = MOV_ST_MENU;
                    Ux_OpenWindow(&MenuCommonItemCtrl, 0);
                    return NVTEVT_CONSUME;
            }
            #if defined(YQCONFIG_ANDROID_SYSTEM_SUPPORT)
            else if(paramArray[0] == NVTRET_WAITMOMENT)
            {
                if(paramArray[1]==NVTRET_FORMAT)
                {
                    if(gbMovieRecFormatFlag==TRUE)
                    {
                        gbMovieRecFormatFlag=FALSE;
                        UIFlowwndMovieSetNeedToRecordFlag(TRUE);
                    }
                    FlowMovie_UpdateIcons(TRUE);
                }
            }
            else if(paramArray[0] == NVTRET_WARNING)
            {
                FlowMovie_UpdateIcons(TRUE);
                UIFlowwndMovieSetNeedToRecordFlag(TRUE);
            }
            #endif
            }
            gMovData.State = MOV_ST_VIEW;
        break;

    case MOV_ST_MENU:
        // disable shutter2 sound
        uiSoundMask = Input_GetKeySoundMask(KEY_PRESS);
        uiSoundMask &= ~FLGKEY_ENTER;
        Input_SetKeySoundMask(KEY_PRESS, uiSoundMask);

         g_uiMaskKeyPress = MOVIE_KEY_PRESS_MASK;
         g_uiMaskKeyRelease = MOVIE_KEY_RELEASE_MASK;
         Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);
         Input_SetKeyMask(KEY_RELEASE, g_uiMaskKeyRelease);
         FlowMovie_UpdateIcons(TRUE);

         // start timer again when exiting menu
         if (gUIMotionDetTimerID==NULL_TIMER)
         {
           gUIMotionDetTimerID = GxTimer_StartTimer(TIMER_HALF_SEC, NVTEVT_05SEC_TIMER, CONTINUE);
         }

         if (g_uiDateTimerID == NULL_TIMER)
         {
           g_uiDateTimerID = GxTimer_StartTimer(TIMER_ONE_SEC, NVTEVT_1SEC_TIMER, CONTINUE);
         }

         // Enable Motion Detect function in starting up movie mode
         if (SysGetFlag(FL_MOVIE_MOTION_DET) == MOVIE_MOTIONDET_ON)
            g_uiRecordIngMotionDet = TRUE;
         else
            g_uiRecordIngMotionDet = FALSE;

         gMovData.State = MOV_ST_VIEW;
        break;
    }
    #if defined(YQCONFIG_ANDROID_SYSTEM_SUPPORT)
    guiMovieTouchUIDisplayCounter=0;
    #endif
    Ux_DefaultEvent(pCtrl,NVTEVT_CHILD_CLOSE,paramNum,paramArray);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnKeyShutter2(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return UIFlowWndMovie_OnExeRecord(pCtrl,paramNum,paramArray);
}
INT32 UIFlowWndMovie_OnKeyZoomin(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return UIFlowWndMovie_OnExeZoomIn(pCtrl,paramNum,paramArray);
}
INT32 UIFlowWndMovie_OnKeyZoomout(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return UIFlowWndMovie_OnExeZoomOut(pCtrl,paramNum,paramArray);
}
INT32 UIFlowWndMovie_OnKeyUp(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return UIFlowWndMovie_OnExeZoomIn(pCtrl, paramNum, paramArray);
}
INT32 UIFlowWndMovie_OnKeyPlayBack(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{

    // Don't stop movie recording
    switch(gMovData.State)
    {
      case MOV_ST_VIEW:
      case MOV_ST_VIEW|MOV_ST_ZOOM:
        // mask key while changing primary mode
        Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);

        Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);
        Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);
        Input_SetKeyMask(KEY_CONTINUE, FLGKEY_KEY_MASK_NULL);
        // changing primary mode
        Ux_SendEvent(&UISetupObjCtrl,NVTEVT_FORCETO_PLAYBACK_MODE,0);
        break;
    }

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnBattery(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    /* modify begin by ZMD, 2017-02-15 */
    #if defined(YQCONFIG_ANDROID_SYSTEM_SUPPORT)
    #else
    static volatile BOOL bBatteryOn = FALSE;

    UxState_SetData(&UIFlowWndMovie_Status_batteryCtrl,STATE_CURITEM,GetBatteryLevel());
    if (KeyScan_IsACIn())
    {
        bBatteryOn = !bBatteryOn;
        UxCtrl_SetShow(&UIFlowWndMovie_Status_batteryCtrl,bBatteryOn);
    }
    else
    {
        UxCtrl_SetShow(&UIFlowWndMovie_Status_batteryCtrl,TRUE);
    }

    #endif
    /* modify end by ZMD, 2017-02-15 */

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnBatteryLow(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_BATTERY_LOW, FLOWWRNMSG_TIMER_2SEC);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnKeyMode(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    // Don't stop movie recording
    switch(gMovData.State)
    {
      case MOV_ST_VIEW:
      case MOV_ST_VIEW|MOV_ST_ZOOM:
        // mask key while changing primary mode
        Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);
        Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);
        Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);
        Input_SetKeyMask(KEY_CONTINUE, FLGKEY_KEY_MASK_NULL);
        // changing primary mode
        Ux_SendEvent(&UISetupObjCtrl,NVTEVT_EXE_CHANGEDSCMODE,1,DSCMODE_CHGTO_NEXT);
        break;
        /* modify begin by ZMD, 2017-02-15 new version management*/
        #if defined(YQCONFIG_ANDROID_SYSTEM_SUPPORT)
    case MOV_ST_REC:
    case MOV_ST_REC|MOV_ST_ZOOM:
        FlowMovie_StopRec();
        if(gbGsensorTrig==TRUE)
            gbGsensorTrig=FALSE;
        //bNeed2RestartRecord=TRUE;
        // mask key while changing primary mode
        Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);
        Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);
        Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);
        Input_SetKeyMask(KEY_CONTINUE, FLGKEY_KEY_MASK_NULL);
        // changing primary mode
        Ux_SendEvent(&UISetupObjCtrl,NVTEVT_EXE_CHANGEDSCMODE,1,DSCMODE_CHGTO_NEXT);
        break;

        #endif
        /* modify end by ZMD, 2017-02-15 */

    }
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnMovieFinish(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiFolderId=0, uiFileId=0;
    BOOL    CheckStorageErr;
    //UINT32  gUIAviRecMaxTime;

    switch (gMovData.State)
    {
      case MOV_ST_REC:
      case MOV_ST_REC|MOV_ST_ZOOM:
            #if 0
            if(UIStorageCheck(STORAGE_CHECK_FULL, &(gUIAviRecMaxTime)) != TRUE)
            {
                DCF_GetNextID(&uiFolderId, &uiFileId);
                SysSetFlag(FL_DCF_DIR_ID, uiFolderId);
                SysSetFlag(FL_DCF_FILE_ID, uiFileId);
            }
            #endif

            //#NT#2016/09/20#Bob Huang -begin
            //#NT#Support HDMI Display with 3DNR Out
            //call stop rec first before starting to rec, keep rec mode
            #if (_3DNROUT_FUNC == ENABLE)
            if(!gb3DNROut)
            #endif
            //#NT#2016/09/20#Bob Huang -end
            {
                gMovData.State = MOV_ST_VIEW;
            }

            //#NT#2012/10/23#Philex Lin - begin
            // enable auto power off/USB detect timer
            KeyScan_EnableMisc(TRUE);
            //#NT#2012/10/23#Philex Lin - end
            FlowMovie_IconDrawMaxRecTime(&UIFlowWndMovie_Static_maxtimeCtrl);
            UxState_SetData(&UIFlowWndMovie_Status_RECCtrl,STATE_CURITEM,UIFlowWndMovie_Status_REC_ICON_REC_TRANSPAENT);

            //if (FlowMovie_ChkDrawStoreFullFolderFull() == FALSE)
            if (SysGetFlag(FL_MOVIE_CYCLIC_REC) == MOVIE_CYCLICREC_OFF)
            {
                CheckStorageErr = FlowMovie_IsStorageErr(TRUE);
            }
            else
            {
                CheckStorageErr = FlowMovie_IsStorageErr(FALSE);
            }
            if (CheckStorageErr == FALSE)
            {
                DCF_GetNextID(&uiFolderId, &uiFileId);
                SysSetFlag(FL_DCF_DIR_ID, uiFolderId);
                SysSetFlag(FL_DCF_FILE_ID, uiFileId);

                //#NT#2016/03/07#KCHong -begin
                //#NT#Low power timelapse function
                #if (TIMELAPSE_LPR_FUNCTION == ENABLE)
                if (UI_GetData(FL_MOVIE_TIMELAPSE_REC) < TL_LPR_TIME_MIN_PERIOD)
                #endif
                //#NT#2016/03/07#KCHong -end
                FlowMovie_UpdateIcons(TRUE);
                Input_SetKeyMask(KEY_PRESS, MOVIE_KEY_PRESS_MASK);
            }
            break;

        //The flow here may be only for APC3 stop record than lock file function.
        //To be careful that gMovData have changed in UIFlowMovie_Stop.
        case MOV_ST_VIEW:
            #if (0)//(PRJ == APC3)
            if (paramNum)
            {
                if (paramArray[0]==UIFlowWndMovie_Restart_Rec)
                {
                    Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
                }
            }
            #endif
            // Enable key if user pressed shutter2 key to stop recording.
            Input_SetKeyMask(KEY_PRESS, MOVIE_KEY_PRESS_MASK);
            break;
    }

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnMovieOneSec(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    switch (gMovData.State)
    {
    case MOV_ST_REC:
    case MOV_ST_REC|MOV_ST_ZOOM:
        if (paramNum)
        {
            if (UxState_GetData(&UIFlowWndMovie_Status_RECCtrl, STATE_CURITEM) == UIFlowWndMovie_Status_REC_ICON_REC_TRANSPAENT)
            {
                UxState_SetData(&UIFlowWndMovie_Status_RECCtrl, STATE_CURITEM, UIFlowWndMovie_Status_REC_ICON_REC_ELLIPSE);
            }
            else
            {
                UxState_SetData(&UIFlowWndMovie_Status_RECCtrl, STATE_CURITEM, UIFlowWndMovie_Status_REC_ICON_REC_TRANSPAENT);
            }
            FlowMovie_IconHideMaxRecTime(&UIFlowWndMovie_Static_maxtimeCtrl);
            FlowMovie_SetRecCurrTime(paramArray[0]);
            FlowMovie_IconDrawRecTime(&UIFlowWndMovie_Static_timeCtrl);
        }
//        FlowMovie_IconDrawRecTime(&UIFlowWndMovie_Static_timeCtrl);
        if (UxCtrl_IsShow(&UIFlowWndMovie_StaticIcon_PIMCCtrl))
            FlowMovie_DrawPIM(FALSE);

        // For PM Demo, snap shot per one second.
        #if(_PM_DEMO_)
        if (UI_GetData(FL_MOVIE_SIZE) == MOVIE_SIZE_1080P60_D1P30)
            Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_REC_RAWENC, 0, 0, 0);
        #endif
        #if (_MODEL_DSC_ == _MODEL_FIREFLY_ || _MODEL_DSC_ == _MODEL_FIREFLY_665_)
        if (LED_IsLEDOn(GPIOMAP_LED_FCS) == TRUE)
            LED_TurnOffLED(GPIOMAP_LED_FCS);
        else
            LED_TurnOnLED(GPIOMAP_LED_FCS);
        #endif
        break;
    }
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnMovieFull(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return UIFlowWndMovie_OnLoopRecFull(pCtrl,paramNum,paramArray);
}
INT32 UIFlowWndMovie_OnMovieWrError(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    if ((gMovData.State == MOV_ST_REC)||(gMovData.State == (MOV_ST_REC|MOV_ST_ZOOM)))
    {
        FlowMovie_StopRec();
        if (UI_GetData(FL_CardStatus) == CARD_LOCKED)
        {
            gMovData.State=MOV_ST_WARNING_MENU;
            Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_CARD_LOCKED,FLOWWRNMSG_TIMER_3SEC);
            //#NT#2017/05/18#Adam Su -begin
            //#NT#fix mantis bug id:0119086
            FlowMovie_UpdateIcons(TRUE);
            //#NT#2017/05/18#Adam Su -end
            return NVTEVT_CONSUME;
        }
        else
        {
            gMovData.State=MOV_ST_WARNING_MENU;
            Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_MEMORYERROR,FLOWWRNMSG_TIMER_3SEC);
            //#NT#2017/05/18#Adam Su -begin
            //#NT#fix mantis bug id:0119086
            FlowMovie_UpdateIcons(TRUE);
            //#NT#2017/05/18#Adam Su -end
            return NVTEVT_CONSUME;
        }
    }
    else
    {
        Input_SetKeyMask(KEY_PRESS, MOVIE_KEY_PRESS_MASK);
    }
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnStorageSlow(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    // trigger re-start encoding
    #if 0
    return UIFlowWndMovie_OnExeRecord(pCtrl, 3, NVTEVT_KEY_PRESS, 0, UIFlowWndMovie_Restart_Rec);
    #else
    //#NT#2015/11/24#KS Hung -begin
    //#NT#SMediaRec and FileSys have new method for slow card
    //Movie_SetSDSlow(TRUE);
    MovRec_EnableOverlap(FALSE);
    //#NT#2015/11/24#KS Hung -end
    #if (_KEY_METHOD_ == _KEY_METHOD_4KEY_)
    Ux_PostEvent(NVTEVT_KEY_SHUTTER2 , 3, NVTEVT_KEY_PRESS, 0, UIFlowWndMovie_Restart_Rec);
    #else
    Ux_PostEvent(NVTEVT_KEY_SELECT, 3, NVTEVT_KEY_PRESS, 0, UIFlowWndMovie_Restart_Rec);
    #endif
    return NVTEVT_CONSUME;
    #endif
}
INT32 UIFlowWndMovie_OnLoopRecFull(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    FlowMovie_StopRec();
    KeyScan_EnableMisc(TRUE);
    //gMovData.State = MOV_ST_VIEW;
    gMovData.State= MOV_ST_WARNING_MENU;
    Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_CARD_FULL,FLOWWRNMSG_TIMER_2SEC);
    FlowMovie_IconDrawMaxRecTime(&UIFlowWndMovie_Static_maxtimeCtrl);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnEMRCompleted(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiPathId = 0;

    if (paramNum)
        uiPathId = paramArray[0];

    DBG_IND("EMR(%d) completed!\r\n", uiPathId);
    return NVTEVT_CONSUME;
}
#if 0
INT32 UIFlowWndMovie_OnPreviewStable(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    ide_enable_video(IDE_VIDEOID_1);
    switch (gMovData.State)
    {
    case MOV_ST_VIEW:
        FlowMovie_UpdateIcons(TRUE);
        break;
    }
    return NVTEVT_CONSUME;
}
#endif
INT32 UIFlowWndMovie_OnStorageInit(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    #if (CALIBRATION_FUNC == ENABLE)
    {
        // check if enter engineer mode
        if (EngineerMode_CheckEng())
        {
            //#NT#2016/06/23#Niven Cho -begin
            //#NT#Enter calibration by cgi event or command event
            Ux_PostEvent(NVTEVT_KEY_CALIBRATION, 0);
            //#NT#2016/06/23#Niven Cho -end
        }
    }
    #endif
    //#NT#2016/03/02#Niven Cho -begin
    //#NT#Fix FAST_BOOT + LINUX + without card, boot failed.
    #if (_CPU2_TYPE_ == _CPU2_LINUX_)
    if(UIStorageCheck(STORAGE_CHECK_ERROR, NULL) == TRUE)
    {
        Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD, FLOWWRNMSG_TIMER_KEEP);
    }
    #endif
    //#NT#2016/03/02#Niven Cho -end
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnOZoomStepChange(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnDZoomStepChange(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    FlowMovie_IconDrawDZoom(&UIFlowWndMovie_Zoom_StaticCtrl);
    return NVTEVT_CONSUME;
}
/* modify begin by ZMD, 2017-02-15 new version management*/
#if defined(YQCONFIG_COMB_DET_LCD_SWITCH_BY_GPIO) && defined(YQCONFIG_ANDROID_SYSTEM_SUPPORT)
extern BOOL GPIO_MapDetLcdSwitch(void);
#endif
/* modify end by ZMD, 2017-02-15 */
INT32 UIFlowWndMovie_OnPreviewStable(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32 uiEvent;
    /* modify begin by ZMD, 2017-02-15 new version management*/
    #if  defined(YQCONFIG_ANDROID_SYSTEM_SUPPORT)
    DX_OBJECT* devLCDObj1;/*ZMD*/
    UINT8   uiResqData[16]= {0};
    static BOOL firstPowerOn=TRUE;
    #endif
    /* modify end by ZMD, 2017-02-15 */
    if (paramNum>0)
    {
        uiEvent = paramArray[0];
        if (uiEvent != NVTEVT_ALGMSG_PREVIEW_STABLE)
            return NVTEVT_CONSUME;
    } else {
        return NVTEVT_CONSUME;
    }
    switch (gMovData.State)
    {
    case MOV_ST_VIEW:
        //#NT#2016/03/07#KCHong -begin
        //#NT#Low power timelapse function
        #if (TIMELAPSE_LPR_FUNCTION == ENABLE)
        if (UI_GetData(FL_MOVIE_TIMELAPSE_REC) < TL_LPR_TIME_MIN_PERIOD)
        #endif
        //#NT#2016/03/07#KCHong -end
            FlowMovie_UpdateIcons(TRUE);
        break;
    }
    g_PreviewStable = TRUE;
    /* modify begin by ZMD, 2017-02-15 new version management*/
    #if defined(YQCONFIG_ANDROID_SYSTEM_SUPPORT)
    if(firstPowerOn==TRUE)
    {
        firstPowerOn=FALSE;
        uiResqData[0]= 0x00;
        //gbWaitingMTKRunOK=TRUE;
        #if defined(YQCONFIG_COMB_DET_LCD_SWITCH_BY_GPIO)
        if(GPIO_MapDetLcdSwitch()==FALSE)
        {
            devLCDObj1=(DX_OBJECT *)Dx_GetObject(DX_CLASS_DISPLAY_EXT|DX_TYPE_LCD);
            devLCDObj1->pfClose();
        }
        /* add end by ZMD, 2016-08-20 */
        #endif
        #if defined(YQCONFIG_UART_TO_MTK_SUPPORT)
        if((GxSystem_GetPowerOnSource() == GX_PWRON_SRC_PWR_VBAT))
        {
            debug_msg("===>00-UIFlowWndMovie_OnOpen power by gsensor..\r\n");
        }
        else
        {
            debug_msg("===>00-UIFlowWndMovie_OnOpen require MTK menu setting..\r\n");
            MTKComposeCMDRspFrame(0, CMD_MENUSETTING_RESQ,(UINT8 *)&uiResqData, 1);
        }
        #endif
        /* modify end by ZMD, 2017-02-15 */

    }
    #endif
    /* modify end by ZMD, 2017-02-15 */
    return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnStorageChange(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    FlowMovie_UpdateIcons(TRUE);

    Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);
    Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyRelease);

    #if (SDHOTPLUG_FUNCTION == ENABLE)
    Ux_PostEvent(NVTEVT_SYSTEM_MODE, 1, System_GetState(SYS_STATE_CURRMODE));
    #endif

    return NVTEVT_CONSUME;
}
#if (GPS_FUNCTION == ENABLE)
inline static void  UIFlowWndMovie_UpdateSpeedData(void)
{
    RMCINFO RMCInfo;

    GPSRec_GetRMCDate(&RMCInfo);
    //#NT#2016/06/28#KCHong -begin
    //#NT#DbgLog in GPS section
    #if (LOG_DBGINFO_IN_GPS_SECTION == ENABLE)
    mp4log_AddLog (0, (char*)&RMCInfo, sizeof(RMCINFO));
    #else
    memcpy(&(gpsdata.rmcinfo),&RMCInfo,sizeof(RMCINFO));
    #endif
    //#NT#2016/06/28#KCHong -end
    #if 0
    debug_msg("lati:%1f, NS:%c, longi:%1f,EW:%c\r\n",gpsdata.rmcinfo.Latitude,gpsdata.rmcinfo.NSInd,gpsdata.rmcinfo.Longitude,gpsdata.rmcinfo.EWInd);
    #endif
}
#endif

static void UIFlowWndMovie_OnMotionDetect(void)
{
    static UINT32  uiMotionDetGo = 0;
    static UINT32  uiMotionDetStop = 0;

    //#NT#2016/11/01#Adam Su -begin
    //#NT#fix mantis issue 0106933
    static BOOL    bMotionDetRec = FALSE; // TRUE: trigger record by MD
    //#NT#2016/11/01#Adam Su -end

    //#NT#2016/10/18#Jeah Yen -begin
    //#NT#move code to support sensor map
    static UINT32  uiMotionDetRet = 0;
    Ux_SendEvent(0, NVTEVT_EXE_MOTION_DET_RUN, 1, (UINT32)&uiMotionDetRet);
    if (uiMotionDetRet==TRUE)
    //#NT#2016/10/18#Jeah Yen -end
    {
         uiMotionDetGo++;
         if (uiMotionDetGo>=2)
         {
            uiMotionDetStop=0;
            // Recording of modtion detection in pure CarDV path
            if (!((gMovData.State == MOV_ST_REC)||(gMovData.State == (MOV_ST_REC|MOV_ST_ZOOM))))
            {
                // reset uiMotionDetGo
                uiMotionDetGo = 0;
                //#NT#2016/11/01#Adam Su -begin
                //#NT#fix mantis issue 0106933
                bMotionDetRec = TRUE;
                //#NT#2016/11/01#Adam Su -end
                // press key to record video
                #if (_KEY_METHOD_ == _KEY_METHOD_4KEY_)
                Ux_PostEvent(NVTEVT_KEY_SHUTTER2 , 1, NVTEVT_KEY_PRESS);
                #else
                Ux_PostEvent(NVTEVT_KEY_SELECT, 1, NVTEVT_KEY_PRESS);
                #endif
            }
         }
    }
    else
    {
        //#NT#2016/11/01#Adam Su -begin
        //#NT#fix mantis issue 0106933
        if (bMotionDetRec == TRUE)
        {
            uiMotionDetStop++;
            if (uiMotionDetStop>=2) // 1 sec
            {
                uiMotionDetGo=0;
            }
            if (uiMotionDetStop>=20) // 10 Sec
            {
                uiMotionDetStop = 0;
                if (FlowMovie_GetRecCurrTime() >= 1)
                {
                    // CardDV path
                    if (gMovData.State==MOV_ST_REC||gMovData.State==(MOV_ST_REC|MOV_ST_ZOOM))
                    {
                        FlowMovie_StopRec();
                        bMotionDetRec = FALSE;
                    }
                }
            }
        }
        //#NT#2016/11/01#Adam Su -end
    }
}
#if defined(YQCONFIG_ANDROID_SYSTEM_SUPPORT)

extern BOOL WndMovieTouchPanelKeyUpdateIcons;

extern void UIFlowWndMovie_OnTouchPanelKeyUpdateIcons(BOOL UpdateShow);

#endif
INT32 UIFlowWndMovie_OnTimer(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    //#NT#2016/03/07#KCHong -begin
    //#NT#Low power timelapse function
    #if (TIMELAPSE_LPR_FUNCTION == ENABLE)
    UINT32 TLRet = 0;
    static UINT32 Cnt = 0;
    #endif
    //#NT#2016/03/07#KCHong -end

#if (GPS_FUNCTION == ENABLE)
    static UINT32 GPSHeartBeatPrev = 0, GPSHeartBeatNow = 0;
#endif
    static UINT32 counter=0;
    static UINT32 Temp_counter=0;
    static UINT32 Parkcounter=0;
    UINT32  uiEvent;
    uiEvent = paramNum ? paramArray[0] : 0;
    switch(uiEvent)
    {
    case NVTEVT_05SEC_TIMER:
        //#NT#2016/03/07#KCHong -begin
        //#NT#Low power timelapse function
        #if (TIMELAPSE_LPR_FUNCTION == ENABLE)
        TLRet = MovieTLLPR_Process(TIMELAPSE_FROM_TIMER);
        if ((TLRet & TL_FLOW_MASK) == TL_FLOW_LPR)
        {
            if((TLRet & TL_STATE_MASK) == TL_STATE_RECORD)
            {
                // flash REC icon one time to indicate capturing
                if (UxState_GetData(&UIFlowWndMovie_Status_RECCtrl, STATE_CURITEM) == UIFlowWndMovie_Status_REC_ICON_REC_TRANSPAENT)
                    Cnt ++;

                if (Cnt == 2)
                {
                    Cnt = 0;
                    UxState_SetData(&UIFlowWndMovie_Status_RECCtrl, STATE_CURITEM, UIFlowWndMovie_Status_REC_ICON_REC_ELLIPSE);
                }
                FlowMovie_IconHideMaxRecTime(&UIFlowWndMovie_Static_maxtimeCtrl);
                FlowMovie_IconDrawRecTime(&UIFlowWndMovie_Static_timeCtrl);
            }
            else
            {
                UxState_SetData(&UIFlowWndMovie_Status_RECCtrl, STATE_CURITEM, UIFlowWndMovie_Status_REC_ICON_REC_TRANSPAENT);
                FlowMovie_IconDrawMaxRecTime(&UIFlowWndMovie_Static_maxtimeCtrl);
            }
        }
        #endif
        //#NT#2016/03/07#KCHong -end

        #if(AUTO_WIFI==ENABLE)
        {
            static BOOL autoWifi = FALSE;

            if(!autoWifi)
            {
                //#NT#2016/03/23#Isiah Chang -begin
                //#NT#add new Wi-Fi UI flow.
                #if(WIFI_UI_FLOW_VER == WIFI_UI_VER_1_0)
                Ux_OpenWindow(&UIMenuWndWiFiWaitCtrl, 0);
                #endif
                //#NT#2016/03/23#Isiah Chang -end
                BKG_PostEvent(NVTEVT_BKW_WIFI_ON);
                autoWifi = TRUE;
            }
        }
        #endif

        //get GPS/GSensor Data
        //#NT#2013/3/20#Philex Lin-begin
        #if (GPS_FUNCTION == ENABLE)
		//#NT#2016/09/29#KCHong -begin
		//#NT#Log GPS data when toggle buffer instead of OnTimer event
		#if (LOG_DBGINFO_IN_GPS_SECTION == DISABLE)
        UIFlowWndMovie_UpdateSpeedData();
		#endif
		//#NT#2016/09/30#KCHong -end
        g_GPSStatus = GPSRec_GetSpeed(&g_CurSpeed);
        #endif
        //#NT#2013/3/20#Philex Lin-end

        #if defined(YQCONFIG_UART_TO_MTK_SUPPORT) && defined(YQCONFIG_ANDROID_SYSTEM_SUPPORT)
        g_GPSStatus=XmodemGetSpeed(&g_CurSpeed);

        debug_msg("onTimer g_CurSpeed=%d,%f  ", (UINT32)g_CurSpeed, g_CurSpeed);
        FlowMovie_IconDrawSpeed();
        FlowMovie_IconDrawDistance();
        #endif
        #if defined(YQCONFIG_ANDROID_SYSTEM_SUPPORT)
        
        if(WndMovieTouchPanelKeyUpdateIcons==TRUE)
        {
            WndMovieTouchPanelKeyUpdateIcons=FALSE;
            debug_msg("WndMovieTouchPanelKeyUpdateIcons1-----\r\n");
            UIFlowWndMovie_OnTouchPanelKeyUpdateIcons(TRUE);
        }

        #endif
        // Do Motion detect process
        if(g_uiRecordIngMotionDet == TRUE)
           UIFlowWndMovie_OnMotionDetect();
        break;

    case NVTEVT_1SEC_TIMER:
        #if defined(YQCONFIG_UART_TO_MTK_SUPPORT) && defined(YQCONFIG_ANDROID_SYSTEM_SUPPORT)
        if(g_PreviewStable == TRUE)
        {
            FlowMovie_OnCheckMtkMenuItem();
        }
        #endif
        //#NT#2015/10/02#KCHong -begin
        //#NT#For GPS & ADAS
        #if (GPS_FUNCTION == ENABLE)
        GPSHeartBeatNow = GetGPSHeartBeat();
        g_GPSLinked = (GPSHeartBeatNow != GPSHeartBeatPrev)?TRUE:FALSE;
        GPSHeartBeatPrev = GPSHeartBeatNow;
        #endif
        //#NT#2015/10/02#KCHong -end

        //#NT#2015/07/17#KS Hung -begin
        //#NT#For ADAS
        #if _ADAS_FUNC_
        if (UxCtrl_IsShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl))
        {
            g_uiAdasAlertSecCnt++;
            if (g_uiAdasAlertSecCnt == 2)
            {
                UxCtrl_SetShow(&UIFlowWndMovie_Panel_Normal_DisplayCtrl, TRUE);
                UxCtrl_SetShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl, FALSE);
                g_uiAdasAlertSecCnt = 0;
            }
            else
            {
                return NVTEVT_CONSUME;
            }
        }
        #endif
        //#NT#2015/07/17#KS Hung -end

        if(g_bDelayUpdateIcon)
        {
            FlowMovie_UpdateIcons(TRUE);
            g_bDelayUpdateIcon = FALSE;
        }

        FlowMovie_OnTimer1SecIndex();
        // Isiah, implement YUV merge mode of recording func.
        if(MovRec_IsRecording())
        {
            Ux_SendEvent(&CustomMovieObjCtrl,NVTEVT_EXE_MOVIE_REC_STEP,NULL);
        }
#if 1//(MOVIE_AUTOREC_ACPLUG == ENABLE)
        if(System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_SAFE)
        {
        //if(!MovRec_IsRecording())
        {
            if (g_PreviewStable_Record == FALSE)
            {
                //if ((g_ACPlug==TRUE)&&(g_PreviewStable == TRUE))
                //if (g_PreviewStable == TRUE)
                {
                   g_PreviewStable_Record = TRUE;
                   Ux_PostEvent(NVTEVT_KEY_SHUTTER2 , 1, NVTEVT_KEY_PRESS);
//                   #if (_KEY_METHOD_ == _KEY_METHOD_4KEY_)
                    }
                }
            }
        }
//                   Ux_PostEvent(NVTEVT_KEY_SHUTTER2 , 1, NVTEVT_KEY_PRESS);
        /* modify begin by ZMD, 2017-02-15 new version management*/
        #if defined(YQCONFIG_ANDROID_SYSTEM_SUPPORT)
        if(System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_SAFE)
        {
            if(!MovRec_IsRecording())
            {
                if (g_PreviewStable_Record == FALSE)
                {

                    if((g_PreviewStable == TRUE)&&(gbNTRequireAndroid==TRUE))
                        //if (g_PreviewStable == TRUE)
                    {
                        g_PreviewStable_Record = TRUE;
                        /* modify begin by ZMD, 2017-02-15 new version management*/
                        #if defined(YQCONFIG_UART_TO_MCU_SUPPORT)
                        // movie open updata mcu fw
                        if(MCU_Upgrade_Doing == FALSE)
                        {
                            if(UserUpgradeMCUFW() == TRUE)
                            {
                                MCU_Upgrade_Doing = TRUE;
                                UserUpgradeMCUFWDoing();
                                MCU_Reset();
                            }
                            else
                            {
                                debug_msg("Auto record start...22..\r\n");
                                if(0)//(ParkingCaptrueFlag==TRUE)
                                {
                                    Ux_PostEvent(NVTEVT_MTK_CAPTURE, 1,0);
                                }
                                else
                                {
                                    Ux_PostEvent(NVTEVT_KEY_SHUTTER2 , 1, NVTEVT_KEY_PRESS);
                                }
                            }
                        }
                        #else
                        debug_msg("Auto record start...11..\r\n");
                        Ux_PostEvent(NVTEVT_KEY_SHUTTER2 , 1, NVTEVT_KEY_PRESS);
                        #endif
                        /* modify end by ZMD, 2017-02-15 */
                    }
                }
            }
        }


        if(gbMovieRecordingFlag==TRUE)
        {
            counter++;
            if(counter==2)
            {
                counter=0;
                gbMovieRecordingFlag=FALSE;
                debug_msg("Auto record start...00..\r\n");
                g_PreviewStable_Record=FALSE;
            }
        }
        if(gbMovieTouchUIDisplayEn==TRUE)
        {
            guiMovieTouchUIDisplayCounter++;
            if(guiMovieTouchUIDisplayCounter==10)
            {
                gbMovieTouchUIDisplayEn=FALSE;
                guiMovieTouchUIDisplayCounter=0;
                FlowMovie_UpdateIcons(FALSE);
            }
        }
        


        #endif
        #endif
        break;
    }
    Ux_DefaultEvent(pCtrl,NVTEVT_TIMER,paramNum,paramArray);
    return NVTEVT_CONSUME;
}
#if defined(YQCONFIG_UART_TO_MTK_SUPPORT) && defined(YQCONFIG_ANDROID_SYSTEM_SUPPORT)
/* add begin by ZMD, 2016-10-14, ╘н╥Є: ╙я╥Ї╟╨╗╗╧╘╩╛╟░║є┬╖*/
INT32 UIFlowWndMovie_MTK_Change_DiaplayMode(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  ModeType=0;
    UINT8  Temp_value=0;
    UINT8 data=0;
    if(paramNum>0)
    {
        ModeType = paramArray[0];
    }

    if(1==DrvSensor_DetPlugIn(SENSOR_ID_2))//  if(ImageUnit_GetParam(&ISF_ImagePipe, IMAGEPIPE_PARAM_SENSORCOUNT)>=2)
    {
        if( ModeType == 0)
        {
            if(SysGetFlag(FL_DUAL_CAM)==DUALCAM_LR_16_9)
            {
                Temp_value=1;
            }
            else
            {
                Temp_value=0;
                SysSetFlag(FL_DUAL_CAM,DUALCAM_LR_16_9);
            }
            data=0;
        }
        else if( ModeType == 1)
        {
            if(SysGetFlag(FL_DUAL_CAM)==DUALCAM_LR_FRONT_FULL)
            {
                Temp_value=1;
            }
            else
            {
                Temp_value=0;
                SysSetFlag(FL_DUAL_CAM,DUALCAM_LR_FRONT_FULL);
            }
            data=1;
        }
        else if( ModeType == 2)
        {
            if(SysGetFlag(FL_DUAL_CAM)==DUALCAM_LR_BEHIND_FULL)
            {
                Temp_value=1;
            }
            else
            {
                Temp_value=0;
                SysSetFlag(FL_DUAL_CAM,DUALCAM_LR_BEHIND_FULL);
            }
            data=2;
        }
        else
        {
            if(SysGetFlag(FL_DUAL_CAM)==DUALCAM_LR_16_9)
            {
                Temp_value=1;
            }
            else
            {
                Temp_value=0;
                SysSetFlag(FL_DUAL_CAM,DUALCAM_LR_16_9);
            }
            data=0;
        }

        if(Temp_value==0)
        {
            Ux_SendEvent(0,  NVTEVT_EXE_DUALCAM,        1,  SysGetFlag(FL_DUAL_CAM));
        }
        DBG_DUMP("^GUART_DrawTest:%d\r\n", SysGetFlag(FL_DUAL_CAM));
    }
    else
    {
        data=0xFF;
        // MTKComposeCMDRspFrame(0, CMD_CHANGE_DIAPLAYMODE,&data, 1);
    }
    debug_msg("^G" "========>> UIFlowWndMovie_MTK_Change_DiaplayMode!========>> \r\n");
    return NVTEVT_CONSUME;
}
//=======================MTK DiaplayMode End=============================
#endif
INT32 UIFlowWndMovie_OnACPlug(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if (MOVIE_AUTOREC_ACPLUG == ENABLE)
    g_ACPlug = TRUE;
    // start record if receiving preview stable event
    if ((g_PreviewStable == TRUE)&&(g_PreviewStable_Record == FALSE))
    {
        g_PreviewStable_Record = TRUE;
        if(UI_GetData(FL_WIFI_AUTO_RECORDING) == WIFI_AUTO_RECORDING_ON)
        {
            //Ux_PostEvent(NVTEVT_KEY_SELECT, 1, NVTEVT_KEY_PRESS);
        }
    }
#endif
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnACUnplug(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    g_ACPlug = FALSE;
    //Ux_PostEvent(NVTEVT_KEY_SELECT, 1, NVTEVT_KEY_PRESS);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnCustom1(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiWidth  = GetMovieSizeWidth(UI_GetData(FL_MOVIE_SIZE));

    if(SysGetFlag(FL_GSENSOR) !=GSENSOR_OFF)
    {
        if ( (gMovData.State == MOV_ST_REC) || (gMovData.State == MOV_ST_REC_WAIT) )
        {
            if (SysGetFlag(FL_MOVIE_URGENT_PROTECT_AUTO)==MOVIE_URGENT_PROTECT_AUTO_ON)
            {

#if (MOVIE_MULTI_RECORD_FUNC)
                if(GetMovieRecType_2p(UI_GetData(FL_MOVIE_SIZE))==MOVIE_REC_TYPE_DUAL
                    || GetMovieRecType_2p(UI_GetData(FL_MOVIE_SIZE))==MOVIE_REC_TYPE_CLONE)
                {
                   DBG_DUMP("dual record, only support set crash\r\n");
				   MovRec_SetCrash();
                   return NVTEVT_CONSUME;
                }
#endif
                if ((uiWidth <= 1920) && (UI_GetData(FL_MOVIE_CYCLIC_REC) != MOVIE_CYCLICREC_OFF))
                {
                    DBG_DUMP("process flash video record!!!\r\n");
                    MovRec_StopFlash(0);
                }
                else
                {
                    DBG_DUMP("Set Crash!!!\r\n");
                    MovRec_SetCrash();
                }
            }
        }
    }
    return NVTEVT_CONSUME;
}

//#NT#2016/03/25#KCHong -begin
//#NT#New ADAS
INT32 UIFlowWndMovie_OnADASShowAlarm(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if (_ADAS_FUNC_ == ENABLE)
    UINT32 AlarmType;
    ADAS_DSP_RESULT_INFO *pAdasDspRlt = MovieExe_GetAdasDspRltOSD();
    {
        debug_msg("");
    }
    Ux_FlushEventByRange(NVTEVT_CB_ADAS_SHOWALARM, NVTEVT_CB_ADAS_SHOWALARM);
    AlarmType = paramArray[0];
    #if defined(YQCONFIG_UART_TO_MTK_SUPPORT) && defined(YQCONFIG_ANDROID_SYSTEM_SUPPORT)
    UINT8   uiResqData[16]= {0};
    UINT32 DepartureDirVoice_Temp=0;
    debug_msg("^GZMD---UIFlowWndMovie_OnADASShowAlarm--%d--\r\n",AlarmType);
    switch (AlarmType)
    {
    case ADAS_ALARM_LD:
        g_uiAdasAlertSecCnt = 0;
		/*
        if(paramNum>1)
        {
            DepartureDirVoice_Temp = paramArray[1];
        }
		*/
        #if defined(YQCONFIG_ANDROID_SYSTEM_SUPPORT)
		/*
        if (!UxCtrl_IsShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl))
        {
		*/
		#if 0
            UxCtrl_SetShow(&UIFlowWndMovie_Panel_Normal_DisplayCtrl, FALSE);
            UxCtrl_SetShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl,TRUE);
            UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_LDWS_AlertCtrl,TRUE);
            UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_FCWS_AlertCtrl,FALSE);
            UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_SNG_AlertCtrl,FALSE);
        #else
            UISound_Play(DEMOSOUND_SOUND_LDWS_TONE);
            debug_msg("^UIFlowWndMovie_OnADASShowAlarm--UISound_Play--\r\n");
            if (!UxCtrl_IsShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl))
            {
                debug_msg("^UIFlowWndMovie_OnADASShowAlarm--UxCtrl_IsShow--\r\n");
                UxCtrl_SetShow(&UIFlowWndMovie_Panel_Normal_DisplayCtrl, FALSE);
                UxCtrl_SetShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl,TRUE);
                UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_LDWS_AlertCtrl,TRUE);
                UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_FCWS_AlertCtrl,FALSE);
                UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_SNG_AlertCtrl,FALSE);
                debug_msg("\r\npAdasDspRlt->LdwsDspRsltInfo.DepartureDirVoice--%d--\r\n",pAdasDspRlt->LdwsDspRsltInfo.DepartureDirVoice);
                UxState_SetData(&UIFlowWndMovie_StatusICN_LDWS_AlertCtrl, STATE_CURITEM, UIFlowWndMovie_StatusICN_LDWS_Alert_ICON_LDWS_LEFT_ALERT);
//                switch (pAdasDspRlt->LdwsDspRsltInfo.DepartureDirVoice)
//                {
//                    case LDWS_DEPARTURE_LEFT:
//                        UxState_SetData(&UIFlowWndMovie_StatusICN_LDWS_AlertCtrl, STATE_CURITEM, UIFlowWndMovie_StatusICN_LDWS_Alert_ICON_LDWS_LEFT_ALERT);
//                        break;
//                    case LDWS_DEPARTURE_RIGHT:
//                        UxState_SetData(&UIFlowWndMovie_StatusICN_LDWS_AlertCtrl, STATE_CURITEM, UIFlowWndMovie_StatusICN_LDWS_Alert_ICON_LDWS_RIGHT_ALERT);
//                        break;
//                    default:
//                        break;
//                }
            }
            #endif
//            switch (DepartureDirVoice_Temp)
//            {
//            case LDWS_DEPARTURE_LEFT:

				uiResqData[0]=(LDWS_RIGHT_ |LDWS_LEFT_|WORKING_MODE);
                uiResqData[1] = 0;
                // debug_msg("^GZMD---CMD_ADAS_RESQ1---\r\n");
                MTKComposeCMDRspFrame(0, CMD_ADAS_RESQ,(UINT8 *)&uiResqData, 2); //0x71==CMD_ADAS_RESQ

//                UxState_SetData(&UIFlowWndMovie_StatusICN_LDWS_AlertCtrl, STATE_CURITEM, UIFlowWndMovie_StatusICN_LDWS_Alert_ICON_LDWS_LEFT_ALERT);
//                break;
//            case LDWS_DEPARTURE_RIGHT:

//                uiResqData[0]=(LDWS_RIGHT_ |LDWS_LEFT_|WORKING_MODE);
//				uiResqData[1] = 0;
				//debug_msg("^GZMD---CMD_ADAS_RESQ1---\r\n");
//				MTKComposeCMDRspFrame(0, CMD_ADAS_RESQ,(UINT8 *)&uiResqData, 2); //0x71==CMD_ADAS_RESQ

//                UxState_SetData(&UIFlowWndMovie_StatusICN_LDWS_AlertCtrl, STATE_CURITEM, UIFlowWndMovie_StatusICN_LDWS_Alert_ICON_LDWS_RIGHT_ALERT);
//                break;
//            default:
//                break;
//            }
//        }
		#else
        UISound_Play(DEMOSOUND_SOUND_LDWS_TONE);
        #endif
        break;

    case ADAS_ALARM_FC:
        g_uiAdasAlertSecCnt = 0;
//        if(paramNum>1)
//        {
//            DepartureDirVoice_Temp = paramArray[1];
//        }
        #if defined(YQCONFIG_ANDROID_SYSTEM_SUPPORT)
//        #else
//        UISound_Play(DEMOSOUND_SOUND_FCS_TONE);
//        #endif
//        if (!UxCtrl_IsShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl))
        //{
            /*
                UxCtrl_SetShow(&UIFlowWndMovie_Panel_Normal_DisplayCtrl, FALSE);
                UxCtrl_SetShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl,TRUE);
                UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_LDWS_AlertCtrl,FALSE);
                UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_FCWS_AlertCtrl,TRUE);
                UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_SNG_AlertCtrl,FALSE);
                */
            //#if defined(YQCONFIG_ANDROID_SYSTEM_SUPPORT)
            // if ((g_AdasResult.FcwsRsltInfo.uiDist < 30) && (g_AdasResult.FcwsRsltInfo.uiDist > 0))
//            if ((DepartureDirVoice_Temp < 30) && (DepartureDirVoice_Temp > 0))
//            #else
//            if ((g_AdasResult.FcwsRsltInfo.uiDist < 15) && (g_AdasResult.FcwsRsltInfo.uiDist > 0))
//            #endif
            //{
                UxCtrl_SetShow(&UIFlowWndMovie_Panel_Normal_DisplayCtrl, FALSE);
                UxCtrl_SetShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl,TRUE);
                UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_LDWS_AlertCtrl,FALSE);
                UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_FCWS_AlertCtrl,TRUE);
                UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_SNG_AlertCtrl,FALSE);

                uiResqData[0]=(FCW_WARNING|WORKING_MODE);
                uiResqData[1]= 0;
                //debug_msg("^GZMD---CMD_ADAS_RESQ3---\r\n");
                MTKComposeCMDRspFrame(0, CMD_ADAS_RESQ,(UINT8 *)&uiResqData, 2);

//                if ((pAdasRlt->FcwsRsltInfo.uiDist < 15) && (pAdasRlt->FcwsRsltInfo.uiDist > 0))
//                {
//                    UxState_SetData(&UIFlowWndMovie_StatusICN_FCWS_AlertCtrl, STATE_CURITEM, UIFlowWndMovie_StatusICN_FCWS_Alert_ICON_FCW_FAR_ALERT);
//                }
            //}
        //}
		#else
        UISound_Play(DEMOSOUND_SOUND_FCS_TONE);
        #endif
        break;
	}
    #else
    switch (AlarmType)
    {
        case ADAS_ALARM_LD:
            g_uiAdasAlertSecCnt = 0;
            UISound_Play(DEMOSOUND_SOUND_LDWS_TONE);
            if (!UxCtrl_IsShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl))
            {
                UxCtrl_SetShow(&UIFlowWndMovie_Panel_Normal_DisplayCtrl, FALSE);
                UxCtrl_SetShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl,TRUE);
                UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_LDWS_AlertCtrl,TRUE);
                UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_FCWS_AlertCtrl,FALSE);
                UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_SNG_AlertCtrl,FALSE);
                switch (pAdasDspRlt->LdwsRsltInfo.DepartureDirVoice)
                {
                    case LDWS_DEPARTURE_LEFT:
                        UxState_SetData(&UIFlowWndMovie_StatusICN_LDWS_AlertCtrl, STATE_CURITEM, UIFlowWndMovie_StatusICN_LDWS_Alert_ICON_LDWS_LEFT_ALERT);
                        break;
                    case LDWS_DEPARTURE_RIGHT:
                        UxState_SetData(&UIFlowWndMovie_StatusICN_LDWS_AlertCtrl, STATE_CURITEM, UIFlowWndMovie_StatusICN_LDWS_Alert_ICON_LDWS_RIGHT_ALERT);
                        break;
                    default:
                        break;
                }
            }
            break;

        case ADAS_ALARM_FC:
            g_uiAdasAlertSecCnt = 0;
            UISound_Play(DEMOSOUND_SOUND_FCS_TONE);
            if (!UxCtrl_IsShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl))
            {
                UxCtrl_SetShow(&UIFlowWndMovie_Panel_Normal_DisplayCtrl, FALSE);
                UxCtrl_SetShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl,TRUE);
                UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_LDWS_AlertCtrl,FALSE);
                UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_FCWS_AlertCtrl,TRUE);
                UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_SNG_AlertCtrl,FALSE);

                if ((pAdasRlt->FcwsDspRsltInfo.uiDist < 15) && (pAdasRlt->FcwsDspRsltInfo.uiDist > 0))
                {
                    UxState_SetData(&UIFlowWndMovie_StatusICN_FCWS_AlertCtrl, STATE_CURITEM, UIFlowWndMovie_StatusICN_FCWS_Alert_ICON_FCW_FAR_ALERT);
                }
            }
            break;

        case ADAS_ALARM_GO:
            g_uiAdasAlertSecCnt = 0;
            UISound_Play(DEMOSOUND_SOUND_SNG_TONE);
            if (!UxCtrl_IsShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl))
            {
                UxCtrl_SetShow(&UIFlowWndMovie_Panel_Normal_DisplayCtrl, FALSE);
                UxCtrl_SetShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl,TRUE);
                UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_LDWS_AlertCtrl,FALSE);
                UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_FCWS_AlertCtrl,FALSE);
                UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_SNG_AlertCtrl,TRUE);
                UxState_SetData(&UIFlowWndMovie_StatusICN_SNG_AlertCtrl, STATE_CURITEM, UIFlowWndMovie_StatusICN_SNG_Alert_ICON_SNG_ALERT);
            }
            break;

        case ADAS_ALARM_STOP:
            g_uiAdasAlertSecCnt = 0;
            UISound_Play(DEMOSOUND_SOUND_SNG_TONE);
            if (!UxCtrl_IsShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl))
            {
                UxCtrl_SetShow(&UIFlowWndMovie_Panel_Normal_DisplayCtrl, FALSE);
                UxCtrl_SetShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl,TRUE);
                UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_LDWS_AlertCtrl,FALSE);
                UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_FCWS_AlertCtrl,FALSE);
                UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_SNG_AlertCtrl,TRUE);
                UxState_SetData(&UIFlowWndMovie_StatusICN_SNG_AlertCtrl, STATE_CURITEM, UIFlowWndMovie_StatusICN_SNG_Alert_ICON_SNG_ALERT);
            }
            break;

        default:
            break;
    }
#endif
#endif
    return NVTEVT_CONSUME;
}
/* modify begin by ZMD, 2017-02-15 new version management*/
#if defined(YQCONFIG_UART_TO_MTK_SUPPORT) && defined(YQCONFIG_ANDROID_SYSTEM_SUPPORT)
#if !defined(YQCONFIG_TOUCH_TO_MTK_PLAYSOUND_OPTION)
INT32 UIFlowWndMovie_OnTouchPanelKey(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32 uiPositon=0,P1=0,P2=0;
    UINT8 FrameID=0;
    UINT32 TouchKeyStatus=0xFFFF;

    UINT8   uiResqData[16]= {0};
    UINT32 uiJpegWidth=0, uiJpegHeight=0, uiDAR=0, uiMovieSize=0;

    if(paramNum>0)
        TouchKeyStatus= paramArray[0];
    if(paramNum>1)
    {
        uiPositon= paramArray[1];
        P1=(uiPositon&0xFFFF0000)>>16;
        P2=(uiPositon&0x0000FFFF);
    }
    if(paramNum>2)
        FrameID=paramArray[2];

    if(gbMovieTouchUIDisplayEn==FALSE)
    {
        switch(TouchKeyStatus)
        {
        case TOUCH_KEY_STATUS_PRESSED:
            uiResqData[0]=0x02;
            MTKComposeCMDRspFrame(FrameID, CMD_TOUCH,(UINT8 *)&uiResqData, 1);
            FlowMovie_UpdateIcons(TRUE);
            break;
        case TOUCH_KEY_STATUS_RELEASED:
            uiResqData[0]=0x02;
            MTKComposeCMDRspFrame(FrameID, CMD_TOUCH,(UINT8 *)&uiResqData, 1);
            gbMovieTouchUIDisplayEn=TRUE;

            break;
        }
        return NVTEVT_CONSUME;
    }
    guiMovieTouchUIDisplayCounter=0;


    {
 	Ux_RECT Rect;
	UxCtrl_GetPos(&UIFlowWndMovie_Status_Touch_RERTURNCtrl,&Rect);
	debug_msg("Rang:x1:%d,x2:%d,y1:%d,y2:%d,p1:%d,p2:%d...\r\n",Rect.x1,Rect.x2,Rect.y1,Rect.y2);
    debug_msg("TouchKeyStatus = %d\r\n",TouchKeyStatus);
//    P1 = (Rect.x1+Rect.x2)/2;
//    P2 = (Rect.y1+Rect.y2)/2;
//    uiMovieKeyPressed=UIFLOW_MOVIE_TOUCH_KEY_RETURN;
    }
    switch(TouchKeyStatus)
    {
    case TOUCH_KEY_STATUS_PRESSED:
//        if(TPIsOnRange(&UIFlowWndMovie_Status_Main_PBCtrl,P1,P2)==TRUE)
//        {
//            debug_msg("Main_PBCtrl...PRESSED...%d\r\n",gMovData.State);
//            if (UI_GetData(FL_CardStatus) == CARD_REMOVED)
//            {
//                Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD,FLOWWRNMSG_TIMER_2SEC);
//                uiResqData[0]=0x03;
//                MTKComposeCMDRspFrame(FrameID, CMD_TOUCH,(UINT8 *)&uiResqData, 1);
//                return NVTEVT_CONSUME;
//            }
//            switch(gMovData.State)
//            {
//            case MOV_ST_REC:
//            case MOV_ST_REC|MOV_ST_ZOOM:
//                if (FlowMovie_GetRecCurrTime() >= 3)
//                {
//                    uiMovieKeyPressed=UIFLOW_MOVIE_TOUCH_KEY_PLAYBACK;
//                    UxCtrl_SetShow(&UIFlowWndMovie_Status_Main_PBCtrl, FALSE);
//                    UxState_SetData(&UIFlowWndMovie_Status_Main_PBCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Main_PB_ICON_PLAY_MODE_PRESSED);
//                    UxCtrl_SetShow(&UIFlowWndMovie_Status_Main_PBCtrl, TRUE);
//                }
//                else
//                {
//                    debug_msg("Movie mode flush Event..\r\n");
//                    Ux_FlushEvent();
//                    UxCtrl_SetShow(&UIFlowWndMovie_Status_Main_PBCtrl, FALSE);
//                    UxState_SetData(&UIFlowWndMovie_Status_Main_PBCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Main_PB_ICON_PLAY_MODE_PRESSED);
//                    UxCtrl_SetShow(&UIFlowWndMovie_Status_Main_PBCtrl, TRUE);
//                }
//                uiResqData[0]=0x02;
//                MTKComposeCMDRspFrame(FrameID, CMD_TOUCH,(UINT8 *)&uiResqData, 1);
//                break;
            case MOV_ST_VIEW:
            case MOV_ST_VIEW|MOV_ST_ZOOM:
                uiMovieKeyPressed=UIFLOW_MOVIE_TOUCH_KEY_PLAYBACK;
                //UxCtrl_SetShow(&UIFlowWndMovie_Status_Main_PBCtrl, FALSE);
                //UxState_SetData(&UIFlowWndMovie_Status_Main_PBCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Main_PB_ICON_PLAY_MODE_PRESSED);
                //UxCtrl_SetShow(&UIFlowWndMovie_Status_Main_PBCtrl, TRUE);
                uiResqData[0]=0x02;
                MTKComposeCMDRspFrame(FrameID, CMD_TOUCH,(UINT8 *)&uiResqData, 1);
                break;
            }
        }
        else if(TPIsOnRange(&UIFlowWndMovie_Status_Touch_RECCtrl,P1,P2)==TRUE)
        {
            debug_msg("Touch_RECCtrl...PRESSED...\r\n");
            uiMovieKeyPressed=UIFLOW_MOVIE_TOUCH_KEY_RECORD;
            UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_RECCtrl, FALSE);
            if(!MovRec_IsRecording())
            {
                UxState_SetData(&UIFlowWndMovie_Status_Touch_RECCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_REC_ICON_TP_REC_PRESSED);
            }
            else
            {
                UxState_SetData(&UIFlowWndMovie_Status_Touch_RECCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_REC_ICON_TP_REC);
            }
            UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_RECCtrl, TRUE);
            uiResqData[0]=0x02;
            MTKComposeCMDRspFrame(FrameID, CMD_TOUCH,(UINT8 *)&uiResqData, 1);
        }
        else if(TPIsOnRange(&UIFlowWndMovie_Status_Touch_RERTURNCtrl,P1,P2)==TRUE)
        {
            debug_msg("Touch_RERTURNCtrl...PRESSED...\r\n");
            uiMovieKeyPressed=UIFLOW_MOVIE_TOUCH_KEY_RETURN;
            UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_RERTURNCtrl, FALSE);
            UxState_SetData(&UIFlowWndMovie_Status_Touch_RERTURNCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_RERTURN_ICON_TP_RETURN_PRESSED);
            UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_RERTURNCtrl, TRUE);
            uiResqData[0]=0x00;
            MTKComposeCMDRspFrame(FrameID, CMD_TOUCH,(UINT8 *)&uiResqData, 1);
        }
        else if(TPIsOnRange(&UIFlowWndMovie_Status_Touch_SnapeShotCtrl,P1,P2)==TRUE)
        {
            debug_msg("Touch_SnapeShotCtrl...PRESSED...\r\n");
            #if(1)//(PHOTO_FUNCTION==ENABLE)
            if (UI_GetData(FL_CardStatus) == CARD_REMOVED)
            {
                Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD,FLOWWRNMSG_TIMER_2SEC);
                uiResqData[0]=0x03;
                MTKComposeCMDRspFrame(FrameID, CMD_TOUCH,(UINT8 *)&uiResqData, 1);
                return NVTEVT_CONSUME;
            }

            switch(gMovData.State)
            {
            case MOV_ST_VIEW:
            case MOV_ST_VIEW|MOV_ST_ZOOM:
            case MOV_ST_REC:
            case MOV_ST_REC|MOV_ST_ZOOM:
                uiMovieKeyPressed=UIFLOW_MOVIE_TOUCH_KEY_SNAPESHOT;
                UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_SnapeShotCtrl, FALSE);
                UxState_SetData(&UIFlowWndMovie_Status_Touch_SnapeShotCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_SnapeShot_ICON_SHOT_PRESS);
                UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_SnapeShotCtrl, TRUE);
                uiResqData[0]=0x02;
                MTKComposeCMDRspFrame(FrameID, CMD_TOUCH,(UINT8 *)&uiResqData, 1);
                break;
            }
            #endif
        }
        else if(TPIsOnRange(&UIFlowWndMovie_Status_Touch_Change_DisplayModeCtrl,P1,P2)==TRUE)
        {
            debug_msg("Touch_Change_DisplayModeCtrl...PRESSED...\r\n");
            uiMovieKeyPressed=UIFLOW_MOVIE_TOUCH_KEY_PIPDISPLAY;
            UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_Change_DisplayModeCtrl, FALSE);
            /* add begin by ZMD, 2016-09-02, ╘н╥Є: ╬▐║є┬╖├╗╙╨╟╨╗╗╣ж─▄*/
            if(1==DrvSensor_DetPlugIn(SENSOR_ID_2))// if(ImageUnit_GetParam(&ISF_ImagePipe, IMAGEPIPE_PARAM_SENSORCOUNT)>=2)
            {
                UxState_SetData(&UIFlowWndMovie_Status_Touch_Change_DisplayModeCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_Change_DisplayMode_ICON_DISPLAY_CHANGE_PRESS);
                UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_Change_DisplayModeCtrl, TRUE);
            }
            else
            {
                UxState_SetData(&UIFlowWndMovie_Status_Touch_Change_DisplayModeCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_Change_DisplayMode_ICON_DISPLAY_CHANGE_PRESS);
                UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_Change_DisplayModeCtrl, FALSE);
            }
            uiResqData[0]=0x02;
            MTKComposeCMDRspFrame(FrameID, CMD_TOUCH,(UINT8 *)&uiResqData, 1);
        }

        

        #if defined(YQCONFIG_TOUCH_AUDIOSWITCH_OPTION)
        else if(TPIsOnRange(&UIFlowWndMovie_Status_Touch_AudioSwitchCtrl,P1,P2)==TRUE)
        {
            debug_msg("Touch_Change_DisplayModeCtrl...PRESSED...\r\n");
            uiMovieKeyPressed=UIFLOW_MOVIE_TOUCH_KEY_AUDIOSWITCH;
            if(UI_GetData(FL_MOVIE_AUDIO)==MOVIE_AUDIO_ON)
            {
                UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_AudioSwitchCtrl, FALSE);
                UxState_SetData(&UIFlowWndMovie_Status_Touch_AudioSwitchCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_AudioSwitch_ICON_SOUND_RELEASE);
                UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_AudioSwitchCtrl, TRUE);
            }
            else
            {
                UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_AudioSwitchCtrl, FALSE);
                UxState_SetData(&UIFlowWndMovie_Status_Touch_AudioSwitchCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_AudioSwitch_ICON_SOUND_PRESS);
                UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_AudioSwitchCtrl, TRUE);
            }

            uiResqData[0]=0x02;
            MTKComposeCMDRspFrame(FrameID, CMD_TOUCH,(UINT8 *)&uiResqData, 1);
        }
        #endif
        else
        {
            debug_msg("Touch_NULL...PRESSED...\r\n");
            Ux_FlushEvent();
            uiMovieKeyPressed=UIFLOW_MOVIE_TOUCH_KEY_NONE;
        }
        break;
    case TOUCH_KEY_STATUS_RELEASED:
        Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);
//        if(TPIsOnRange(&UIFlowWndMovie_Status_Main_PBCtrl,P1,P2)==TRUE)
//       {
//            debug_msg("Main_PBCtrl...RELEASED...%d\r\n",uiMovieKeyPressed);
//            if(uiMovieKeyPressed==UIFLOW_MOVIE_TOUCH_KEY_PLAYBACK)
//            {
//                UxCtrl_SetShow(&UIFlowWndMovie_Status_Main_PBCtrl, FALSE);
//                UxState_SetData(&UIFlowWndMovie_Status_Main_PBCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Main_PB_ICON_PLAY_MODE);
//                UxCtrl_SetShow(&UIFlowWndMovie_Status_Main_PBCtrl, TRUE);
//                Ux_PostEvent(NVTEVT_KEY_MODE, 1, NVTEVT_KEY_PRESS);
//                uiResqData[0]=0x02;
//                uiResqData[1]=0x01;
//                MTKComposeCMDRspFrame(FrameID, CMD_TOUCH,(UINT8 *)&uiResqData, 2);
//            }
//        }
//        else 
            if(TPIsOnRange(&UIFlowWndMovie_Status_Touch_RECCtrl,P1,P2)==TRUE)
        {
            debug_msg("Touch_RECCtrl...RELEASED...\r\n");
            UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_RECCtrl, FALSE);
            if(!MovRec_IsRecording())
            {
                UxState_SetData(&UIFlowWndMovie_Status_Touch_RECCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_REC_ICON_TP_REC_PRESSED);
            }
            else
            {
                UxState_SetData(&UIFlowWndMovie_Status_Touch_RECCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_REC_ICON_TP_REC);
            }
            UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_RECCtrl, TRUE);
            if(uiMovieKeyPressed==UIFLOW_MOVIE_TOUCH_KEY_RECORD)
            {
                Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
                uiResqData[0]=0x02;
                uiResqData[1]=0x02;
                MTKComposeCMDRspFrame(FrameID, CMD_TOUCH,(UINT8 *)&uiResqData, 2);
            }
        }
        else if(TPIsOnRange(&UIFlowWndMovie_Status_Touch_RERTURNCtrl,P1,P2)==TRUE)
        {
            debug_msg("Touch_RERTURNCtrl...RELEASED...\r\n");
            if(uiMovieKeyPressed==UIFLOW_MOVIE_TOUCH_KEY_RETURN)
            {
                UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_RERTURNCtrl, FALSE);
                UxState_SetData(&UIFlowWndMovie_Status_Touch_RERTURNCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_RERTURN_ICON_TP_RETURN);
                UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_RERTURNCtrl, TRUE);
                uiResqData[0]=0x00;
                uiResqData[1]=0x03;
                MTKComposeCMDRspFrame(FrameID, CMD_TOUCH,(UINT8 *)&uiResqData, 2);
            }
        }
        else if(TPIsOnRange(&UIFlowWndMovie_Status_Touch_SnapeShotCtrl,P1,P2)==TRUE)
        {
            debug_msg("Touch_SnapeShotCtrl...RELEASED...\r\n");
            if(uiMovieKeyPressed==UIFLOW_MOVIE_TOUCH_KEY_SNAPESHOT)
            {
                switch(gMovData.State)
                {
                case MOV_ST_VIEW:
                case MOV_ST_VIEW|MOV_ST_ZOOM:
                    UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_SnapeShotCtrl, FALSE);
                    UxState_SetData(&UIFlowWndMovie_Status_Touch_SnapeShotCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_SnapeShot_ICON_SHOT_RELEASE);
                    UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_SnapeShotCtrl, TRUE);

                    Ux_SendEvent(0, NVTEVT_SYSTEM_MODE, 1, PRIMARY_MODE_PHOTO);
                    gbTrigUartTransmitFile=FALSE;
                    uiResqData[0]=0x02;
                    uiResqData[1]=0x04;
                    MTKComposeCMDRspFrame(FrameID, CMD_TOUCH,(UINT8 *)&uiResqData, 2);
                    break;
                case MOV_ST_REC:
                case MOV_ST_REC|MOV_ST_ZOOM:
                    #if 0
                    if(gbGsensorTrig==TRUE)
                    {
                        gbGsensorTrig=FALSE;
                    }
                    gMovData.State= MOV_ST_VIEW;
                    FlowMovie_StopRec();
                    gbMovieRecordingFlag=TRUE;
                    Delay_DelayMs(300);
                    gbTrigUartTransmitFile=FALSE;
                    UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_SnapeShotCtrl, FALSE);
                    UxState_SetData(&UIFlowWndMovie_Status_Touch_SnapeShotCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_SnapeShot_ICON_SHOT_RELEASE);
                    UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_SnapeShotCtrl, TRUE);
                    Ux_SendEvent(0, NVTEVT_SYSTEM_MODE, 1, PRIMARY_MODE_PHOTO);
                    #else
                    UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_SnapeShotCtrl, FALSE);
                    UxState_SetData(&UIFlowWndMovie_Status_Touch_SnapeShotCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_SnapeShot_ICON_SHOT_RELEASE);
                    UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_SnapeShotCtrl, TRUE);
                    //FlowMovie_DrawPIM(TRUE);
                    gbTrigUartTransmitFile=FALSE;
                    uiMovieSize = UI_GetData(FL_MOVIE_SIZE);
                    uiJpegWidth = GetMovieSizeWidth(uiMovieSize);
                    uiJpegHeight = GetMovieSizeHeight(uiMovieSize);
                    uiDAR = GetMovieDispAspectRatio(uiMovieSize);
                    if (uiDAR == VIDENC_DAR_16_9)
                    {
                        uiJpegWidth = (uiJpegHeight * 16) / 9;
                    }

                    Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_REC_RAWENC, 2, uiJpegWidth, uiJpegHeight);
                    Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_RAWENC,FLOWWRNMSG_TIMER_1SEC);
                    #endif
                    uiResqData[0]=0x02;
                    uiResqData[1]=0x04;
                    MTKComposeCMDRspFrame(FrameID, CMD_TOUCH,(UINT8 *)&uiResqData, 2);
                    break;
                }
            }
        }
        else if(TPIsOnRange(&UIFlowWndMovie_Status_Touch_Change_DisplayModeCtrl,P1,P2)==TRUE)
        {
            debug_msg("Touch_Change_DisplayModeCtrl...RELEASED...\r\n");
            if(uiMovieKeyPressed==UIFLOW_MOVIE_TOUCH_KEY_PIPDISPLAY)
            {
                UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_Change_DisplayModeCtrl, FALSE);
                /* add begin by ZMD, 2016-08-24, ╘н╥Є: ├╗╙╨║є┬╖гм╟╨╗╗┤е├■░┤┼е╬▐╨з*/
                if(1==DrvSensor_DetPlugIn(SENSOR_ID_2))//  if(ImageUnit_GetParam(&ISF_ImagePipe, IMAGEPIPE_PARAM_SENSORCOUNT)>=2)
                {
                    UxState_SetData(&UIFlowWndMovie_Status_Touch_Change_DisplayModeCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_Change_DisplayMode_ICON_DISPLAY_CHANGE_RELEASE);
                    UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_Change_DisplayModeCtrl, TRUE);

                    #if defined(YQCONFIG_PIP_VIEW_LR_SUPPORT)

                    if((SysGetFlag(FL_DUAL_CAM)==DUALCAM_LR_16_9)||(SysGetFlag(FL_DUAL_CAM)==DUALCAM_LR_FULL))
                    {
                        //SysSetFlag(FL_DUAL_CAM,DUALCAM_LR_FULL);
                        //else if(SysGetFlag(FL_DUAL_CAM)==DUALCAM_LR_FULL)
                        SysSetFlag(FL_DUAL_CAM,DUALCAM_LR_FRONT_FULL);
                    }
                    else if(SysGetFlag(FL_DUAL_CAM)==DUALCAM_LR_FRONT_FULL)
                    {
                        SysSetFlag(FL_DUAL_CAM,DUALCAM_LR_BEHIND_FULL);
                    }
                    else if(SysGetFlag(FL_DUAL_CAM)==DUALCAM_LR_BEHIND_FULL)
                    {
                        SysSetFlag(FL_DUAL_CAM,DUALCAM_LR_16_9);
                    }
                    else
                    {
                        SysSetFlag(FL_DUAL_CAM,DUALCAM_LR_16_9);
                    }

                    Ux_SendEvent(0,  NVTEVT_EXE_DUALCAM,        1,  SysGetFlag(FL_DUAL_CAM));
                    DBG_DUMP("^GDrawTest:%d\r\n", SysGetFlag(FL_DUAL_CAM));
                    #else
                    if(SysGetFlag(FL_DUAL_CAM)==DUALCAM_FRONT)
                        SysSetFlag(FL_DUAL_CAM,DUALCAM_BEHIND);
                    else if(SysGetFlag(FL_DUAL_CAM)==DUALCAM_BEHIND)
                        SysSetFlag(FL_DUAL_CAM,DUALCAM_BOTH);
                    else if(SysGetFlag(FL_DUAL_CAM)==DUALCAM_BOTH)
                        SysSetFlag(FL_DUAL_CAM,DUALCAM_BOTH2);
                    else if(SysGetFlag(FL_DUAL_CAM)==DUALCAM_BOTH2)
                        SysSetFlag(FL_DUAL_CAM,DUALCAM_FRONT);
                    Ux_SendEvent(0,  NVTEVT_EXE_DUALCAM,        1,  SysGetFlag(FL_DUAL_CAM));
                    DBG_DUMP("^GDrawTest:%d\r\n", SysGetFlag(FL_DUAL_CAM));
                    #endif
                }
                /* add end by ZMD, 2016-08-24 */
                uiResqData[0]=0x02;
                uiResqData[1]=0x05;
                MTKComposeCMDRspFrame(FrameID, CMD_TOUCH,(UINT8 *)&uiResqData, 2);
            }
        }
        #if defined(YQCONFIG_TOUCH_LOCKFILE_OPTION)

        #endif
        #if defined(YQCONFIG_TOUCH_AUDIOSWITCH_OPTION)
        else if(TPIsOnRange(&UIFlowWndMovie_Status_Touch_AudioSwitchCtrl,P1,P2)==TRUE)
        {
            debug_msg("Touch_Change_DisplayModeCtrl...RELEASED...\r\n");
            if(uiMovieKeyPressed==UIFLOW_MOVIE_TOUCH_KEY_AUDIOSWITCH)
            {
                if(UI_GetData(FL_MOVIE_AUDIO)==MOVIE_AUDIO_ON)
                {
                    UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_AudioSwitchCtrl, FALSE);
                    UxState_SetData(&UIFlowWndMovie_Status_Touch_AudioSwitchCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_AudioSwitch_ICON_SOUND_RELEASE);
                    UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_AudioSwitchCtrl, TRUE);
                    guiMTKMenuSetting[MENU_AUDIO_RECORD_SWITCH]=MOVIE_AUDIO_OFF;
                    uiResqData[0]=0x00;
                }
                else
                {
                    UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_AudioSwitchCtrl, FALSE);
                    UxState_SetData(&UIFlowWndMovie_Status_Touch_AudioSwitchCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_AudioSwitch_ICON_SOUND_PRESS);
                    UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_AudioSwitchCtrl, TRUE);
                    guiMTKMenuSetting[MENU_AUDIO_RECORD_SWITCH]=MOVIE_AUDIO_ON;
                    uiResqData[0]=0x01;
                }

                Ux_PostEvent(NVTEVT_MTK_MENU_SETTING, 1,FrameID);

                MTKComposeCMDRspFrame(0, CMD_AUDIO_SWITCH,(UINT8 *)&uiResqData, 1);
                Delay_DelayMs(100);

                uiResqData[0]=0x02;
                uiResqData[1]=0x07;
                MTKComposeCMDRspFrame(FrameID, CMD_TOUCH,(UINT8 *)&uiResqData, 2);
            }
        }
        #endif

        else
        {
            debug_msg("Touch_NULL...RELEASED...\r\n");
            //UxCtrl_SetShow(&UIFlowWndMovie_Status_Main_PBCtrl, FALSE);
            UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_RECCtrl, FALSE);
            UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_RERTURNCtrl, FALSE);
            UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_SnapeShotCtrl, FALSE);
            //UxCtrl_SetShow(&UIFlowWndMovie_Panel_SecondPipviewCtrl, FALSE);
            //UxCtrl_SetShow(&UIFlowWndMovie_Panel_SecondPipview2Ctrl, FALSE);
            UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_Change_DisplayModeCtrl, FALSE);

            //UxState_SetData(&UIFlowWndMovie_Status_Main_PBCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Main_PB_ICON_PLAY_MODE);
            //UxCtrl_SetShow(&UIFlowWndMovie_Status_Main_PBCtrl, TRUE);
            if(!MovRec_IsRecording())
            {
                UxState_SetData(&UIFlowWndMovie_Status_Touch_RECCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_REC_ICON_TP_REC);
            }
            else
            {
                UxState_SetData(&UIFlowWndMovie_Status_Touch_RECCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_REC_ICON_TP_REC_PRESSED);
            }
            UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_RECCtrl, TRUE);
            UxState_SetData(&UIFlowWndMovie_Status_Touch_RERTURNCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_RERTURN_ICON_TP_RETURN);
            UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_RERTURNCtrl, TRUE);
            #if(1)//(PHOTO_FUNCTION==ENABLE)
            UxState_SetData(&UIFlowWndMovie_Status_Touch_SnapeShotCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_SnapeShot_ICON_SHOT_RELEASE);
            UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_SnapeShotCtrl, TRUE);
            #endif
            /* add begin by ZMD, 2016-09-02, ╘н╥Є: ╬▐║є┬╖гм╟╨╗╗┤е├■╬▐╨з*/
            if(1==DrvSensor_DetPlugIn(SENSOR_ID_2))// if(ImageUnit_GetParam(&ISF_ImagePipe, IMAGEPIPE_PARAM_SENSORCOUNT)>=2)
            {
                UxState_SetData(&UIFlowWndMovie_Status_Touch_Change_DisplayModeCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_SnapeShot_ICON_SHOT_RELEASE);
                UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_Change_DisplayModeCtrl, TRUE);
            }
            else
            {
                UxState_SetData(&UIFlowWndMovie_Status_Touch_Change_DisplayModeCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_SnapeShot_ICON_SHOT_RELEASE);
                UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_Change_DisplayModeCtrl, FALSE);
            }

            #if defined(YQCONFIG_TOUCH_AUDIOSWITCH_OPTION)
            if(UI_GetData(FL_MOVIE_AUDIO)==MOVIE_AUDIO_ON)
            {
                UxState_SetData(&UIFlowWndMovie_Status_Touch_AudioSwitchCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_AudioSwitch_ICON_SOUND_RELEASE);
                UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_AudioSwitchCtrl, TRUE);
            }
            else
            {
                UxState_SetData(&UIFlowWndMovie_Status_Touch_AudioSwitchCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_AudioSwitch_ICON_SOUND_PRESS);
                UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_AudioSwitchCtrl, TRUE);
            }
            #endif
            Ux_FlushEvent();
            uiResqData[0]=0x02;
            MTKComposeCMDRspFrame(FrameID, CMD_TOUCH,(UINT8 *)&uiResqData, 1);
        }
        uiMovieKeyPressed=UIFLOW_MOVIE_TOUCH_KEY_NONE;
        break;

    default:
        break;
    }

    return NVTEVT_CONSUME;
}
#endif


BOOL WndMovieTouchPanelKeyUpdateIcons=FALSE;


void UIFlowWndMovie_OnTouchPanelKeyUpdateIcons(BOOL UpdateShow)
{
    if(UpdateShow)
    {
    /*
        debug_msg("WndMovieTouchPanelKeyUpdateIcons2-----%d,%d,%d,%d,%d,%d,%d----\r\n",\
                  UxState_GetData(&UIFlowWndMovie_Status_Main_PBCtrl, STATE_CURITEM),\
                  UxState_GetData(&UIFlowWndMovie_Status_Touch_RECCtrl, STATE_CURITEM) ,\
                  UxState_GetData(&UIFlowWndMovie_Status_Touch_RERTURNCtrl, STATE_CURITEM),\
                  UxState_GetData(&UIFlowWndMovie_Status_Touch_SnapeShotCtrl, STATE_CURITEM),\
                  UxState_GetData(&UIFlowWndMovie_Status_Touch_Change_DisplayModeCtrl, STATE_CURITEM),\
                  UxState_GetData(&UIFlowWndMovie_Status_Touch_LockFileCtrl, STATE_CURITEM) ,\
                  UxState_GetData(&UIFlowWndMovie_Status_Touch_SETUPCtrl, STATE_CURITEM)
                 );
                 */
//        if(UxState_GetData(&UIFlowWndMovie_Status_Main_PBCtrl, STATE_CURITEM) == UIFlowWndMovie_Status_Main_PB_ICON_PLAY_MODE_PRESSED)
//        {
//            UxState_SetData(&UIFlowWndMovie_Status_Main_PBCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Main_PB_ICON_PLAY_MODE);
//            UxCtrl_SetShow(&UIFlowWndMovie_Status_Main_PBCtrl, TRUE);
//        }
        if(UxState_GetData(&UIFlowWndMovie_Status_Touch_RECCtrl, STATE_CURITEM) == UIFlowWndMovie_Status_Touch_REC_ICON_TP_REC_PRESSED)
        {
            //UxState_SetData(&UIFlowWndMovie_Status_Touch_RECCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_REC_ICON_TP_REC);
        }
        if(UxState_GetData(&UIFlowWndMovie_Status_Touch_RERTURNCtrl, STATE_CURITEM) == UIFlowWndMovie_Status_Touch_RERTURN_ICON_TP_RETURN_PRESSED)
        {
            UxState_SetData(&UIFlowWndMovie_Status_Touch_RERTURNCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_RERTURN_ICON_TP_RETURN);
            UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_RERTURNCtrl, TRUE);
        }
        if(UxState_GetData(&UIFlowWndMovie_Status_Touch_SnapeShotCtrl, STATE_CURITEM) == UIFlowWndMovie_Status_Touch_SnapeShot_ICON_SHOT_PRESS)
        {
            UxState_SetData(&UIFlowWndMovie_Status_Touch_SnapeShotCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_SnapeShot_ICON_SHOT_RELEASE);
            UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_SnapeShotCtrl, TRUE);
        }
        if(UxState_GetData(&UIFlowWndMovie_Status_Touch_Change_DisplayModeCtrl, STATE_CURITEM) == UIFlowWndMovie_Status_Touch_Change_DisplayMode_ICON_DISPLAY_CHANGE_PRESS)
        {            
            UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_Change_DisplayModeCtrl, FALSE);
            UxState_SetData(&UIFlowWndMovie_Status_Touch_Change_DisplayModeCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_Change_DisplayMode_ICON_DISPLAY_CHANGE_RELEASE);
            UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_Change_DisplayModeCtrl, TRUE);
        }

#endif
    }
}
#if 1
INT32 UIFlowWndMovie_OnTouchPanelKey(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32 uiPositon=0,P1=0,P2=0;
    UINT8 FrameID=0;
    UINT32 TouchKeyStatus=0xFFFF;

    UINT8   uiResqData[16]= {0};
    UINT32 uiJpegWidth=0, uiJpegHeight=0, uiDAR=0, uiMovieSize=0;

    if(paramNum>0)
        TouchKeyStatus= paramArray[0];
    if(paramNum>1)
    {
        uiPositon= paramArray[1];
        P1=(uiPositon&0xFFFF0000)>>16;
        P2=(uiPositon&0x0000FFFF);
    }
    if(paramNum>2)
        FrameID=paramArray[2];

    if(gbMovieTouchUIDisplayEn==FALSE)
    {
        switch(TouchKeyStatus)
        {
        // case TOUCH_KEY_STATUS_PRESSED:
        case TOUCH_KEY_STATUS_RELEASED:
            uiResqData[0]=0x02;
            MTKComposeCMDRspFrame(FrameID, CMD_TOUCH,(UINT8 *)&uiResqData, 1);
            FlowMovie_UpdateIcons(TRUE);
            gbMovieTouchUIDisplayEn=TRUE;
            break;
        }
        return NVTEVT_CONSUME;
    }

    guiMovieTouchUIDisplayCounter=0;


    switch(TouchKeyStatus)
    {

    case TOUCH_KEY_STATUS_RELEASED:
        // case TOUCH_KEY_STATUS_PRESSED:

//        if(TPIsOnRange(&UIFlowWndMovie_Status_Main_PBCtrl,P1,P2)==TRUE)
//        {
//            debug_msg("Main_PBCtrl...%d\r\n",gMovData.State);
//            if (UI_GetData(FL_CardStatus) == CARD_REMOVED)
//            {
//                Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD,FLOWWRNMSG_TIMER_2SEC);
//                uiResqData[0]=0x03;
//                MTKComposeCMDRspFrame(FrameID, CMD_TOUCH,(UINT8 *)&uiResqData, 1);
//                return NVTEVT_CONSUME;
//            }
//            switch(gMovData.State)
//            {
//            case MOV_ST_REC:
//            case MOV_ST_REC|MOV_ST_ZOOM:
//            case MOV_ST_VIEW:
//            case MOV_ST_VIEW|MOV_ST_ZOOM:
//                UxState_SetData(&UIFlowWndMovie_Status_Main_PBCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Main_PB_ICON_PLAY_MODE_PRESSED);
//                WndMovieTouchPanelKeyUpdateIcons=TRUE;
//                //UxState_SetData(&UIFlowWndMovie_Status_Main_PBCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Main_PB_ICON_PLAY_MODE);
//                break;
//            }
//            Ux_PostEvent(NVTEVT_KEY_MODE, 1, NVTEVT_KEY_PRESS);
//            uiResqData[0]=0x02;
//            uiResqData[1]=0x01;
//            MTKComposeCMDRspFrame(FrameID, CMD_TOUCH,(UINT8 *)&uiResqData, 2);
//        }
//        else 
            if(TPIsOnRange(&UIFlowWndMovie_Status_Touch_RECCtrl,P1,P2)==TRUE)
        {
            debug_msg("Touch_RECCtrl...\r\n");

            if(MovRec_IsRecording())
            {
                UxState_SetData(&UIFlowWndMovie_Status_Touch_RECCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_REC_ICON_TP_REC_PRESSED);
            }
            else
            {
                UxState_SetData(&UIFlowWndMovie_Status_Touch_RECCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_REC_ICON_TP_REC);
            }

            Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
            uiResqData[0]=0x02;
            uiResqData[1]=0x02;
            MTKComposeCMDRspFrame(FrameID, CMD_TOUCH,(UINT8 *)&uiResqData, 2);
        }
        else if(TPIsOnRange(&UIFlowWndMovie_Status_Touch_RERTURNCtrl,P1,P2)==TRUE)
        {
            debug_msg("Touch_RERTURNCtrl...\r\n");

            UxState_SetData(&UIFlowWndMovie_Status_Touch_RERTURNCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_RERTURN_ICON_TP_RETURN_PRESSED);
            WndMovieTouchPanelKeyUpdateIcons=TRUE;
            //UxState_SetData(&UIFlowWndMovie_Status_Touch_RERTURNCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_RERTURN_ICON_TP_RETURN);

            uiResqData[0]=0x00;
            uiResqData[1]=0x03;
            MTKComposeCMDRspFrame(FrameID, CMD_TOUCH,(UINT8 *)&uiResqData, 2);
        }
        else if(TPIsOnRange(&UIFlowWndMovie_Status_Touch_SnapeShotCtrl,P1,P2)==TRUE)
        {
            debug_msg("Touch_SnapeShotCtrl...\r\n");

            if (UI_GetData(FL_CardStatus) == CARD_REMOVED)
            {
                Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD,FLOWWRNMSG_TIMER_2SEC);
                uiResqData[0]=0x03;
                MTKComposeCMDRspFrame(FrameID, CMD_TOUCH,(UINT8 *)&uiResqData, 1);
                return NVTEVT_CONSUME;
            }

            UxState_SetData(&UIFlowWndMovie_Status_Touch_SnapeShotCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_SnapeShot_ICON_SHOT_PRESS);
            WndMovieTouchPanelKeyUpdateIcons=TRUE;
            //UxState_SetData(&UIFlowWndMovie_Status_Touch_SnapeShotCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_SnapeShot_ICON_SHOT_RELEASE);

            switch(gMovData.State)
            {
            case MOV_ST_VIEW:
            case MOV_ST_VIEW|MOV_ST_ZOOM:

          /*      Ux_SendEvent(0, NVTEVT_SYSTEM_MODE, 1, PRIMARY_MODE_PHOTO);
                gbTrigUartTransmitFile=FALSE;

                uiResqData[0]=0x02;
                uiResqData[1]=0x04;
                MTKComposeCMDRspFrame(FrameID, CMD_TOUCH,(UINT8 *)&uiResqData, 2);
           */
                break;
            case MOV_ST_REC:
            case MOV_ST_REC|MOV_ST_ZOOM:
                #if 0
                if(gbGsensorTrig==TRUE)
                {
                    gbGsensorTrig=FALSE;
                }
                gMovData.State= MOV_ST_VIEW;
                FlowMovie_StopRec();
                gbMovieRecordingFlag=TRUE;
                Delay_DelayMs(300);
                gbTrigUartTransmitFile=FALSE;
                UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_SnapeShotCtrl, FALSE);
                UxState_SetData(&UIFlowWndMovie_Status_Touch_SnapeShotCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_SnapeShot_ICON_SHOT_RELEASE);
                UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_SnapeShotCtrl, TRUE);
                Ux_SendEvent(0, NVTEVT_SYSTEM_MODE, 1, PRIMARY_MODE_PHOTO);
                #else

                //FlowMovie_DrawPIM(TRUE);
                gbTrigUartTransmitFile=FALSE;
                uiMovieSize = UI_GetData(FL_MOVIE_SIZE);
                uiJpegWidth = GetMovieSizeWidth(uiMovieSize);
                uiJpegHeight = GetMovieSizeHeight(uiMovieSize);
                uiDAR = GetMovieDispAspectRatio(uiMovieSize);
                if (uiDAR == VIDENC_DAR_16_9)
                {
                    uiJpegWidth = (uiJpegHeight * 16) / 9;
                }
                Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_REC_RAWENC, 2, uiJpegWidth, uiJpegHeight);
                Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_RAWENC,FLOWWRNMSG_TIMER_1SEC);
                #endif

                uiResqData[0]=0x02;
                uiResqData[1]=0x04;
                MTKComposeCMDRspFrame(FrameID, CMD_TOUCH,(UINT8 *)&uiResqData, 2);
                break;
            }
        }
        else if(TPIsOnRange(&UIFlowWndMovie_Status_Touch_Change_DisplayModeCtrl,P1,P2)==TRUE)
        {
            debug_msg("Touch_Change_DisplayModeCtrl...\r\n");

            /* add begin by ZMD, 2016-09-02, ╘н╥Є: ╬▐║є┬╖├╗╙╨╟╨╗╗╣ж─▄*/
            if(1==DrvSensor_DetPlugIn(SENSOR_ID_2))// if(ImageUnit_GetParam(&ISF_ImagePipe, IMAGEPIPE_PARAM_SENSORCOUNT)>=2)
            {
                UxState_SetData(&UIFlowWndMovie_Status_Touch_Change_DisplayModeCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_Change_DisplayMode_ICON_DISPLAY_CHANGE_PRESS);
                WndMovieTouchPanelKeyUpdateIcons=TRUE;
                //UxState_SetData(&UIFlowWndMovie_Status_Touch_Change_DisplayModeCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_Change_DisplayMode_ICON_DISPLAY_CHANGE_RELEASE);

                #if defined(YQCONFIG_PIP_VIEW_LR_SUPPORT)
                if((SysGetFlag(FL_DUAL_CAM)==DUALCAM_LR_16_9)||(SysGetFlag(FL_DUAL_CAM)==DUALCAM_LR_FULL))
                {
                    //SysSetFlag(FL_DUAL_CAM,DUALCAM_LR_FULL);
                    //else if(SysGetFlag(FL_DUAL_CAM)==DUALCAM_LR_FULL)
                    SysSetFlag(FL_DUAL_CAM,DUALCAM_LR_FRONT_FULL);
                }
                else if(SysGetFlag(FL_DUAL_CAM)==DUALCAM_LR_FRONT_FULL)
                {
                    SysSetFlag(FL_DUAL_CAM,DUALCAM_LR_BEHIND_FULL);
                }
                else if(SysGetFlag(FL_DUAL_CAM)==DUALCAM_LR_BEHIND_FULL)
                {
                    SysSetFlag(FL_DUAL_CAM,DUALCAM_LR_16_9);
                }
                else
                {
                    SysSetFlag(FL_DUAL_CAM,DUALCAM_LR_16_9);
                }

                Ux_SendEvent(0,  NVTEVT_EXE_DUALCAM,        1,  SysGetFlag(FL_DUAL_CAM));
                //  Ux_PostEvent(0,  NVTEVT_EXE_DUALCAM,        1,  SysGetFlag(FL_DUAL_CAM));
                DBG_DUMP("^GDrawTest1:%d\r\n", SysGetFlag(FL_DUAL_CAM));
                #else
                if(SysGetFlag(FL_DUAL_CAM)==DUALCAM_FRONT)
                {
                    SysSetFlag(FL_DUAL_CAM,DUALCAM_BEHIND);
                }
                else if(SysGetFlag(FL_DUAL_CAM)==DUALCAM_BEHIND)
                {
                    SysSetFlag(FL_DUAL_CAM,DUALCAM_BOTH);
                }
                else if(SysGetFlag(FL_DUAL_CAM)==DUALCAM_BOTH)
                {
                    SysSetFlag(FL_DUAL_CAM,DUALCAM_BOTH2);
                }
                else if(SysGetFlag(FL_DUAL_CAM)==DUALCAM_BOTH2)
                {
                    SysSetFlag(FL_DUAL_CAM,DUALCAM_FRONT);
                }
                Ux_SendEvent(0,  NVTEVT_EXE_DUALCAM,        1,  SysGetFlag(FL_DUAL_CAM));
                DBG_DUMP("^GDrawTest2:%d\r\n", SysGetFlag(FL_DUAL_CAM));
                #endif
                uiResqData[0]=0x02;
                uiResqData[1]=0x05;
                MTKComposeCMDRspFrame(FrameID, CMD_TOUCH,(UINT8 *)&uiResqData, 2);
            }
            else
            {
                //UxState_SetData(&UIFlowWndMovie_Status_Touch_Change_DisplayModeCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_Change_DisplayMode_ICON_DISPLAY_CHANGE_PRESS);
                UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_Change_DisplayModeCtrl, FALSE);
            }
        }
        #if defined(YQCONFIG_TOUCH_AUDIOSWITCH_OPTION)
        else if(TPIsOnRange(&UIFlowWndMovie_Status_Touch_AudioSwitchCtrl,P1,P2)==TRUE)
        {
            debug_msg("Touch_Change_DisplayModeCtrl...\r\n");

            if(UI_GetData(FL_MOVIE_AUDIO)==MOVIE_AUDIO_ON)
            {
                UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_AudioSwitchCtrl, FALSE);
                UxState_SetData(&UIFlowWndMovie_Status_Touch_AudioSwitchCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_AudioSwitch_ICON_SOUND_RELEASE);
                UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_AudioSwitchCtrl, TRUE);
            }
            else
            {
                UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_AudioSwitchCtrl, FALSE);
                UxState_SetData(&UIFlowWndMovie_Status_Touch_AudioSwitchCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_AudioSwitch_ICON_SOUND_PRESS);
                UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_AudioSwitchCtrl, TRUE);
            }


            if(UI_GetData(FL_MOVIE_AUDIO)==MOVIE_AUDIO_ON)
            {
                UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_AudioSwitchCtrl, FALSE);
                UxState_SetData(&UIFlowWndMovie_Status_Touch_AudioSwitchCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_AudioSwitch_ICON_SOUND_RELEASE);
                UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_AudioSwitchCtrl, TRUE);
                guiMTKMenuSetting[MENU_AUDIO_RECORD_SWITCH]=MOVIE_AUDIO_OFF;
                uiResqData[0]=0x00;
            }
            else
            {
                UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_AudioSwitchCtrl, FALSE);
                UxState_SetData(&UIFlowWndMovie_Status_Touch_AudioSwitchCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_AudioSwitch_ICON_SOUND_PRESS);
                UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_AudioSwitchCtrl, TRUE);
                guiMTKMenuSetting[MENU_AUDIO_RECORD_SWITCH]=MOVIE_AUDIO_ON;
                uiResqData[0]=0x01;
            }

            Ux_PostEvent(NVTEVT_MTK_MENU_SETTING, 1,FrameID);

            MTKComposeCMDRspFrame(0, CMD_AUDIO_SWITCH,(UINT8 *)&uiResqData, 1);
            Delay_DelayMs(100);

            uiResqData[0]=0x02;
            uiResqData[1]=0x07;
            MTKComposeCMDRspFrame(FrameID, CMD_TOUCH,(UINT8 *)&uiResqData, 2);

        }
        #endif
        else
        {
            debug_msg("Touch_NULL...\r\n");
            Ux_FlushEvent();

            //UxCtrl_SetShow(&UIFlowWndMovie_Status_Main_PBCtrl, FALSE);
            UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_RECCtrl, FALSE);
            UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_RERTURNCtrl, FALSE);
            UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_SnapeShotCtrl, FALSE);
            //UxCtrl_SetShow(&UIFlowWndMovie_Panel_SecondPipviewCtrl, FALSE);
            //UxCtrl_SetShow(&UIFlowWndMovie_Panel_SecondPipview2Ctrl, FALSE);
            UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_Change_DisplayModeCtrl, FALSE);

            //UxState_SetData(&UIFlowWndMovie_Status_Main_PBCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Main_PB_ICON_PLAY_MODE);
            //UxCtrl_SetShow(&UIFlowWndMovie_Status_Main_PBCtrl, TRUE);
            if(!MovRec_IsRecording())
            {
                UxState_SetData(&UIFlowWndMovie_Status_Touch_RECCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_REC_ICON_TP_REC);
            }
            else
            {
                UxState_SetData(&UIFlowWndMovie_Status_Touch_RECCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_REC_ICON_TP_REC_PRESSED);
            }
            UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_RECCtrl, TRUE);
            UxState_SetData(&UIFlowWndMovie_Status_Touch_RERTURNCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_RERTURN_ICON_TP_RETURN);
            UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_RERTURNCtrl, TRUE);

          if(MovRec_IsRecording()){
            UxState_SetData(&UIFlowWndMovie_Status_Touch_SnapeShotCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_SnapeShot_ICON_SHOT_RELEASE);
            UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_SnapeShotCtrl, TRUE);
          }else{
             UxState_SetData(&UIFlowWndMovie_Status_Touch_SnapeShotCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_SnapeShot_ICON_SHOT_RELEASE);
            UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_SnapeShotCtrl, FALSE);

          }
            /* add begin by ZMD, 2016-09-02, ╘н╥Є: ╬▐║є┬╖гм╟╨╗╗┤е├■╬▐╨з*/
            if(1==DrvSensor_DetPlugIn(SENSOR_ID_2))// if(ImageUnit_GetParam(&ISF_ImagePipe, IMAGEPIPE_PARAM_SENSORCOUNT)>=2)
            {
                UxState_SetData(&UIFlowWndMovie_Status_Touch_Change_DisplayModeCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_SnapeShot_ICON_SHOT_RELEASE);
                UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_Change_DisplayModeCtrl, TRUE);
            }
            else
            {
                UxState_SetData(&UIFlowWndMovie_Status_Touch_Change_DisplayModeCtrl,STATE_CURITEM,UIFlowWndMovie_Status_Touch_SnapeShot_ICON_SHOT_RELEASE);
                UxCtrl_SetShow(&UIFlowWndMovie_Status_Touch_Change_DisplayModeCtrl, FALSE);
            }

            uiResqData[0]=0x02;
            MTKComposeCMDRspFrame(FrameID, CMD_TOUCH,(UINT8 *)&uiResqData, 1);
        }
        break;

    default:
        break;
    }

    return NVTEVT_CONSUME;
}
#endif

INT32 UIFlowWndMovie_OnMTKMenuSetting(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT8   uiResqData[16]= {0};
    UINT32 FrameID;
    static BOOL MtkFirstAnswer=TRUE;
    UINT32 uiFWVersion;
    UINT32 uiMCUVersion;
    UINT32 i;

    if(paramNum>0)
        FrameID=paramArray[0];

    XmodemGetMTKMenuSetting(MTKMenuSetting);


    debug_msg("get menu setting :");
    for(i=0; i<MENU_MTK_SETTING_MAX; i++)
    {
        debug_msg("%d  ,",MTKMenuSetting[i]);
    }
    debug_msg("\r\n");

//***************************NT96663 movie record resolution begin*************************************
    #if 1//debug message for log
    debug_msg("=================================================\r\n");
    switch(MTKMenuSetting[MENU_MOVIE_RESOLUTION])
    {
    case MOVIE_SIZE_DUAL_1920x1080P30_1920x1080P30:
        debug_msg("Movie size: dual 1920x1080\r\n");
        break;
    case MOVIE_SIZE_FRONT_1920x1080P30:
        debug_msg("Movie size: single 1920x1080 p30 fps\r\n");
        break;
    case MOVIE_SIZE_FRONT_1280x720P30:
        debug_msg("Movie size: single 1280x720 p30 fps\r\n");
        break;
    default:
        debug_msg("Movie size: unknows index:%d\r\n",UI_GetData(FL_MOVIE_SIZE));
        break;
    }
    switch(MTKMenuSetting[MENU_MOVIE_CYCLE_RECORD])
    {
    case MOVIE_CYCLICREC_OFF:
        debug_msg("Movie cycle record OFF \r\n");
        break;
    case MOVIE_CYCLICREC_3MIN:
        debug_msg("Movie cycle record 3 minutes \r\n");
        break;
    case MOVIE_CYCLICREC_5MIN:
        debug_msg("Movie cycle record 5 minutes \r\n");
        break;
    case MOVIE_CYCLICREC_10MIN:
        debug_msg("Movie cycle record 10 minutes \r\n");
        break;
    default:
        debug_msg("Movie cycle record: unknows index:%d\r\n",UI_GetData(FL_MOVIE_CYCLIC_REC));
        break;
    }
    debug_msg("WDR :         	%s\r\n",(MTKMenuSetting[MENU_MOVIE_CYCLE_RECORD]==MOVIE_WDR_ON)?"ON":"OFF");
    debug_msg("Motion Det :	%s\r\n",(MTKMenuSetting[MENU_MOVIE_MOTION_DET]==MOVIE_MOTIONDET_ON)?"ON":"OFF");
    debug_msg("Gsensor :    	%s\r\n",(MTKMenuSetting[MENU_MOVIE_GSENSOR]==GSENSOR_OFF)?"OFF":"ON");
    debug_msg("Parking :      	%s\r\n",(MTKMenuSetting[MENU_MOVIE_PARKINGMODE]==PARKINGMODE_ON)?"ON":"OFF");
    debug_msg("ADAS :        	%s\r\n",(MTKMenuSetting[MENU_MOVIE_ADAS]==MOVIE_ADAS_CAL_ON)?"ON":"OFF");
    debug_msg("SpeedLimit : 	%d\r\n",MTKMenuSetting[MENU_ADAS_SPEED_TRR]);
    debug_msg("=================================================\r\n");
    #endif

    if((MTKMenuSetting[MENU_MOVIE_RESOLUTION]==MOVIE_SIZE_DUAL_1920x1080P30_1920x1080P30)||(MTKMenuSetting[MENU_MOVIE_RESOLUTION]==MOVIE_SIZE_FRONT_1920x1080P30)\
            &&(MTKMenuSetting[MENU_MOVIE_RESOLUTION]==MOVIE_SIZE_FRONT_1280x720P30))
    {
        if(MTKMenuSetting[MENU_MOVIE_RESOLUTION]==MOVIE_SIZE_DUAL_1920x1080P30_1920x1080P30)
        {
            debug_msg("====>[%d]movie resolution dual 1080P ok..%d..%d..\r\n",DrvSensor_DetPlugIn(SENSOR_ID_2),UI_GetData(FL_DUAL_CAM),UI_GetData(FL_DUAL_CAM_MENU));
            if(DrvSensor_DetPlugIn(SENSOR_ID_2)==1)
            {
                debug_msg("====>movie resolution save dual index OK..\r\n");
                uiResqData[MENU_MOVIE_RESOLUTION]=MTK_MENU_RESQ_SUCCESS;
            }
            else
            {
                debug_msg("====>[%d]movie resolution save dual index fail..%d..\r\n",DrvSensor_DetPlugIn(SENSOR_ID_2),SysGetFlag(FL_MOVIE_SIZE));
                uiResqData[MENU_MOVIE_RESOLUTION]=SysGetFlag(FL_MOVIE_SIZE);//MTK_MENU_RESQ_FAIL;
            }
        }
        else
        {
            debug_msg("====>[%d]movie resolution save index ok..%d..\r\n",MTKMenuSetting[MENU_MOVIE_RESOLUTION]);
            uiResqData[MENU_MOVIE_RESOLUTION]=MTK_MENU_RESQ_SUCCESS;
        }
    }
    else
    {
        uiResqData[MENU_MOVIE_RESOLUTION]=MTK_MENU_RESQ_FAIL;
    }

//***************************NT96663 movie record resolution end*************************************

//***************************NT96663 movie cycle record  begin*******************************
    if((MTKMenuSetting[MENU_MOVIE_CYCLE_RECORD]>=MOVIE_CYCLICREC_OFF)&&(MTKMenuSetting[MENU_MOVIE_CYCLE_RECORD]<MOVIE_CYCLICREC_ID_MAX))
    {
        uiResqData[MENU_MOVIE_CYCLE_RECORD]=MTK_MENU_RESQ_SUCCESS;
    }
    else
    {
        uiResqData[MENU_MOVIE_CYCLE_RECORD]=MTK_MENU_RESQ_FAIL;
    }

//***************************NT96663 movie cycle record  end*******************************

//********************************NT96663 movie wdr  begin********************************
    if((MTKMenuSetting[MENU_MOVIE_HDR]>=MOVIE_WDR_OFF)&&(MTKMenuSetting[MENU_MOVIE_HDR]<MOVIE_WDR_ID_MAX))
    {
        uiResqData[MENU_MOVIE_HDR]=MTK_MENU_RESQ_SUCCESS;
    }
    else
    {
        uiResqData[MENU_MOVIE_HDR]=MTK_MENU_RESQ_FAIL;
    }

//********************************NT96663 movie wdr  end********************************


//********************************NT96663 movie gsensor  begin********************************
    if((MTKMenuSetting[MENU_MOVIE_GSENSOR]>=0)&&(MTKMenuSetting[MENU_MOVIE_GSENSOR]<4))
    {
        uiResqData[MENU_MOVIE_GSENSOR]=MTK_MENU_RESQ_SUCCESS;
    }
    else
    {
        uiResqData[MENU_MOVIE_GSENSOR]=MTK_MENU_RESQ_FAIL;
    }

//********************************NT96663 movie gsensor  end********************************

//********************************NT96663 movie parking mode  begin********************************
    if((MTKMenuSetting[MENU_MOVIE_PARKINGMODE]>=0)&&(MTKMenuSetting[MENU_MOVIE_PARKINGMODE]<2))
    {
        uiResqData[MENU_MOVIE_PARKINGMODE]=MTK_MENU_RESQ_SUCCESS;
    }
    else
    {
        uiResqData[MENU_MOVIE_PARKINGMODE]=MTK_MENU_RESQ_FAIL;
    }
//********************************NT96663 movie parking mode  end********************************

//********************************NT96663 movie adas  begin********************************
    if((MTKMenuSetting[MENU_MOVIE_ADAS]>=0)&&(MTKMenuSetting[MENU_MOVIE_ADAS]<2))
    {
        if(MTKMenuSetting[MENU_MOVIE_ADAS]==MOVIE_ADAS_CAL_ON)
        {
            if((UI_GetData(FL_MOVIE_SIZE_MENU)==MOVIE_SIZE_FRONT_2880x2160P24)||(UI_GetData(FL_MOVIE_SIZE_MENU)==MOVIE_SIZE_FRONT_2560x1440P30)||\
                    (UI_GetData(FL_MOVIE_SIZE_MENU)==MOVIE_SIZE_FRONT_1280x720P120))
            {
                debug_msg("please check second sensor adas..\r\n");
                uiResqData[MENU_MOVIE_ADAS]=MTK_MENU_RESQ_FAIL;
            }
            else
            {
                uiResqData[MENU_MOVIE_ADAS]=MTK_MENU_RESQ_SUCCESS;
            }
        }
        else
        {
            uiResqData[MENU_MOVIE_ADAS]=MTK_MENU_RESQ_SUCCESS;
        }
    }
    else
    {
        uiResqData[MENU_MOVIE_ADAS]=MTK_MENU_RESQ_FAIL;
    }

//********************************NT96663 movie adas  end********************************

//********************************NT96663 movie adas  gps speed begin********************************
    g_MTKSetADASEnSpeed=MTKMenuSetting[MENU_ADAS_SPEED_TRR];
    uiResqData[MENU_ADAS_SPEED_TRR]=MTKMenuSetting[MENU_ADAS_SPEED_TRR];

    #if defined(AUDIO_MIC_SWITCH_SUPPORT) && (AUDIO_MIC_SWITCH_SUPPORT==ENABLE)

//pgl 20160628 add beg
//********************************NT96663 movie audio record begin********************************
    if((MTKMenuSetting[MENU_AUDIO_RECORD_SWITCH]>=0)&&(MTKMenuSetting[MENU_AUDIO_RECORD_SWITCH]<2))
    {
        uiResqData[MENU_AUDIO_RECORD_SWITCH]=MTK_MENU_RESQ_SUCCESS;
    }
    else
    {
        uiResqData[MENU_AUDIO_RECORD_SWITCH]=MTK_MENU_RESQ_FAIL;
    }
//********************************NT96663 movie audio record end********************************
//pgl 20160628 add end
    #endif
//********************************NT96663 movie FW  version begin********************************


    #if(FW_VERSION_NUM_FUNC==ENABLE)
    uiResqData[MENU_VERSION1]=0;
    uiResqData[MENU_VERSION2]=0;
    #endif

    #if defined(YQCONFIG_UART_TO_MCU_SUPPORT)
    //*****************************MCU version*************************************
    if((currentInfo.MCU_Ver[0]!=0)||(currentInfo.MCU_Ver[1]!=0))
    {
        uiResqData[MENU_MCUVERSION1] = (currentInfo.MCU_Ver[0]);
        uiResqData[MENU_MCUVERSION2] = (currentInfo.MCU_Ver[1]);
    }
    else
    {
        // uiMCUVersion = Prj_GetMCUVersionNum();
        //uiResqData[MENU_MCUVERSION1] = (uiMCUVersion >> 8);
        // uiResqData[MENU_MCUVERSION2] = (uiMCUVersion & 0xff);
    }
    debug_msg("Get_MCU_VER = %X.%X ===>>>\r\n",uiResqData[MENU_MCUVERSION1],uiResqData[MENU_MCUVERSION2]);
    #endif
//********************************NT96663 movie FW  version end********************************
    memcpy(MTKMenuSettingTmp, MTKMenuSetting,32);
    MTKComposeCMDRspFrame(FrameID, CMD_SETTING,(UINT8 *)&uiResqData, MENU_MTK_SETTING_MAX);

    /* add begin by ZMD, 2016-10-28, ╘н╥Є:╨┬░ц▒╛╣▄└э */
    #if(FW_VERSION_NUM_FUNC==ENABLE)
    //char FwVersionInfoTemp[50]= {0};
    Mtk_Prj_GetVersionString();

    UINT8 LenTemp=0;
    LenTemp=strlen(FwVersion_string);

    debug_msg("PRJ_FW_VERSION_NUM_LenTemp : %d \r\n",LenTemp);
    debug_msg("PRJ_FW_VERSION_NUM :");

    for(i=0; i<LenTemp; i++)
    {
        debug_msg("%d--",FwVersion_string[i]);
    }

    #if 0
    LenTemp=8;
    for(i=0; i<LenTemp; i++)
    {
        debug_msg("%d--",FwVersionInfo.Prj_Name_string[i]);

    }
    debug_msg("\r\n");
    for(i=0; i<LenTemp; i++)
    {
        debug_msg("%d--",FwVersionInfo.Server_Name_String[i]);
    }
    debug_msg("\r\n");
    for(i=0; i<LenTemp; i++)
    {
        debug_msg("%d--",FwVersionInfo.Sensor_Type_String[i]);
    }
    debug_msg("\r\n");
    for(i=0; i<LenTemp; i++)
    {
        debug_msg("%d--",FwVersionInfo.Code_Type_String[i]);
    }
    debug_msg("\r\n");
    for(i=0; i<LenTemp; i++)
    {
        debug_msg("%d--",FwVersionInfo.Fw_Ver_String[i]);
    }
    debug_msg("\r\n");
    for(i=0; i<LenTemp; i++)
    {
        debug_msg("%d--",FwVersionInfo.Date_String[i]);
    }

    #endif
    debug_msg("\r\n");

    extern BOOL FwVersion_Seting_state;

    if(FwVersion_Seting_state==FWVERSION_SETING_STATE_OFF)
    {
        FwVersion_Seting_state=FWVERSION_SETING_STATE_ON;
    }
    Delay_DelayMs(200);
    MTKComposeCMDRspFrame(FrameID+1, CMD_FWVERSION,(UINT8 *)&FwVersion_string, LenTemp);
    #endif
    /* add end by ZMD, 2016-10-28 */
    return NVTEVT_CONSUME;
}

extern BOOL System_GetSensor2Plug(void);//pgl 20160905 add

INT32 UIFlowWndMovie_OnMTKGpsInfo(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT8   uiResqData[16]= {0};
    UINT32 FrameID=0;
    static UINT8 Count_Temp1=0;
    static UINT8 Count_Temp2=0;
    UINT32 i=0;
    if(paramNum>0)
        FrameID=paramArray[0];

    uiResqData[0]=0x00;
    uiResqData[0] =( (0x01<<1)|uiResqData[0]);
//pgl_modify
    switch(gMovData.State)
    {
    case MOV_ST_REC:
    case MOV_ST_REC|MOV_ST_ZOOM:
        uiResqData[0]=(0xC0|uiResqData[0]);
        break;
    case MOV_ST_VIEW:
    case MOV_ST_VIEW|MOV_ST_ZOOM:
        uiResqData[0]=(uiResqData[0]&0x3F);
        break;
    }
//pgl_modify


//pgl 20160905 add beg
    if(System_GetSensor2Plug())
    {
        uiResqData[1] = 0x01;
    }
    else
    {
        uiResqData[1] = 0x0;
    }
//pgl 20160905 add end

    if(UI_GetData(FL_MOVIE_SIZE) ==MOVIE_SIZE_DUAL_1920x1080P30_1920x1080P30)
    {
        uiResqData[1] =( (0x01<<1)|uiResqData[1]);
    }
    else if(UI_GetData(FL_MOVIE_SIZE)==MOVIE_SIZE_FRONT_1920x1080P30)
    {
        uiResqData[1] = ((0x02<<1)|uiResqData[1]);
    }
    else if(UI_GetData(FL_MOVIE_SIZE)==MOVIE_SIZE_FRONT_1280x720P30)
    {
        uiResqData[1] = ((0x03<<1)|uiResqData[1]);
    }
    else
    {
        uiResqData[1] = ((0x00<<1)|uiResqData[1]);
    }
    uiResqData[1] = ((0x08<<1)|uiResqData[1]);

    #if(FW_VERSION_NUM_FUNC==ENABLE)
    extern BOOL FwVersion_Seting_state;
    if(FwVersion_Seting_state==FWVERSION_SETING_STATE_ON)
    {
        if(2<=Count_Temp2)
        {

        }
        else
        {
            Count_Temp1++;
            if(3<=Count_Temp1)
            {
                Count_Temp1=0;
                Count_Temp2++;
                UINT8 LenTemp=0;
                LenTemp=strlen(FwVersion_string);
                MTKComposeCMDRspFrame(FrameID, CMD_FWVERSION,(UINT8 *)&FwVersion_string, LenTemp);
                Delay_DelayMs(200);
                debug_msg("PRJ_FW_VERSION_NUM_GPS :");
                for(i=0; i<LenTemp; i++)
                {
                    debug_msg("%d--",FwVersion_string[i]);
                }
                debug_msg("\r\n");
            }
        }
    }
    else
    {
        Count_Temp1=0;
    }
    #endif
    //  debug_msg("UIFlowWndMovie_OnMTKGpsInfo:--%x--%x--\r\n",uiResqData[0],uiResqData[1]);
    MTKComposeCMDRspFrame(FrameID, CMD_GPS,(UINT8 *)&uiResqData, 2/*1*/);	//pgl modify 20160905

    return NVTEVT_CONSUME;
}

//pgl add adas_switch_cmd 20160429 beg
INT32 UIFlowWndMovie_OnAdasSetting(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{

    UINT32 i;
    static BOOL gbneed2changmode=FALSE;
    UINT8   uiResqData[16]= {0};
    UINT32 FrameID;
    static BOOL MtkFirstAnswer=TRUE;
    UINT32 uiFWVersion;
    UINT8 adas_switch = 0;

    if(paramNum>0)
        FrameID=paramArray[0];

    if(paramNum>1)
    {
        adas_switch= paramArray[1];

    }

    debug_msg("UIFlowWndMovie_OnAdasSetting: %d\r\n",adas_switch );
//********************************NT96663 movie adas  begin********************************
    if(UI_GetData(FL_MOVIE_ADAS_CAL) != adas_switch)
    {
        if(adas_switch==MOVIE_ADAS_CAL_ON)
        {
            if((UI_GetData(FL_MOVIE_SIZE_MENU)==MOVIE_SIZE_FRONT_2880x2160P24)||(UI_GetData(FL_MOVIE_SIZE_MENU)==MOVIE_SIZE_FRONT_2560x1440P30)||\
                    (UI_GetData(FL_MOVIE_SIZE_MENU)==MOVIE_SIZE_FRONT_1280x720P120))
            {
                debug_msg("please check second sensor adas..\r\n");
                uiResqData[0]=MTK_MENU_RESQ_FAIL;
            }
            else
            {
                uiResqData[0]=MTK_MENU_RESQ_SUCCESS;
            }
        }
        else
        {
            uiResqData[0]=MTK_MENU_RESQ_SUCCESS;
        }

    }
    else
    {
        if(UI_GetData(FL_MOVIE_ADAS_CAL)==MOVIE_ADAS_CAL_ON)
        {
            if((UI_GetData(FL_MOVIE_SIZE_MENU)==MOVIE_SIZE_FRONT_2880x2160P24)||(UI_GetData(FL_MOVIE_SIZE_MENU)==MOVIE_SIZE_FRONT_2560x1440P30)||\
                    (UI_GetData(FL_MOVIE_SIZE_MENU)==MOVIE_SIZE_FRONT_1280x720P120))
            {
                debug_msg("please check second sensor adas..\r\n");
                uiResqData[0]=MTK_MENU_RESQ_FAIL;
            }
        }
        else
        {
            uiResqData[0]=MTK_MENU_RESQ_SUCCESS;
        }
    }
//********************************NT96663 movie adas  end********************************

    MTKComposeCMDRspFrame(FrameID, CMD_ADAS_SWITCH,(UINT8 *)&uiResqData, 1);	// 0x06 ==CMD_GPS
    return NVTEVT_CONSUME;

}
//pgl add adas_switch_cmd 20160429 end

INT32 UIFlowWndMovie_OnCustom2(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32 FrameID;
    UINT32 uiJpegWidth, uiJpegHeight, uiDAR, uiMovieSize;
    UINT8   uiResqData[16]= {0};
    UINT32 gbTransmitSensorSelect=0;
    if(paramNum>0)
        FrameID=paramArray[0];
    if(paramNum>1)
        gbTransmitSensorSelect=paramArray[1];
    if (UI_GetData(FL_MOVIE_SIZE) == MOVIE_SIZE_FRONT_2880x2160P24)
    {
        if (KeyScan_GetPlugDev() == PLUG_HDMI)
            return NVTEVT_CONSUME;
    }
    if(System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_SAFE)
    {
        if (UI_GetData(FL_CardStatus) == CARD_REMOVED)
        {
            Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD,FLOWWRNMSG_TIMER_2SEC);
            return NVTEVT_CONSUME;
        }
    }
    else if (System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_NORMAL)
    {
        if (GxStrg_GetDeviceCtrl(0, CARD_READONLY)) // card lock
        {
            Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_CARD_LOCKED,FLOWWRNMSG_TIMER_2SEC);
            return NVTEVT_CONSUME;
        }
        if (!GxStrg_GetDeviceCtrl(0, CARD_INSERT)) // card insert
        {
            Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD,FLOWWRNMSG_TIMER_2SEC);
            return NVTEVT_CONSUME;
        }
    }
    switch(gMovData.State)
    {
    case MOV_ST_VIEW:
    case MOV_ST_VIEW|MOV_ST_ZOOM:
        gbTrigUartTransmitFile=TRUE;
        if(gbTransmitSensorSelect==0)
        {
            gbTransmitSecondSensor=FALSE;
        }
        else
        {
            gbTransmitSecondSensor=TRUE;
            /* modify begin by ZMD, 2016-09-22, ╘н╥Є: ╘╢│╠┼─╒╒║є┬╖╧╘╩╛▓╗╢╘*/
            #if (_MODEL_DSC_ == _MODEL_PWU01_)
            if(UI_GetData(FL_DUAL_CAM_MENU)!=DUALCAM_BOTH)
            {
                gbDualDispalyFlag=TRUE;
                Ux_PostEvent(NVTEVT_EXE_DUALCAM, 1, DUALCAM_BOTH);
            }
            #endif
        }
        if((g_PreviewStable_Record==FALSE)||(gbMovieRecordingFlag==TRUE))
        {
            g_PreviewStable_Record=TRUE;
            gbMovieRecordingFlag=FALSE;
            SetMovieRecordingFlag=TRUE;
        }
        Ux_SendEvent(0, NVTEVT_SYSTEM_MODE, 1, PRIMARY_MODE_PHOTO);
        break;
    case MOV_ST_REC:
    case MOV_ST_REC|MOV_ST_ZOOM:
        if(gbGsensorTrig==TRUE)
        {
            gbGsensorTrig=FALSE;
        }
        gMovData.State= MOV_ST_VIEW;
        FlowMovie_StopRec();
        gbMovieRecordingFlag=TRUE;
        gbTrigUartTransmitFile=TRUE;
        if(gbTransmitSensorSelect==0)
        {
            gbTransmitSecondSensor=FALSE;
        }
        else
        {
            gbTransmitSecondSensor=TRUE;
            /* modify begin by ZMD, 2016-09-22, ╘н╥Є: ╘╢│╠┼─╒╒║є┬╖╧╘╩╛▓╗╢╘*/
            #if (_MODEL_DSC_ == _MODEL_PWU01_)
            if(UI_GetData(FL_DUAL_CAM_MENU)!=DUALCAM_BOTH)
            {
                gbDualDispalyFlag=TRUE;
                Ux_PostEvent(NVTEVT_EXE_DUALCAM, 1, DUALCAM_BOTH);
            }
            #endif
        }
        if (g_uiDateTimerID != NULL_TIMER)
        {
            GxTimer_StopTimer(&g_uiDateTimerID);
        }
        Ux_SendEvent(0, NVTEVT_SYSTEM_MODE, 1, PRIMARY_MODE_PHOTO);
        break;
    }
    return NVTEVT_CONSUME;
}


INT32 UIFlowWndMovie_GsensorTrig(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    if(gbGsensorTrig==TRUE)
        return NVTEVT_CONSUME;
    if(UI_GetData(FL_GSENSOR) != GSENSOR_OFF)
    {
        switch(gMovData.State)
        {
        case MOV_ST_REC:
        case MOV_ST_REC|MOV_ST_ZOOM:
            if(UI_GetData(FL_GSENSOR) != GSENSOR_OFF)
            {
                MovRec_SetCrash();
                gbGsensorTrig=TRUE;
                FlowMovie_IconDrawLockFile();
               
                debug_msg(("====> MovRec_SetCrash() !\r\n"));
            }
            break;
        }
    }
    return NVTEVT_CONSUME;
}

//pgl 20160720 add for sync_old_codebase  beg

INT32 UIFlowWndMovie_StartMovieRecord(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32 FrameID;
    UINT8   uiResqData[16]= {0};
    BOOL   CheckStorageErr = FALSE;
    if(paramNum>0)
        FrameID=paramArray[0];
    Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);
    if (UI_GetData(FL_MOVIE_SIZE) == MOVIE_SIZE_FRONT_2880x2160P24)
    {
        if (KeyScan_GetPlugDev() == PLUG_HDMI)
            return NVTEVT_CONSUME;
    }
    if(System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_SAFE)
    {
        if (UI_GetData(FL_CardStatus) == CARD_REMOVED)
        {
            Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD,FLOWWRNMSG_TIMER_2SEC);
            return NVTEVT_CONSUME;
        }
    }
    else if (System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_NORMAL)
    {
        if (GxStrg_GetDeviceCtrl(0, CARD_READONLY)) // card lock
        {
            gMovData.State=MOV_ST_WARNING_MENU;
            Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_CARD_LOCKED,FLOWWRNMSG_TIMER_2SEC);
            return NVTEVT_CONSUME;
        }
        if (!GxStrg_GetDeviceCtrl(0, CARD_INSERT)) // card insert
        {
            Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD,FLOWWRNMSG_TIMER_2SEC);
            return NVTEVT_CONSUME;
        }
    }
    switch (gMovData.State)
    {
    case MOV_ST_VIEW:
        if (MovRec_GetStatus() == MOVREC_STATUS_OPENED_NOT_RECORD)
        {
            gMovData.State= MOV_ST_REC;
            if(System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_SAFE)
            {
                //#NT#2015/08/05#KS Hung -begin
                //#NT#Even if the DCIM folder is not exist, FileSys_ScanDir stiil return FST_STA_OK.
                //#NT#When the card is full and it sets cyclic record, it still can't record.
                //#NT#MediaRec library will automatically delete the files of Car DV folder.
                //#NT#if the files can't be deleted, it will have LOOPREC_FULL event in the callback.
                if (SysGetFlag(FL_MOVIE_CYCLIC_REC) == MOVIE_CYCLICREC_OFF)
                {
                    CheckStorageErr = FlowMovie_IsStorageErr(TRUE);
                }
                else
                {
                    CheckStorageErr = FlowMovie_IsStorageErr(FALSE);
                }
                //#NT#2015/08/05#KS Hung -end

                if (CheckStorageErr == TRUE)
                {
                    gMovData.State= MOV_ST_WARNING_MENU;
                    gMovData.SysTimeCount = 0;
                    return NVTEVT_CONSUME;
                }
            }
            if(GetBatteryLevel() == BATTERY_EXHAUSTED)
            {
                debug_err(("UIFlowWndMovie_OnExeRecord: Battery is too low!\r\n"));
                return NVTEVT_CONSUME;
            }
            if (FlowMovie_GetSelfTimerID() != NULL_TIMER)
            {
                FlowMovie_StopRecSelfTimer();
                return NVTEVT_CONSUME;
            }
            FlowMovie_StartRec();
            FlowMovie_UpdateIcons(TRUE);
            debug_msg("UIFlowWndMovie_StartMovieRecord..\r\n");
            uiResqData[0]=0;
            MTKComposeCMDRspFrame(FrameID, CMD_MOVIE_START,&uiResqData, 1);
        }
        break;
    }
    return NVTEVT_CONSUME;
}


INT32 UIFlowWndMovie_StopMovieRecord(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32 FrameID=0;
    UINT8   uiResqData[16]= {0};

    if(paramNum>0)
        FrameID=paramArray[0];


    // flush key event first
    Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);

    // if HDMI is inserted, DRAM size is not enough for movie recording
    if (UI_GetData(FL_MOVIE_SIZE) == MOVIE_SIZE_FRONT_2880x2160P24)
    {
        if (KeyScan_GetPlugDev() == PLUG_HDMI)
            return NVTEVT_CONSUME;
    }

    if(System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_SAFE)
    {
        if (UI_GetData(FL_CardStatus) == CARD_REMOVED)
        {
            Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD,FLOWWRNMSG_TIMER_2SEC);
            return NVTEVT_CONSUME;
        }

    }
    else if (System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_NORMAL)
    {
        if (GxStrg_GetDeviceCtrl(0, CARD_READONLY)) // card lock
        {
            gMovData.State=MOV_ST_WARNING_MENU;
            Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_CARD_LOCKED,FLOWWRNMSG_TIMER_2SEC);
            return NVTEVT_CONSUME;
        }

        if (!GxStrg_GetDeviceCtrl(0, CARD_INSERT)) // card insert
        {
            Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD,FLOWWRNMSG_TIMER_2SEC);
            return NVTEVT_CONSUME;
        }
    }
    switch (gMovData.State)
    {
    case MOV_ST_REC:
    case MOV_ST_REC|MOV_ST_ZOOM:
        UxCtrl_SetShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl, FALSE);
        #if _ADAS_FUNC_
        g_uiAdasAlertSecCnt = 0;
        #endif

        // Isiah, implement YUV merge mode of recording func.
        //if (FlowMovie_GetRecCurrTime() >= 1)
        {
            // Mask key during movie stop flow.
            Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);
            Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);
            FlowMovie_StopRec();
            if(gbGsensorTrig==TRUE)
            {
                gbGsensorTrig=FALSE;
            }
            // update ui window icon
            FlowMovie_UpdateIcons(TRUE);

            uiResqData[0]=0;
            MTKComposeCMDRspFrame(FrameID, CMD_MOVIE_STOP,(UINT8 *)&uiResqData, 1);
        }
        break;

    }
    return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_FormatCard(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32 FrameID=0;
    UINT8   uiResqData[16]= {0};

    if(paramNum>0)
        FrameID=paramArray[0];

    switch (gMovData.State)
    {
    case MOV_ST_VIEW:
    case MOV_ST_VIEW|MOV_ST_ZOOM:
        if(UI_GetData(FL_CardStatus) == CARD_REMOVED)
        {
            CHKPNT;
            Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,FLOWWRNMSG_ISSUE_NO_CARD,FLOWWRNMSG_TIMER_2SEC);
            return NVTEVT_CONSUME;
        }
        else
        {
            if(UIStorageCheck(STORAGE_CHECK_LOCKED, NULL) == TRUE)
            {
                CHKPNT;
                Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,FLOWWRNMSG_ISSUE_CARD_LOCKED,FLOWWRNMSG_TIMER_2SEC);
                return NVTEVT_CONSUME;
            }
        }
        gMovData.State=MOV_ST_WARNING_MENU;
        Ux_OpenWindow(&UIFlowWndWaitMomentCtrl,1,UIFlowWndWaitMoment_StatusTXT_Msg_STRID_PLEASE_WAIT);
        BKG_PostEvent(NVTEVT_BKW_FORMAT_CARD);
        uiResqData[0]=0;
        MTKComposeCMDRspFrame(FrameID, CMD_MOVIE_FORMAT,(UINT8 *)&uiResqData, 1);
        break;
    case MOV_ST_REC:
    case MOV_ST_REC|MOV_ST_ZOOM:
        debug_msg("#stop movie record before format card..\r\n");
        if(gbGsensorTrig==TRUE)
        {
            gbGsensorTrig=FALSE;
        }
        gMovData.State= MOV_ST_VIEW;
        FlowMovie_StopRec();
        Delay_DelayMs(300);
        gbMovieRecFormatFlag=TRUE;
        gMovData.State=MOV_ST_WARNING_MENU;
        Ux_OpenWindow(&UIFlowWndWaitMomentCtrl,1,UIFlowWndWaitMoment_StatusTXT_Msg_STRID_PLEASE_WAIT);
        BKG_PostEvent(NVTEVT_BKW_FORMAT_CARD);
        uiResqData[0]=0;
        MTKComposeCMDRspFrame(FrameID, CMD_MOVIE_FORMAT,(UINT8 *)&uiResqData, 1);
        break;
    }
    return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_Capture(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32 FrameID=0;
    UINT8   uiResqData[16]= {0};
    UINT32 uiJpegWidth=0, uiJpegHeight=0, uiDAR=0, uiMovieSize=0;

    if(paramNum>0)
        FrameID=paramArray[0];

    if (UI_GetData(FL_MOVIE_SIZE) == MOVIE_SIZE_FRONT_2880x2160P24)
    {
        if (KeyScan_GetPlugDev() == PLUG_HDMI)
        {
            uiResqData[0]=1;
            MTKComposeCMDRspFrame(FrameID, CMD_CAPTURE,(UINT8 *)&uiResqData, 1);
            return NVTEVT_CONSUME;
        }
    }

    if(System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_SAFE)
    {
        if (UI_GetData(FL_CardStatus) == CARD_REMOVED)
        {
            Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD,FLOWWRNMSG_TIMER_2SEC);
            uiResqData[0]=1;
            MTKComposeCMDRspFrame(FrameID, CMD_CAPTURE,(UINT8 *)&uiResqData, 1);
            if(ParkingCaptrueFlag==TRUE)
            {
                System_PowerOff(SYS_POWEROFF_NORMAL);
            }
            return NVTEVT_CONSUME;
        }
    }
    else if (System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_NORMAL)
    {
        if (GxStrg_GetDeviceCtrl(0, CARD_READONLY)) // card lock
        {
            Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_CARD_LOCKED,FLOWWRNMSG_TIMER_2SEC);
            uiResqData[0]=1;
            MTKComposeCMDRspFrame(FrameID, CMD_CAPTURE,(UINT8 *)&uiResqData, 1);
            if(ParkingCaptrueFlag==TRUE)
            {
                System_PowerOff(SYS_POWEROFF_NORMAL);
            }
            return NVTEVT_CONSUME;
        }

        if (!GxStrg_GetDeviceCtrl(0, CARD_INSERT)) // card insert
        {
            Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD,FLOWWRNMSG_TIMER_2SEC);
            uiResqData[0]=1;
            MTKComposeCMDRspFrame(FrameID, CMD_CAPTURE,(UINT8 *)&uiResqData, 1);
            if(ParkingCaptrueFlag==TRUE)
            {
                System_PowerOff(SYS_POWEROFF_NORMAL);
            }
            return NVTEVT_CONSUME;
        }
    }
    switch(gMovData.State)
    {
    case MOV_ST_VIEW:
    case MOV_ST_VIEW|MOV_ST_ZOOM:
        gbTrigUartTransmitFile=FALSE;
        Ux_SendEvent(0, NVTEVT_SYSTEM_MODE, 1, PRIMARY_MODE_PHOTO);
        break;
    case MOV_ST_REC:
    case MOV_ST_REC|MOV_ST_ZOOM:
        #if 0

        gMovData.State= MOV_ST_VIEW;
        FlowMovie_StopRec();
        //gbMovieRecordingFlag=TRUE;
        Delay_DelayMs(300);
        gbTrigUartTransmitFile=FALSE;
        Ux_SendEvent(0, NVTEVT_SYSTEM_MODE, 1, PRIMARY_MODE_PHOTO);
        #else
        gbTrigUartTransmitFile=FALSE;
        uiMovieSize = UI_GetData(FL_MOVIE_SIZE);
        uiJpegWidth = GetMovieSizeWidth(uiMovieSize);
        uiJpegHeight = GetMovieSizeHeight(uiMovieSize);
        uiDAR = GetMovieDispAspectRatio(uiMovieSize);
        if (uiDAR == VIDENC_DAR_16_9)
        {
            uiJpegWidth = (uiJpegHeight * 16) / 9;
        }
        Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_REC_RAWENC, 2, uiJpegWidth, uiJpegHeight);
        #endif
        break;
    }

    uiResqData[0]=0;
    MTKComposeCMDRspFrame(FrameID, CMD_CAPTURE,(UINT8 *)&uiResqData, 1);
    return NVTEVT_CONSUME;
}


INT32 UIFlowWndMovie_TransmitFinish(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    debug_msg("UIFlowWndMovie_TransmitFinish: %d..\r\n",SxTimer_GetFuncActive(SX_TIMER_DET_USB_ID));
    if(SxTimer_GetFuncActive(SX_TIMER_DET_USB_ID)== FALSE)
        SxTimer_SetFuncActive(SX_TIMER_DET_USB_ID, TRUE);

    return NVTEVT_CONSUME;
}

//#NT#2016/07/20#Brain Yen -begin
//#NT#Add for DDD alarm
INT32 UIFlowWndMovie_OnDDDShowAlarm(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if (_DDD_FUNC_ == ENABLE)
    UINT32 AlarmType;
    AlarmType = paramArray[0];
    #if 0//Add for test
    GxSound_SetOutDevConfigIdx(0);
    #endif
    switch (AlarmType)
    {
        case DDD_ALARM_PERCLOS:
            UISound_Play(DEMOSOUND_SOUND_DDDWARNING3_TONE);
            break;

        case DDD_ALARM_YAWN:
            UISound_Play(DEMOSOUND_SOUND_DDDWARNING3_TONE);
            break;

        case DDD_ALARM_DIS:
            UISound_Play(DEMOSOUND_SOUND_DDDWARNING2_TONE);
            break;

        case DDD_ALARM_NODE:
            UISound_Play(DEMOSOUND_SOUND_DDDWARNING3_TONE);
            break;

        case DDD_ALARM_EYE:
            UISound_Play(DEMOSOUND_SOUND_DDDWARNING1_TONE);
            break;

        default:
            break;
    }
#endif
    return NVTEVT_CONSUME;
}
//#NT#2016/07/20#Brain Yen -end

//#NT#2016/03/25#KCHong -end
//#NT#2016/06/23#Niven Cho -begin
//#NT#Enter calibration by cgi event or command event
INT32 UIFlowWndMovie_OnKeyCalibration(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    #if (CALIBRATION_FUNC == ENABLE)
    {
        Ux_SendEvent(0, NVTEVT_SYSTEM_MODE, 1, PRIMARY_MODE_MAIN);
        EngineerMode_Open();
    }
    #endif
    return NVTEVT_CONSUME;

}
//#NT#2016/06/23#Niven Cho -end

//---------------------UIFlowWndMovie_Panel_Normal_DisplayCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie_Panel_Normal_Display)
CTRL_LIST_ITEM(UIFlowWndMovie_Static_camera)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_CyclicRec)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_MotionDet)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_battery)
CTRL_LIST_ITEM(UIFlowWndMovie_YMD_Static)
CTRL_LIST_ITEM(UIFlowWndMovie_HMS_Static)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_REC)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_Storage)
CTRL_LIST_ITEM(UIFlowWndMovie_Static_time)
CTRL_LIST_ITEM(UIFlowWndMovie_Static_maxtime)
CTRL_LIST_ITEM(UIFlowWndMovie_Static_resolution)
CTRL_LIST_ITEM(UIFlowWndMovie_Zoom_Static)
CTRL_LIST_ITEM(UIFlowWndMovie_StatusICN_EV)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_HDR)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_WIFI)
CTRL_LIST_ITEM(UIFlowWndMovie_StaticIcon_PIMC)
#if defined(YQCONFIG_ANDROID_SYSTEM_SUPPORT)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_WDR)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_G_Sensor)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_File_Lock)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_Urgent_protect_Auto)
CTRL_LIST_ITEM(UIFlowWndMovie_StatusICN_Audio)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_GPS)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_TimeLapse)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_ADAS_Status)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_FCW_Status)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_LDWS_Status)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_Urgent_protect_Manual)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_ParkingMode)
//CTRL_LIST_ITEM(UIFlowWndMovie_Status_Main_PB)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_Touch_REC)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_Touch_RERTURN)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_Touch_SnapeShot)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_Touch_Change_DisplayMode)
CTRL_LIST_ITEM(UIFlowWndMovie_Static_Speed)
CTRL_LIST_ITEM(UIFlowWndMovie_Static_Distance)
#endif
CTRL_LIST_ITEM(UIFlowWndMovie_ADAS_DrawingLine)
///#NT#2016/06/08#Lincy Lin -begin
//#NT#Implement generic OSD and video drawing mechanism for ALG function
CTRL_LIST_ITEM(UIFlowWndMovie_ALG_Draw)
//#NT#2016/06/08#Lincy Lin -end
CTRL_LIST_END

//----------------------UIFlowWndMovie_Panel_Normal_DisplayCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Panel_Normal_Display)
EVENT_END

//----------------------UIFlowWndMovie_Static_cameraCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Static_camera)
EVENT_END

//----------------------UIFlowWndMovie_Status_CyclicRecCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_CyclicRec)
EVENT_END

//----------------------UIFlowWndMovie_Status_MotionDetCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_MotionDet)
EVENT_END

//----------------------UIFlowWndMovie_Status_batteryCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_battery)
EVENT_END

//----------------------UIFlowWndMovie_YMD_StaticCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_YMD_Static)
EVENT_END

//----------------------UIFlowWndMovie_HMS_StaticCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_HMS_Static)
EVENT_END

//----------------------UIFlowWndMovie_Status_RECCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_REC)
EVENT_END

//----------------------UIFlowWndMovie_Status_StorageCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_Storage)
EVENT_END

//----------------------UIFlowWndMovie_Static_timeCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Static_time)
EVENT_END

//----------------------UIFlowWndMovie_Static_maxtimeCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Static_maxtime)
EVENT_END

//----------------------UIFlowWndMovie_Static_resolutionCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Static_resolution)
EVENT_END

//----------------------UIFlowWndMovie_Zoom_StaticCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Zoom_Static)
EVENT_END

//----------------------UIFlowWndMovie_StatusICN_EVCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_StatusICN_EV)
EVENT_END

//----------------------UIFlowWndMovie_Status_HDRCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_HDR)
EVENT_END

//----------------------UIFlowWndMovie_Status_WIFICtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_WIFI)
EVENT_END

//----------------------UIFlowWndMovie_StaticIcon_PIMCCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_StaticIcon_PIMC)
EVENT_END

#if defined(YQCONFIG_ANDROID_SYSTEM_SUPPORT)
EVENT_BEGIN(UIFlowWndMovie_Status_WDR)
EVENT_END
EVENT_BEGIN(UIFlowWndMovie_Status_G_Sensor)
EVENT_END
EVENT_BEGIN(UIFlowWndMovie_Status_File_Lock)
EVENT_END
EVENT_BEGIN(UIFlowWndMovie_Status_Urgent_protect_Auto)
EVENT_END

//----------------------UIFlowWndMovie_Status_Urgent_protect_ManualCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_Urgent_protect_Manual)
EVENT_END

//----------------------UIFlowWndMovie_StatusICN_AudioCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_StatusICN_Audio)
EVENT_END

//----------------------UIFlowWndMovie_Status_GPSCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_GPS)
EVENT_END

//----------------------UIFlowWndMovie_Status_TimeLapseCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_TimeLapse)
EVENT_END

//----------------------UIFlowWndMovie_Status_ADAS_StatusCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_ADAS_Status)
EVENT_END

//----------------------UIFlowWndMovie_Status_FCW_StatusCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_FCW_Status)
EVENT_END

//----------------------UIFlowWndMovie_Status_LDWS_StatusCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_LDWS_Status)
EVENT_END

//----------------------UIFlowWndMovie_Status_ParkingModeCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_ParkingMode)
EVENT_END

//----------------------UIFlowWndMovie_Status_Main_PBCtrl Event---------------------------
//EVENT_BEGIN(UIFlowWndMovie_Status_Main_PB)
//EVENT_END

//----------------------UIFlowWndMovie_Status_Touch_RECCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_Touch_REC)
EVENT_END

//----------------------UIFlowWndMovie_Status_Touch_RERTURNCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_Touch_RERTURN)
EVENT_END

//----------------------UIFlowWndMovie_Status_Touch_SnapeShotCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_Touch_SnapeShot)
EVENT_END

//----------------------UIFlowWndMovie_Status_Touch_Change_DisplayModeCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_Touch_Change_DisplayMode)
EVENT_END
#if defined(YQCONFIG_TOUCH_SETUP_OPTION)
//----------------------UIFlowWndMovie_Status_Touch_SETUPCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_Touch_SETUP)
EVENT_END
#endif
#if defined(YQCONFIG_TOUCH_AUDIOSWITCH_OPTION)
//----------------------UIFlowWndMovie_Status_Touch_AudioSwitchCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_Touch_AudioSwitch)
EVENT_END
#endif
EVENT_BEGIN(UIFlowWndMovie_Static_Reverse)
EVENT_END
#endif
//#NT#2016/06/08#Lincy Lin -begin
//#NT#Implement generic OSD and video drawing mechanism for ALG function

//---------------------UIFlowWndMovie_ADAS_DrawingLineCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie_ADAS_DrawingLine)
CTRL_LIST_END

//----------------------UIFlowWndMovie_ADAS_DrawingLineCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_ADAS_DrawingLine)
EVENT_END

//---------------------UIFlowWndMovie_ADAS_Alert_DisplayCtrl Control List---------------------------

#if MOVIE_FD_FUNC_
INT32 UIFlowWndMovie_FD_Draw(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    extern    URECT     gMovieFdDispCord;
    //#NT#2016/10/18#Jeah Yen -begin
    //#NT#fix compile error
    #if (TV_FUNC == ENABLE)
    extern    DX_HANDLE gDevTVObj;
    #endif
    //#NT#2016/10/18#Jeah Yen -end
    #if VDO_USE_ROTATE_BUFFER
    extern    DX_HANDLE gDevLCDObj;
    UINT32            isLCD =0;
    #endif
    UINT32            uiRectColor = _OSD_INDEX_WHITE;
    UINT32            i,Fdnumber;
    static FD_FACE    FdInfo[MAX_FDNUM];
    PDISP_OBJ         pDispObj = NULL;
    DISPLAYER_PARAM   DispLyr = {0} ;
    URECT             DispCord;
    UINT32            BorderW = 3, BorderH = 3;
    ISIZE             dev1size;
    USIZE             dev1Ratio;
    UINT32            ExpandRatio=1;

    //#NT#2016/08/18#Lincy Lin -begin
    //#NT#Fix enter sleep mode will have divide by zero exception because of GxVideo_GetDevice return NULL.
    if(((DX_HANDLE)GxVideo_GetDevice(DOUT1)) == NULL)
        return NVTEVT_CONSUME;
    //#NT#2016/08/18#Lincy Lin -end
    idec_setFDExpEn(0, 1);
    DispCord = gMovieFdDispCord;
    #if (TV_FUNC == ENABLE)
    if(((DX_HANDLE)GxVideo_GetDevice(DOUT1)) == gDevTVObj)
    {
        ExpandRatio = 2;
    }
    #endif
    #if VDO_USE_ROTATE_BUFFER
    if(((DX_HANDLE)GxVideo_GetDevice(DOUT1)) == gDevLCDObj)
    {
        isLCD = 1;
    }
    #endif
    dev1size = GxVideo_GetDeviceSize(DOUT1);
    dev1Ratio = GxVideo_GetDeviceAspect(DOUT1);
    BorderW = dev1size.w/dev1Ratio.w*dev1Ratio.h*BorderH*ExpandRatio*10/dev1size.h;
    BorderW = ALIGN_ROUND(BorderW,10)/10;
    DBG_IND("[fd] dev1size w=%d,h=%d dev1Ratio w=%d,h=%d, BorderW=%d\r\n",dev1size.w,dev1size.h,dev1Ratio.w,dev1Ratio.h,BorderW);
    DBG_IND("[fd] DispCord x=%d,y=%d, w=%d,h=%d \r\n",DispCord.x,DispCord.y,DispCord.w,DispCord.h);
    Fdnumber = FD_GetRsltFace (FdInfo,&DispCord);


    if (Fdnumber > MAX_FDNUM)
    {
        Fdnumber = MAX_FDNUM;
    }
    if (0)//SysGetFlag(FL_FD)==FD_OFF)
    {
        uiRectColor = _OSD_INDEX_TRANSPART;
    }
    else
    {
        uiRectColor = _OSD_INDEX_WHITE;
    }

    DBG_IND("[fd]FDFrame_OnDraw color=%d, \r\n",uiRectColor);

    pDispObj = disp_getDisplayObject(DISP_1);
    //#NT#2016/03/02#Lincy Lin -begin
    //#NT#Support object tracking function
    for (i=0;i<MAX_FDNUM;i++)
    //#NT#2016/03/02#Lincy Lin -end
    {
        DispLyr.SEL.SET_FDEN.FD_NUM = DISPFD_NUM0<<i;
        DispLyr.SEL.SET_FDEN.bEn = FALSE;
        pDispObj->dispLyrCtrl(DISPLAYER_FD, DISPLAYER_OP_SET_FDEN, &DispLyr);
    }
    if(uiRectColor != _OSD_INDEX_TRANSPART)
    {
        for (i=0;i<Fdnumber;i++)
        {
            // draw FD frame
            DBG_IND("[fd] %d ( %3d , %3d ; %3d , %3d )\r\n",
                        i,
                        FdInfo[i].x,
                        FdInfo[i].y,
                        FdInfo[i].w,
                        FdInfo[i].h);

            pDispObj = disp_getDisplayObject(DISP_1);
            DispLyr.SEL.SET_FDSIZE.FD_NUM = DISPFD_NUM0<<i;
            #if VDO_USE_ROTATE_BUFFER
            if(isLCD)
            {
                UINT32              in_hsz, in_vsz;
                in_hsz = dev1size.h;
                in_vsz = dev1size.w;
                DispLyr.SEL.SET_FDSIZE.uiFDX     = FdInfo[i].y;
                DispLyr.SEL.SET_FDSIZE.uiFDY     = in_vsz - FdInfo[i].w - FdInfo[i].x;
                DispLyr.SEL.SET_FDSIZE.uiFDW     = FdInfo[i].h;
                DispLyr.SEL.SET_FDSIZE.uiFDH     = FdInfo[i].w;
                DispLyr.SEL.SET_FDSIZE.uiFDBORD_W = BorderH;
                DispLyr.SEL.SET_FDSIZE.uiFDBORD_H = BorderW;


                DBG_IND("[fd] rotate %d( %3d , %3d ; %3d , %3d )\r\n",
                        i,
                        DispLyr.SEL.SET_FDSIZE.uiFDX,
                        DispLyr.SEL.SET_FDSIZE.uiFDY,
                        DispLyr.SEL.SET_FDSIZE.uiFDW,
                        DispLyr.SEL.SET_FDSIZE.uiFDH);
            }
            else
            #endif
            {
                DispLyr.SEL.SET_FDSIZE.uiFDX = FdInfo[i].x*ExpandRatio;
                DispLyr.SEL.SET_FDSIZE.uiFDY = FdInfo[i].y;
                DispLyr.SEL.SET_FDSIZE.uiFDW = FdInfo[i].w*ExpandRatio;
                DispLyr.SEL.SET_FDSIZE.uiFDH = FdInfo[i].h;
                DispLyr.SEL.SET_FDSIZE.uiFDBORD_W = BorderW;
                DispLyr.SEL.SET_FDSIZE.uiFDBORD_H = BorderH;

            }
            DBG_IND("[fd] BorderW %d BorderH %d \r\n",DispLyr.SEL.SET_FDSIZE.uiFDBORD_W,DispLyr.SEL.SET_FDSIZE.uiFDBORD_H);
            pDispObj->dispLyrCtrl(DISPLAYER_FD, DISPLAYER_OP_SET_FDSIZE, &DispLyr);

            DispLyr.SEL.SET_FDCOLOR.FD_NUM = DISPFD_NUM0<<i;
            DispLyr.SEL.SET_FDCOLOR.uiFDCRY = 0xFF;
            DispLyr.SEL.SET_FDCOLOR.uiFDCRCb = 0x80;
            DispLyr.SEL.SET_FDCOLOR.uiFDCRCr = 0x80;
            pDispObj->dispLyrCtrl(DISPLAYER_FD, DISPLAYER_OP_SET_FDCOLOR, &DispLyr);

            DispLyr.SEL.SET_FDEN.FD_NUM = DISPFD_NUM0<<i;
            DispLyr.SEL.SET_FDEN.bEn = TRUE;
            pDispObj->dispLyrCtrl(DISPLAYER_FD, DISPLAYER_OP_SET_FDEN, &DispLyr);
        }
    }
    pDispObj->load(TRUE);
    return NVTEVT_CONSUME;
}
#endif


#if MOVIE_OT_FUNC
INT32 UIFlowWndMovie_OT_Draw(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    extern    URECT   gMovieFdDispCord;
    //#NT#2016/10/18#Jeah Yen -begin
    //#NT#fix compile error
    #if (TV_FUNC == ENABLE)
    extern    DX_HANDLE gDevTVObj;
    #endif
    //#NT#2016/10/18#Jeah Yen -end
    #if VDO_USE_ROTATE_BUFFER
    extern    DX_HANDLE gDevLCDObj;
    UINT32            isLCD =0;
    #endif
    UINT32            uiRectColor = _OSD_INDEX_WHITE;
    UINT32            OTnumber = 0;
    URECT             OTInfo;
    PDISP_OBJ         pDispObj = NULL;
    DISPLAYER_PARAM   DispLyr = {0} ;
    URECT             DispCord = {0,0, 640,360};
    UINT32            BorderW = 3, BorderH = 3;
    ISIZE             dev1size;
    USIZE             dev1Ratio;
    UINT32            ExpandRatio=1;
    UINT32            dispFdID;

    //#NT#2016/08/18#Lincy Lin -begin
    //#NT#Fix enter sleep mode will have divide by zero exception because of GxVideo_GetDevice return NULL.
    if(((DX_HANDLE)GxVideo_GetDevice(DOUT1)) == NULL)
        return NVTEVT_CONSUME;
    //#NT#2016/08/18#Lincy Lin -end

    idec_setFDExpEn(0, 1);
    DispCord = gMovieFdDispCord;
    #if (TV_FUNC == ENABLE)
    if(((DX_HANDLE)GxVideo_GetDevice(DOUT1)) == gDevTVObj)
    {
        ExpandRatio = 2;
    }
    #endif
    #if VDO_USE_ROTATE_BUFFER
    if(((DX_HANDLE)GxVideo_GetDevice(DOUT1)) == gDevLCDObj)
    {
        isLCD = 1;
    }
    #endif
    dev1size = GxVideo_GetDeviceSize(DOUT1);
    dev1Ratio = GxVideo_GetDeviceAspect(DOUT1);
    BorderW = dev1size.w/dev1Ratio.w*dev1Ratio.h*BorderH*ExpandRatio*10/dev1size.h;
    BorderW = ALIGN_ROUND(BorderW,10)/10;
    DBG_IND("[fd] dev1size w=%d,h=%d dev1Ratio w=%d,h=%d, BorderW=%d\r\n",dev1size.w,dev1size.h,dev1Ratio.w,dev1Ratio.h,BorderW);
    DBG_IND("[fd] DispCord x=%d,y=%d, w=%d,h=%d \r\n",DispCord.x,DispCord.y,DispCord.w,DispCord.h);
    // Only when movie recording will have Object tracking
    if(MovRec_IsRecording())
    {
        OTnumber = OT_GetTarget(&OTInfo, &DispCord);
    }
    uiRectColor = _OSD_INDEX_WHITE;
    DBG_IND("[fd]FDFrame_OnDraw color=%d, \r\n",uiRectColor);
    pDispObj = disp_getDisplayObject(DISP_1);

    // use last DispFD
    dispFdID = DISPFD_NUM0;
    DispLyr.SEL.SET_FDEN.FD_NUM = dispFdID;
    DispLyr.SEL.SET_FDEN.bEn = FALSE;
    pDispObj->dispLyrCtrl(DISPLAYER_FD, DISPLAYER_OP_SET_FDEN, &DispLyr);

    if(OTnumber)
    {
        // draw FD frame
        DBG_IND("[ot]( %3d , %3d ; %3d , %3d )\r\n",
                    OTInfo.x,
                    OTInfo.y,
                    OTInfo.w,
                    OTInfo.h);

        #if VDO_USE_ROTATE_BUFFER
        if(isLCD)
        {
            UINT32              in_hsz, in_vsz;
            in_hsz = dev1size.h;
            in_vsz = dev1size.w;
            DispLyr.SEL.SET_FDSIZE.uiFDX     = OTInfo.y;
            DispLyr.SEL.SET_FDSIZE.uiFDY     = in_vsz - OTInfo.w - OTInfo.x;
            DispLyr.SEL.SET_FDSIZE.uiFDW     = OTInfo.h;
            DispLyr.SEL.SET_FDSIZE.uiFDH     = OTInfo.w;
            DispLyr.SEL.SET_FDSIZE.uiFDBORD_W = BorderH;
            DispLyr.SEL.SET_FDSIZE.uiFDBORD_H = BorderW;


            DBG_IND("[ot] rotate ( %3d , %3d ; %3d , %3d )\r\n",
                    DispLyr.SEL.SET_FDSIZE.uiFDX,
                    DispLyr.SEL.SET_FDSIZE.uiFDY,
                    DispLyr.SEL.SET_FDSIZE.uiFDW,
                    DispLyr.SEL.SET_FDSIZE.uiFDH);
        }
        else
        #endif
        {
            DispLyr.SEL.SET_FDSIZE.uiFDX = OTInfo.x*ExpandRatio;
            DispLyr.SEL.SET_FDSIZE.uiFDY = OTInfo.y;
            DispLyr.SEL.SET_FDSIZE.uiFDW = OTInfo.w*ExpandRatio;
            DispLyr.SEL.SET_FDSIZE.uiFDH = OTInfo.h;
            DispLyr.SEL.SET_FDSIZE.uiFDBORD_W = BorderW;
            DispLyr.SEL.SET_FDSIZE.uiFDBORD_H = BorderH;

        }
        DBG_IND("[ot] BorderW %d BorderH %d \r\n",DispLyr.SEL.SET_FDSIZE.uiFDBORD_W,DispLyr.SEL.SET_FDSIZE.uiFDBORD_H);
        pDispObj->dispLyrCtrl(DISPLAYER_FD, DISPLAYER_OP_SET_FDSIZE, &DispLyr);

        DispLyr.SEL.SET_FDCOLOR.FD_NUM = dispFdID;
        DispLyr.SEL.SET_FDCOLOR.uiFDCRY = 0xFF;
        DispLyr.SEL.SET_FDCOLOR.uiFDCRCb = 0x80;
        DispLyr.SEL.SET_FDCOLOR.uiFDCRCr = 0x80;
        pDispObj->dispLyrCtrl(DISPLAYER_FD, DISPLAYER_OP_SET_FDCOLOR, &DispLyr);

        DispLyr.SEL.SET_FDEN.FD_NUM = dispFdID;
        DispLyr.SEL.SET_FDEN.bEn = TRUE;
        pDispObj->dispLyrCtrl(DISPLAYER_FD, DISPLAYER_OP_SET_FDEN, &DispLyr);
    }
    pDispObj->load(FALSE);
    return NVTEVT_CONSUME;
}
#endif

//#NT#2016/04/22#Nestor Yang -begin
//#NT# Support Driver Drowsiness Detection(DDD)
#if MOVIE_DDD_FUNC
//#NT#2016/11/10#Brain Yen -begin
//#NT#Add for PTL668 UI bug
_INLINE TCHAR_VALUE String_GetChar(const TCHAR* pszDest, INT16 n)
{
        return (TCHAR_VALUE)(pszDest[n]);
}
UINT16 UIFlowWndMovie_GetStringLength(TCHAR* pszDest)
{
    TCHAR_VALUE c;
    ISIZE szFont;
    INT16 iCount=0;
    IVALUE id;
    UINT16 Length=0;
    c = String_GetChar(pszDest, iCount);
    while(c)
    {
        id =c;
        GxGfx_GetFontCharSize(id, &szFont);
        Length+=szFont.w;
        //DBG_ERR("szFont=%d\r\n",szFont);
        iCount++;
        c = String_GetChar(pszDest, iCount);
    }
    //DBG_ERR("Length=%d\r\n",Length);
    return Length;
}
//#NT#2016/11/10#Brain Yen -end
extern    URECT   gMovieOsdDispCord;
static void UIFlowWndMovie_DDD_Draw(UINT32 *paramArray)
{
    URECT       DispCord = {0,0,OSD_W,OSD_H};
    UIScreen    ScreenObj = *paramArray;
    INT32       i, Dddnumber;
    DDD_SHAPE   TotalShape;
    DDD_SHAPE   PartShape;
    INT32		iPoseRay[8];
    INT32       ret;
    URECT       trackRect;
    DDD_WARN    dowsyState;

    DispCord = gMovieOsdDispCord;
    //DBG_DUMP("x=%d, y=%d, w=%d, h=%d\r\n", DispCord.x, DispCord.y, DispCord.w, DispCord.h);
    Dddnumber = DDD_GetRsltLandmark(&TotalShape, &DispCord);
        //DBG_ERR("Dddnumber=%d\r\n",Dddnumber);

    if(Dddnumber > 0)
    {
        GxGfx_SetShapeStroke(LINEBRUSH_SQUARE|LINEWEIGHT(1), FILLSTYLE_FILL);
        GxGfx_SetShapeColor(CLRID_IDX_GREEN, CLRID_IDX_GREEN, NULL);
        for (i = 0; i < Dddnumber; i++)
        {
            GxGfx_Point(((DC**)ScreenObj)[GxGfx_OSD], TotalShape.pt[i*2], TotalShape.pt[i*2+1]);
        }

        ret = DDD_GetRsltPoseRay(iPoseRay, 100, &DispCord);
        if(ret)
        {
            GxGfx_SetShapeColor(CLRID_IDX_GREEN, CLRID_IDX_GREEN, NULL);
            GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD],  iPoseRay[0],  iPoseRay[1], iPoseRay[2], iPoseRay[3]);
            GxGfx_SetShapeColor(CLRID_IDX_BLUE, CLRID_IDX_BLUE, NULL);
            GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD],  iPoseRay[0],  iPoseRay[1], iPoseRay[4], iPoseRay[5]);
            GxGfx_SetShapeColor(CLRID_IDX_RED, CLRID_IDX_RED, NULL);
            GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD],  iPoseRay[0],  iPoseRay[1], iPoseRay[6], iPoseRay[7]);
        }

        if(DDD_GetFacialState(DDD_FACIAL_TYPE_LEFT_EYE) == DDD_EYE_CLOSED)
        {
            PartShape = DDD_GetFacialPts(&TotalShape, DDD_FACIAL_TYPE_LEFT_EYE);
            GxGfx_SetShapeColor(CLRID_IDX_BLUE, CLRID_IDX_BLUE, NULL);
            for(i = 0; i < PartShape.nL; i++)
                GxGfx_Point(((DC**)ScreenObj)[GxGfx_OSD], PartShape.pt[i*2], PartShape.pt[i*2+1]);
        }
        else if(DDD_GetFacialState(DDD_FACIAL_TYPE_LEFT_EYE) == DDD_EYE_UNCERTAIN)
        {
            PartShape = DDD_GetFacialPts(&TotalShape, DDD_FACIAL_TYPE_LEFT_EYE);
            GxGfx_SetShapeColor(CLRID_IDX_ORANGE, CLRID_IDX_GREEN, NULL);
            for(i = 0; i < PartShape.nL; i++)
                GxGfx_Point(((DC**)ScreenObj)[GxGfx_OSD], PartShape.pt[i*2], PartShape.pt[i*2+1]);
        }

        if(DDD_GetFacialState(DDD_FACIAL_TYPE_RIGHT_EYE) == DDD_EYE_CLOSED)
        {
            PartShape = DDD_GetFacialPts(&TotalShape, DDD_FACIAL_TYPE_RIGHT_EYE);
            GxGfx_SetShapeColor(CLRID_IDX_BLUE, CLRID_IDX_BLUE, NULL);
            for(i = 0; i < PartShape.nL; i++)
                GxGfx_Point(((DC**)ScreenObj)[GxGfx_OSD], PartShape.pt[i*2], PartShape.pt[i*2+1]);
        }
        else if(DDD_GetFacialState(DDD_FACIAL_TYPE_RIGHT_EYE) == DDD_EYE_UNCERTAIN)
        {
            PartShape = DDD_GetFacialPts(&TotalShape, DDD_FACIAL_TYPE_RIGHT_EYE);
            GxGfx_SetShapeColor(CLRID_IDX_ORANGE, CLRID_IDX_GREEN, NULL);
            for(i = 0; i < PartShape.nL; i++)
                GxGfx_Point(((DC**)ScreenObj)[GxGfx_OSD], PartShape.pt[i*2], PartShape.pt[i*2+1]);
        }

        if(DDD_GetFacialState(DDD_FACIAL_TYPE_MOUTH) == DDD_MOUTH_YAWN)
        {
            PartShape = DDD_GetFacialPts(&TotalShape, DDD_FACIAL_TYPE_MOUTH);
            GxGfx_SetShapeColor(CLRID_IDX_SKYBLUE, NULL, NULL);
            for(i = 0; i < PartShape.nL; i++)
                GxGfx_Point(((DC**)ScreenObj)[GxGfx_OSD], PartShape.pt[i*2], PartShape.pt[i*2+1]);
        }

        ret = DDD_GetFacialState(DDD_FACIAL_TYPE_HEAD);
        if(ret != DDD_HEAD_STATE_NORMAL)
        {
            PartShape = DDD_GetFacialPts(&TotalShape, DDD_FACIAL_TYPE_HEAD);
            if(ret == DDD_HEAD_STATE_NODING)
                GxGfx_SetShapeColor(CLRID_IDX_ORANGE, CLRID_IDX_GREEN, NULL);
            else// distribute
                GxGfx_SetShapeColor(CLRID_IDX_RED, CLRID_IDX_RED, NULL);
            for(i = 0; i < PartShape.nL; i++)
                GxGfx_Point(((DC**)ScreenObj)[GxGfx_OSD], PartShape.pt[i*2], PartShape.pt[i*2+1]);
        }

        ret = DDD_GetRsltTrackingRect(&trackRect, &DispCord);
        if(ret)
        {
            GxGfx_SetShapeColor(CLRID_IDX_PURPLE, CLRID_IDX_PURPLE, NULL);
            GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD],  trackRect.x,  trackRect.y,
                       trackRect.x + trackRect.w, trackRect.y);
            GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD],  trackRect.x,  trackRect.y,
                       trackRect.x, trackRect.y + trackRect.h);
            GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD],  trackRect.x + trackRect.w,  trackRect.y,
                       trackRect.x + trackRect.w, trackRect.y + trackRect.h);
            GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD],  trackRect.x,  trackRect.y + trackRect.h,
                       trackRect.x + trackRect.w, trackRect.y + trackRect.h);
        }
    }


    #if (MOVIE_DDD_FUNC && MOVIE_DDD_DRAW_VIDEO)
    g_DDD_DowsyState = 0;//Add by ML Cui@2016-4-25
    #endif
    #if 1
	//#NT#2016/11/21#ML Cui -begin
	//#NT#Add for PTL user defined warning
    dowsyState = DDD_GetUserWarning();
    if(dowsyState)
    {
        UINT32 dowsybinary = 0;

        GxGfx_SetTextStroke((const FONT*)gDemoKit_Font, TEXTFONTSTYLE_DEFAULT, TEXTFONTSIZE_DEFAULT);
        GxGfx_SetTextLayout(TEXTLAYOUT_DEFAULT, TEXTALIGN_DEFAULT, TEXTLINEHEIGHT_DEFAULT, TEXTLETTERSPACE_DEFAULT, TEXTINDENTSPACE_DEFAULT);

        if(dowsyState & (DDD_UWRN_NOFACE | DDD_UWRN_NOFACE_DURA))
        {
            GxGfx_SetTextColor(CLRID_IDX_CYAN, NULL, NULL);

            sprintf(strTmp, "NOFACE Warning %d%d",
                    (dowsyState & DDD_UWRN_NOFACE_DURA) > 0,
                    (dowsyState & DDD_UWRN_NOFACE) > 0);

            GxGfx_TextPrint(((DC**)ScreenObj)[GxGfx_OSD], 5, 40,
                                strTmp);

            dowsybinary += (dowsyState & (DDD_UWRN_NOFACE |
                                         DDD_UWRN_NOFACE_DURA))
                    / DDD_UWRN_NOFACE;

        }
        else
        {
            dowsybinary = 0;

            if(dowsyState & (DDD_UWRN_BLINK ))
            {
                GxGfx_SetTextColor(CLRID_IDX_RED, NULL, NULL);

                sprintf(strTmp,"Blink Warning %d",
                        (dowsyState & DDD_UWRN_BLINK) > 0);
                GxGfx_TextPrint(((DC**)ScreenObj)[GxGfx_OSD], ((TOOL_LAYOUT_W-UIFlowWndMovie_GetStringLength(strTmp))/2), 60,
                                strTmp);
                dowsybinary += 0x10 * ((dowsyState & (DDD_UWRN_BLINK))
                        / DDD_UWRN_BLINK);
            }

            if(dowsyState & (DDD_UWRN_YAWN | DDD_UWRN_YAWN_DURA))
            {
                GxGfx_SetTextColor(CLRID_IDX_ORANGE, CLRID_IDX_GREEN, NULL);
                //GxGfx_TextPrint(((DC**)ScreenObj)[GxGfx_OSD], 5, 80,
                //                "Remind~ driver yawn too frequently");
                sprintf(strTmp, "Yawn Warning %d%d",
                        (dowsyState & DDD_UWRN_YAWN_DURA) > 0,
                        (dowsyState & DDD_UWRN_YAWN) > 0);
                GxGfx_TextPrint(((DC**)ScreenObj)[GxGfx_OSD], ((TOOL_LAYOUT_W-UIFlowWndMovie_GetStringLength(strTmp))/2), 80,
                                strTmp);

                dowsybinary += 0x100 * ((dowsyState & (DDD_UWRN_YAWN | DDD_UWRN_YAWN_DURA))
                                      / DDD_UWRN_YAWN);
            }

            if(dowsyState & (DDD_UWRN_DIS | DDD_UWRN_DIS_DURA))
            {
                GxGfx_SetTextColor(CLRID_IDX_RED, NULL, NULL);
                //GxGfx_TextPrint(((DC**)ScreenObj)[GxGfx_OSD], 5, 100,
                //                "Serious Warning! Driver distraction!");

                sprintf(strTmp,"Distraction Warning %d%d",
                        (dowsyState & DDD_UWRN_DIS_DURA) > 0,
                        (dowsyState & DDD_UWRN_DIS) > 0);
                GxGfx_TextPrint(((DC**)ScreenObj)[GxGfx_OSD], ((TOOL_LAYOUT_W-UIFlowWndMovie_GetStringLength(strTmp))/2), 120,
                                strTmp);
                dowsybinary += 0x1000 * ((dowsyState & (DDD_UWRN_DIS | DDD_UWRN_DIS_DURA))
                                       / DDD_UWRN_DIS);
            }

            if(dowsyState & (DDD_UWRN_NOD | DDD_UWRN_NOD_DURA))
            {
                GxGfx_SetTextColor(CLRID_IDX_ORANGE, NULL, NULL);
                //GxGfx_TextPrint(((DC**)ScreenObj)[GxGfx_OSD], 5, 120,
                //                "Annotation! Driver is a little tired!");
                sprintf(strTmp,"Nod Warning %d%d",
                        (dowsyState & DDD_UWRN_NOD_DURA) > 0,
                        (dowsyState & DDD_UWRN_NOD) > 0);
                GxGfx_TextPrint(((DC**)ScreenObj)[GxGfx_OSD], ((TOOL_LAYOUT_W-UIFlowWndMovie_GetStringLength(strTmp))/2), 140,
                                strTmp);

                dowsybinary += 0x10000 * ((dowsyState & (DDD_UWRN_NOD | DDD_UWRN_NOD_DURA))
                                         / DDD_UWRN_NOD);
            }
            //#NT#2016/06/07#ML Cui -Begin
            //#NT# Add Continues eye closed warning
            if(dowsyState & (DDD_UWRN_EYE | DDD_UWRN_EYE_DURA))
            {
                //GxGfx_SetTextColor(CLRID_IDX_ORANGE, NULL, NULL);
                GxGfx_SetTextColor(CLRID_IDX_RED, NULL, NULL);
                //GxGfx_TextPrint(((DC**)ScreenObj)[GxGfx_OSD], 5, 140,
                //                "Warning! Driver's eye closed too long!");
                sprintf(strTmp,"Eye Warning %d%d",
                        (dowsyState & DDD_UWRN_EYE_DURA) > 0,
                        (dowsyState & DDD_UWRN_EYE) > 0);
                GxGfx_TextPrint(((DC**)ScreenObj)[GxGfx_OSD], ((TOOL_LAYOUT_W-UIFlowWndMovie_GetStringLength(strTmp))/2), 180,
                                strTmp);
                dowsybinary += 0x100000 * ((dowsyState & (DDD_UWRN_EYE | DDD_UWRN_EYE_DURA))
                                           / DDD_UWRN_EYE) ;
            }
        }
       //#NT#2016/06/07#ML Cui -End
        //debug_msg("dowsybinary = %06x\r\n", dowsybinary);
        #if (MOVIE_DDD_FUNC && MOVIE_DDD_DRAW_VIDEO)
        g_DDD_DowsyState = dowsybinary;
        #endif
    }
	//#NT#2016/11/21#ML Cui -end
    #else
    dowsyState = DDD_GetWarning();
    if(dowsyState)
    {
        UINT32 dowsybinary = 0;

        GxGfx_SetTextStroke((const FONT*)gDemoKit_Font, TEXTFONTSTYLE_DEFAULT, TEXTFONTSIZE_DEFAULT);
        GxGfx_SetTextLayout(TEXTLAYOUT_DEFAULT, TEXTALIGN_DEFAULT, TEXTLINEHEIGHT_DEFAULT, TEXTLETTERSPACE_DEFAULT, TEXTINDENTSPACE_DEFAULT);

        if(dowsyState & DDD_WARN_NONEFACE)
        {
            GxGfx_SetTextColor(CLRID_IDX_CYAN, NULL, NULL);
            GxGfx_TextPrint(((DC**)ScreenObj)[GxGfx_OSD], 5, 40,
                            "Could not find face!");
            dowsybinary = 1;
        }
        else
        {
            dowsybinary = 0;

            if(dowsyState & DDD_WARN_PERCLOS)
            {
                GxGfx_SetTextColor(CLRID_IDX_RED, NULL, NULL);
                //GxGfx_TextPrint(((DC**)ScreenObj)[GxGfx_OSD], 5, 60,
                //                "Warning! Driver drossy!!");
                sprintf(strTmp,"Warning! Driver drossy!!");
                GxGfx_TextPrint(((DC**)ScreenObj)[GxGfx_OSD], ((TOOL_LAYOUT_W-UIFlowWndMovie_GetStringLength(strTmp))/2), 60,
                                strTmp);
                dowsybinary += 0x10;
            }

            if(dowsyState & DDD_WARN_YAWN)
            {
                GxGfx_SetTextColor(CLRID_IDX_ORANGE, CLRID_IDX_GREEN, NULL);
                //GxGfx_TextPrint(((DC**)ScreenObj)[GxGfx_OSD], 5, 80,
                //                "Remind~ driver yawn too frequently");
                sprintf(strTmp,"Remind~ driver yawn too frequently");
                GxGfx_TextPrint(((DC**)ScreenObj)[GxGfx_OSD], ((TOOL_LAYOUT_W-UIFlowWndMovie_GetStringLength(strTmp))/2), 80,
                                strTmp);

                dowsybinary += 0x100;
            }

            if(dowsyState & DDD_WARN_DIS)
            {
                GxGfx_SetTextColor(CLRID_IDX_RED, NULL, NULL);
                //GxGfx_TextPrint(((DC**)ScreenObj)[GxGfx_OSD], 5, 100,
                //                "Serious Warning! Driver distraction!");
                sprintf(strTmp,"Serious Warning!");
                GxGfx_TextPrint(((DC**)ScreenObj)[GxGfx_OSD], ((TOOL_LAYOUT_W-UIFlowWndMovie_GetStringLength(strTmp))/2), 100,
                                strTmp);
                sprintf(strTmp,"Driver distraction!");
                GxGfx_TextPrint(((DC**)ScreenObj)[GxGfx_OSD], ((TOOL_LAYOUT_W-UIFlowWndMovie_GetStringLength(strTmp))/2), 120,
                                strTmp);
                dowsybinary += 0x1000;
            }

            if(dowsyState & DDD_WARN_NODE)
            {
                GxGfx_SetTextColor(CLRID_IDX_ORANGE, NULL, NULL);
                //GxGfx_TextPrint(((DC**)ScreenObj)[GxGfx_OSD], 5, 120,
                //                "Annotation! Driver is a little tired!");
                sprintf(strTmp,"Annotation! Driver is a little tired!");
                GxGfx_TextPrint(((DC**)ScreenObj)[GxGfx_OSD], ((TOOL_LAYOUT_W-UIFlowWndMovie_GetStringLength(strTmp))/2), 140,
                                strTmp);

                dowsybinary += 0x10000;
            }
			//#NT#2016/06/07#ML Cui -Begin
			//#NT# Add Continues eye closed warning
            if(dowsyState & DDD_WARN_EYE)
            {
                //GxGfx_SetTextColor(CLRID_IDX_ORANGE, NULL, NULL);
                GxGfx_SetTextColor(CLRID_IDX_RED, NULL, NULL);
                //GxGfx_TextPrint(((DC**)ScreenObj)[GxGfx_OSD], 5, 140,
                //                "Warning! Driver's eye closed too long!");
                sprintf(strTmp,"Warning!");
                GxGfx_TextPrint(((DC**)ScreenObj)[GxGfx_OSD], ((TOOL_LAYOUT_W-UIFlowWndMovie_GetStringLength(strTmp))/2), 160,
                                strTmp);
                sprintf(strTmp,"Driver's eye closed too long!");
                GxGfx_TextPrint(((DC**)ScreenObj)[GxGfx_OSD], ((TOOL_LAYOUT_W-UIFlowWndMovie_GetStringLength(strTmp))/2), 180,
                                strTmp);
                dowsybinary += 0x100000;
            }
            //#NT#2016/06/07#ML Cui -End
        }

        #if (MOVIE_DDD_FUNC && MOVIE_DDD_DRAW_VIDEO)
        g_DDD_DowsyState = dowsybinary;
        #endif
    }
#endif

}

#endif

#if MOVIE_TD_FUNC
INT32 UIFlowWndMovie_TD_Draw(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    extern    URECT   gMovieOsdDispCord;
    URECT       DispCord = {0,0,OSD_W,OSD_H};
    static URECT     TdInfo[TD_MAX_BLK_NUM];
    UIScreen    ScreenObj = *paramArray;
    INT32       i, Tdnumber = 0;
    URECT *rect;

    DispCord = gMovieOsdDispCord;
    //DBG_DUMP("x=%d, y=%d, w=%d, h=%d\r\n", DispCord.x, DispCord.y, DispCord.w, DispCord.h);
    Tdnumber = TDGetTarget(TdInfo, &DispCord);

#if 1
    GxGfx_SetShapeStroke(LINEBRUSH_SQUARE|LINEWEIGHT(1), FILLSTYLE_FILL);
    if(TDGetAlarm())
    {
        GxGfx_SetShapeColor(CLRID_IDX_RED, CLRID_IDX_RED, NULL);
    }
    else
    {
        GxGfx_SetShapeColor(CLRID_IDX_WHITE, CLRID_IDX_WHITE, NULL);
    }
    for(i = 0; i < Tdnumber; i++)
    {
        rect = TdInfo + i;

        GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD],  rect->x,  rect->y,
            rect->x + rect->w, rect->y);
        GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD],  rect->x,  rect->y,
            rect->x, rect->y + rect->h);
        GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD],  rect->x + rect->w,  rect->y,
            rect->x + rect->w, rect->y + rect->h);
        GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD],  rect->x,  rect->y + rect->h,
            rect->x + rect->w, rect->y + rect->h);
    }
#endif
    return NVTEVT_CONSUME;
}
#endif
//#NT#2016/05/23#David Tsai -end

//#NT#2016/10/14#Yuzhe Bian -begin
//#NT# Support trip-wire detection function
#if MOVIE_TWD_FUNC
INT32 UIFlowWndMovie_TWD_Draw(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    extern URECT     gMovieOsdDispCord;
    URECT            DispCord = {0,0,OSD_W,OSD_H};
    static URECT     TWDInfo[twd_max_objects_number];
    static BOOL      TWDState[twd_max_objects_number];
    static UPOINT    TWDLINEInfo[twd_max_nodes_number];
    UIScreen         ScreenObj = *paramArray;
    INT32            i, Tdnumber_rect = 0, Tdnumber_point = 0;
    URECT            *rect;
    UPOINT           TWDStart, TWDEnd;

    DispCord = gMovieOsdDispCord;
    //DBG_DUMP("x=%d, y=%d, w=%d, h=%d\r\n", DispCord.x, DispCord.y, DispCord.w, DispCord.h);
    Tdnumber_point = twd_getpointsintripwire(TWDLINEInfo, &DispCord);
    Tdnumber_rect = twd_gettargetswithwarn(TWDInfo, TWDState, &DispCord);

#if 1
    GxGfx_SetShapeStroke(LINEBRUSH_SQUARE|LINEWEIGHT(1), FILLSTYLE_FILL);
    GxGfx_SetShapeColor(CLRID_IDX_RED, CLRID_IDX_RED, NULL);

    for (i = 0; i < Tdnumber_point - 1; i++)
    {
        TWDStart.x = TWDLINEInfo[i].x;
        TWDStart.y = TWDLINEInfo[i].y;
        TWDEnd.x = TWDLINEInfo[i+1].x;
        TWDEnd.y = TWDLINEInfo[i+1].y;
        GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD],  TWDStart.x,  TWDStart.y,
            TWDEnd.x, TWDEnd.y);
    }
    for(i = 0; i < Tdnumber_rect; i++)
    {
        rect = TWDInfo + i;

        if(TWDState[i] == FALSE)
            GxGfx_SetShapeColor(CLRID_IDX_WHITE, CLRID_IDX_WHITE, NULL);
        else
            GxGfx_SetShapeColor(CLRID_IDX_RED, CLRID_IDX_RED, NULL);

        GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD],  rect->x,  rect->y,
            rect->x + rect->w, rect->y);
        GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD],  rect->x,  rect->y,
            rect->x, rect->y + rect->h);
        GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD],  rect->x + rect->w,  rect->y,
            rect->x + rect->w, rect->y + rect->h);
        GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD],  rect->x,  rect->y + rect->h,
            rect->x + rect->w, rect->y + rect->h);
    }
#endif
    return NVTEVT_CONSUME;
}
#endif
//#NT#2016/10/14#Yuzhe Bian -end

//#NT#2016/10/14#Yuzhe Bian -begin
//#NT# Support trip-wire detection function
#if MOVIE_TZD_FUNC
INT32 UIFlowWndMovie_TZD_Draw(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    extern URECT     gMovieOsdDispCord;
    URECT            DispCord = {0,0,OSD_W,OSD_H};
    static URECT     TZDInfo[tzd_max_objects_number];
    static BOOL      TZDState[tzd_max_objects_number];
    static UPOINT    TZDLINEInfo[tzd_max_nodes_number];
    UIScreen         ScreenObj = *paramArray;
    INT32            i, Tdnumber_rect = 0, Tdnumber_point = 0;
    URECT            *rect;
    UPOINT           TZDStart, TZDEnd;

    DispCord = gMovieOsdDispCord;
    //DBG_ERR("x=%d, y=%d, w=%d, h=%d\r\n", DispCord.x, DispCord.y, DispCord.w, DispCord.h);
    Tdnumber_point = tzd_getpointsintripzone(TZDLINEInfo, &DispCord);
    Tdnumber_rect = tzd_gettargetswithwarn(TZDInfo, TZDState, &DispCord);

#if 1
    GxGfx_SetShapeStroke(LINEBRUSH_SQUARE|LINEWEIGHT(1), FILLSTYLE_FILL);
    GxGfx_SetShapeColor(CLRID_IDX_RED, CLRID_IDX_RED, NULL);

    for (i = 0; i < Tdnumber_point - 1; i++)
    {
        TZDStart.x = TZDLINEInfo[i].x;
        TZDStart.y = TZDLINEInfo[i].y;
        TZDEnd.x = TZDLINEInfo[i+1].x;
        TZDEnd.y = TZDLINEInfo[i+1].y;
        GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD],  TZDStart.x,  TZDStart.y,
            TZDEnd.x, TZDEnd.y);
    }
    for(i = 0; i < Tdnumber_rect; i++)
    {
        rect = TZDInfo + i;

        if(TZDState[i] == FALSE)
            GxGfx_SetShapeColor(CLRID_IDX_WHITE, CLRID_IDX_WHITE, NULL);
        else
            GxGfx_SetShapeColor(CLRID_IDX_RED, CLRID_IDX_RED, NULL);

        GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD],  rect->x,  rect->y,
            rect->x + rect->w, rect->y);
        GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD],  rect->x,  rect->y,
            rect->x, rect->y + rect->h);
        GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD],  rect->x + rect->w,  rect->y,
            rect->x + rect->w, rect->y + rect->h);
        GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD],  rect->x,  rect->y + rect->h,
            rect->x + rect->w, rect->y + rect->h);
    }
#endif
    return NVTEVT_CONSUME;
}
#endif
//#NT#2016/10/14#Yuzhe Bian -end

#if((_ADAS_FUNC_ == ENABLE)&&(_ADAS_DSP_FUNC_ ==ENABLE))

INT32 UIFlowWndMovie_ADASDsp_Draw(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UIScreen ScreenObj = *paramArray;
    //ADAS_APPS_RESULT_INFO *pAdasRlt = MovieExe_GetAdasRltOSD();

	ADAS_DSP_RESULT_INFO *pAdasDspRlt = MovieExe_GetAdasDspRltOSD();
	
    CHAR InfoStr[20] = {0};
    BVALUE LineColor = 0;

    if ((UI_GetData(FL_MOVIE_LDWS) == MOVIE_LDWS_OFF) && (UI_GetData(FL_MOVIE_FCW) == MOVIE_FCW_OFF))
    {
        return NVTEVT_CONSUME;
    }

    // Draw FC distance and speed info
	//#NT#2016/09/29#KCHong -begin
	//#NT#The GPS related variables should not depend on ADAS.
//	#if (GPS_FUNCTION == ENABLE)
//    sprintf(InfoStr ,"%dm/%dkm",ADAS_GetAppsStatus()?ADAS_GetFcwsCurrentDist():0, (UINT32)g_CurSpeed);
//	#else
//    sprintf(InfoStr ,"%dm/0km",ADAS_GetAppsStatus()?ADAS_GetFcwsCurrentDist():0);
//	#endif
	//#NT#2016/09/29#KCHong -end

//	#if ((GPS_FUNCTION == ENABLE)&&(_DRAW_LDFCINFO_ON_OSD_ == ENABLE))
//    sprintf(InfoStr ,"%dm/%dkm",ADASDsp_GetFcwsCurrentDist(),(UINT32)g_CurSpeed);
//	#else
//	sprintf(InfoStr ,"%dkm",(UINT32)g_CurSpeed);
//	#endif

//    GxGfx_SetTextStroke((const FONT*)&gDemoKit_Font, FONTEFFECT_HIGHLIGHT2, SCALE_1X);
//    GxGfx_Text(((DC**)ScreenObj)[GxGfx_OSD], 180, 150, (CHAR *)InfoStr);

    if (ADASDsp_GetAppsStatus() == FALSE)
    {
        return NVTEVT_CONSUME;
    }

    GxGfx_SetShapeStroke(LINEBRUSH_SQUARE|LINEWEIGHT(1), FILLSTYLE_FILL);
    GxGfx_SetShapeColor(CLRID_IDX_GREEN, CLRID_IDX_GREEN, NULL);;

    // SnG ROI
//    #if ((_SNG_FUNC_ == ENABLE) && (_DRAW_SNG_ROI_ == ENABLE))
//    if (1)
//    #else
//    if (ADAS_IsAdasDebug())
//    #endif
//    {
//        ADAS_SNG_ROI_INFO *pSnGROI = MovieExe_GetSnGROIOSD();
//        
//        if (pSnGROI)
//        {
//            //debug_msg("\r\n----ADAS_draw----\r\n");
//            LineColor = (pAdasRlt->SnGInfo.uiMvValid == STOPNGO_MV_VALID)?CLRID_IDX_GREEN:CLRID_IDX_RED;
//            GxGfx_SetShapeColor(LineColor, LineColor, NULL);
//            GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD], pSnGROI->uiP1x, pSnGROI->uiP1y, pSnGROI->uiP2x, pSnGROI->uiP2y);
//            GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD], pSnGROI->uiP2x, pSnGROI->uiP2y, pSnGROI->uiP3x, pSnGROI->uiP3y);
//            GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD], pSnGROI->uiP3x, pSnGROI->uiP3y, pSnGROI->uiP4x, pSnGROI->uiP4y);
//            GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD], pSnGROI->uiP4x, pSnGROI->uiP4y, pSnGROI->uiP1x, pSnGROI->uiP1y);
//        }
//    }

        // draw lane detection result
    if (pAdasDspRlt->LdwsDspRsltInfo.Failure == LDWS_FAILURE_FALSE)
    {
        #if (_DRAW_LDFCINFO_ON_OSD_ == ENABLE)
        if (1)
        #else
        if (ADAS_IsAdasDebug())
        #endif
        {
			
			//debug_msg("\r\n----DSP_draw_LdwsDspRsltInfo----\r\n");
            //debug_msg("\r\n----DSP_LdwsDspRsltInfo.DepartureDirVoice = %d----\r\n",pAdasDspRlt->LdwsDspRsltInfo.DepartureDirVoice);
            
            LineColor = (pAdasDspRlt->LdwsDspRsltInfo.DepartureDir == LDWS_DEPARTURE_LEFT)?CLRID_IDX_RED:CLRID_IDX_GREEN;
            GxGfx_SetShapeColor(LineColor, LineColor, NULL);
            GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD], pAdasDspRlt->LdwsDspRsltInfo.uiLx1, pAdasDspRlt->LdwsDspRsltInfo.uiLy1, pAdasDspRlt->LdwsDspRsltInfo.uiLx2, pAdasDspRlt->LdwsDspRsltInfo.uiLy2); // left lane

            LineColor = (pAdasDspRlt->LdwsDspRsltInfo.DepartureDir == LDWS_DEPARTURE_RIGHT)?CLRID_IDX_RED:CLRID_IDX_GREEN;
            GxGfx_SetShapeColor(LineColor, LineColor, NULL);
            GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD], pAdasDspRlt->LdwsDspRsltInfo.uiRx1, pAdasDspRlt->LdwsDspRsltInfo.uiRy1, pAdasDspRlt->LdwsDspRsltInfo.uiRx2, pAdasDspRlt->LdwsDspRsltInfo.uiRy2); // right lane

        }
	}
        // draw car location
	if (pAdasDspRlt->FcwsDspRsltInfo.Failure == FCWS_FAILURE_FALSE)
	{
        #if (_DRAW_LDFCINFO_ON_OSD_ == ENABLE)
        if (1)
        #else
        if (ADAS_IsAdasDebug())
        #endif
        {
            //debug_msg("\r\n----DSP_draw_FcwsDspRsltInfo----\r\n");
            //debug_msg("\r\n----DSP_FcwsDspRsltInfo.FCSoundWarning = %d----\r\n",pAdasDspRlt->FcwsDspRsltInfo.FCSoundWarning);
			LineColor = CLRID_IDX_WHITE;
            
                //LineColor = (pAdasRlt->FcwsRsltInfo.FCWarning)?CLRID_IDX_RED:CLRID_IDX_GREEN;
                //GxGfx_SetShapeColor(LineColor, LineColor, NULL);
                //GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD], pAdasRlt->FcwsRsltInfo.uiLx, pAdasRlt->FcwsRsltInfo.uiLy, pAdasRlt->FcwsRsltInfo.uiRx, pAdasRlt->FcwsRsltInfo.uiRy);
		    GxGfx_SetShapeColor(LineColor, LineColor, NULL);
			UINT32 ltPtx = pAdasDspRlt->FcwsDspRsltInfo.uiTargetRect.x;
			UINT32 ltPty = pAdasDspRlt->FcwsDspRsltInfo.uiTargetRect.y;
			UINT32 rbPtx = pAdasDspRlt->FcwsDspRsltInfo.uiTargetRect.x+pAdasDspRlt->FcwsDspRsltInfo.uiTargetRect.w;
			UINT32 rbPty = pAdasDspRlt->FcwsDspRsltInfo.uiTargetRect.y+pAdasDspRlt->FcwsDspRsltInfo.uiTargetRect.h;
			
			GxGfx_Line( ((DC**)ScreenObj)[GxGfx_OSD], ltPtx, ltPty, ltPtx, rbPty );
			GxGfx_Line( ((DC**)ScreenObj)[GxGfx_OSD], ltPtx, ltPty, rbPtx, ltPty );
			GxGfx_Line( ((DC**)ScreenObj)[GxGfx_OSD], rbPtx, ltPty, rbPtx, rbPty );
			GxGfx_Line( ((DC**)ScreenObj)[GxGfx_OSD], ltPtx, rbPty, rbPtx, rbPty );
            
        }
    }

    #if (_AUTOVP_FUNC_ == ENABLE)
	
   	if((pAdasDspRlt->LdwsDspRsltInfo.Failure == LDWS_FAILURE_TRUE)&&(pAdasDspRlt->FcwsDspRsltInfo.Failure == FCWS_FAILURE_TRUE))
	{
		LineColor=CLRID_IDX_RED;
    GxGfx_SetShapeColor(LineColor, LineColor, NULL);
    GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD], pAdasDspRlt->LdwsDspRsltInfo.AutoVpParms.AutoVPRslt.x - 10, pAdasDspRlt->LdwsDspRsltInfo.AutoVpParms.AutoVPRslt.y, pAdasDspRlt->LdwsDspRsltInfo.AutoVpParms.AutoVPRslt.x + 10, pAdasDspRlt->LdwsDspRsltInfo.AutoVpParms.AutoVPRslt.y);
    GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD], pAdasDspRlt->LdwsDspRsltInfo.AutoVpParms.AutoVPRslt.x, pAdasDspRlt->LdwsDspRsltInfo.AutoVpParms.AutoVPRslt.y - 10, pAdasDspRlt->LdwsDspRsltInfo.AutoVpParms.AutoVPRslt.x, pAdasDspRlt->LdwsDspRsltInfo.AutoVpParms.AutoVPRslt.y + 10);
   	}
    #else
    GxGfx_SetShapeColor(CLRID_IDX_RED, CLRID_IDX_RED, NULL);
    GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD], OSD_W/2 - 10, OSD_H/2, OSD_W/2 + 10, OSD_H/2);
    GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD], OSD_W/2, OSD_H/2 - 10, OSD_W/2, OSD_H/2 + 10);
    #endif
/*
    // Show SnG & stop detection debug info
    if (ADAS_IsAdasDebug())
    {
        UINT32 y;

        #if (_SNG_FUNC_ == ENABLE)
        // SnG debug info
        if (pAdasRlt->SnGInfo.uiMovingStatus == STOPNGO_MOVING)
        {
            GxGfx_SetShapeColor(CLRID_IDX_GREEN, CLRID_IDX_GREEN, NULL); // green
        }
        if (pAdasRlt->SnGInfo.uiStopStatus == STOPNGO_STOP)
        {
            GxGfx_SetShapeColor(CLRID_IDX_YELLOW, CLRID_IDX_YELLOW, NULL); // yellow
        }
        if (pAdasRlt->SnGInfo.uiGoStatus == STOPNGO_GO)
        {
            GxGfx_SetShapeColor(CLRID_IDX_RED, CLRID_IDX_RED, NULL); // red
        }
        for(y = 0;y < 7; y++)
        {
            GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD], OSD_W*8/10, OSD_H*5/8 + y, OSD_W*8/10+20, OSD_H*5/8 + y);
        }
        #endif

        // Stop detection debug info
        if (ADAS_GetStopDectRslt() == STOPDECT_STOP_TRUE)
        {
            GxGfx_SetShapeColor(CLRID_IDX_RED, CLRID_IDX_RED, NULL); // red
            for(y = 0;y < 7; y++)
            {
                GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD], OSD_W*9/10, OSD_H*5/8 + y, OSD_W*9/10+20, OSD_H*5/8 + y);
            }
        }
    }
	*/
    return NVTEVT_CONSUME;
}
#endif

//#NT#2016/07/06#CC Chao -begin
#if MOVIE_TSR_FUNC_
INT32 UIFlowWndMovie_TSR_OSD_Draw(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    extern URECT gMovieOsdDispCord;
    UIScreen ScreenObj = *paramArray;
    URECT DispCord;
    TRAFFIC_SIGN TsrInfo[TSD_FDE_MAX_TS_NUM];
    UINT32 Tsrnumber = 0, idx = 0;

    //debug_msg("^M%s: ScreenObj = 0x%x\r\n", __func__, ScreenObj);
    if (gMovData.State != MOV_ST_REC)
    { return NVTEVT_CONSUME; }

    DispCord = gMovieOsdDispCord;
    //pAdasOsdCoord = (ADAS_OSD_COORDINATE *)FlowMovie_GetAdasOsdIno();
#if 0
    Tsrnumber = TSR_GetRsltTS(TsrInfo,&DispCord);
    GxGfx_SetShapeStroke(LINEBRUSH_SQUARE|LINEWEIGHT(1), FILLSTYLE_FILL);
    GxGfx_SetShapeColor(CLRID_IDX_BLACK, CLRID_IDX_BLACK, NULL);;
    for(idx=0; idx<Tsrnumber; idx++)
    {
        UINT32 ltPtx = TsrInfo[idx].uiStx;
        UINT32 ltPty = TsrInfo[idx].uiSty;
        UINT32 rbPtx = TsrInfo[idx].uiStx + TsrInfo[idx].uiWidth;
        UINT32 rbPty = TsrInfo[idx].uiSty + TsrInfo[idx].uiHeight;

        //if( (ltPtx < (DispCord.w>>1)) || (rbPtx < (DispCord.w>>1)) )
        //{ continue; }

        GxGfx_Line( ((DC**)ScreenObj)[GxGfx_OSD], ltPtx, ltPty, ltPtx, rbPty );
        GxGfx_Line( ((DC**)ScreenObj)[GxGfx_OSD], ltPtx, ltPty, rbPtx, ltPty );
        GxGfx_Line( ((DC**)ScreenObj)[GxGfx_OSD], rbPtx, ltPty, rbPtx, rbPty );
        GxGfx_Line( ((DC**)ScreenObj)[GxGfx_OSD], ltPtx, rbPty, rbPtx, rbPty );
    }
#else
    Tsrnumber = NvtCv_TSDDSP_GetRsltTS(TsrInfo,&DispCord);
    GxGfx_SetShapeStroke(LINEBRUSH_SQUARE|LINEWEIGHT(1), FILLSTYLE_FILL);
    GxGfx_SetShapeColor(CLRID_IDX_WHITE, CLRID_IDX_WHITE, NULL);;
    for(idx=0; idx<Tsrnumber; idx++)
    {
        UINT32 ltPtx = TsrInfo[idx].uiStx;
        UINT32 ltPty = TsrInfo[idx].uiSty;
        UINT32 rbPtx = TsrInfo[idx].uiStx + TsrInfo[idx].uiWidth;
        UINT32 rbPty = TsrInfo[idx].uiSty + TsrInfo[idx].uiHeight;

        GxGfx_Line( ((DC**)ScreenObj)[GxGfx_OSD], ltPtx, ltPty, ltPtx, rbPty );
        GxGfx_Line( ((DC**)ScreenObj)[GxGfx_OSD], ltPtx, ltPty, rbPtx, ltPty );
        GxGfx_Line( ((DC**)ScreenObj)[GxGfx_OSD], rbPtx, ltPty, rbPtx, rbPty );
        GxGfx_Line( ((DC**)ScreenObj)[GxGfx_OSD], ltPtx, rbPty, rbPtx, rbPty );

        // Draw Speed Number
        CHAR InfoStr[20] = {0};
        sprintf( InfoStr ,"%d", TSR_Speed2Num(TsrInfo[idx].uiSpeedNum) );
        GxGfx_SetTextStroke((const FONT*)&gDemoKit_Font, FONTEFFECT_HIGHLIGHT2, SCALE_1X);
        GxGfx_Text(((DC**)ScreenObj)[GxGfx_OSD], ltPtx, rbPty, (CHAR *)InfoStr);
    }
#endif

    return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_TSR_FD_Draw(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    extern    URECT     gMovieFdDispCord;
    //#NT#2016/10/18#Jeah Yen -begin
    //#NT#fix compile error
    #if (TV_FUNC == ENABLE)
    extern    DX_HANDLE gDevTVObj;
    #endif
    //#NT#2016/10/18#Jeah Yen -end
    #if VDO_USE_ROTATE_BUFFER
    extern    DX_HANDLE gDevLCDObj;
    UINT32            isLCD =0;
    #endif
    UINT32            uiRectColor = _OSD_INDEX_WHITE;
    UINT32            i,Tsrnumber;
    TRAFFIC_SIGN      TsrInfo[TSD_FDE_MAX_TS_NUM];
    PDISP_OBJ         pDispObj = NULL;
    DISPLAYER_PARAM   DispLyr = {0} ;
    URECT             DispCord;
    UINT32            BorderW = 3, BorderH = 3;
    ISIZE             dev1size;
    USIZE             dev1Ratio;
    UINT32            ExpandRatio=1;

    //#NT#2016/08/18#Lincy Lin -begin
    //#NT#Fix enter sleep mode will have divide by zero exception because of GxVideo_GetDevice return NULL.
    if(((DX_HANDLE)GxVideo_GetDevice(DOUT1)) == NULL)
        return NVTEVT_CONSUME;
    //#NT#2016/08/18#Lincy Lin -end

    idec_setFDExpEn(0, 1);
    DispCord = gMovieFdDispCord;
    #if (TV_FUNC == ENABLE)
    if(((DX_HANDLE)GxVideo_GetDevice(DOUT1)) == gDevTVObj)
    {
        ExpandRatio = 2;
    }
    #endif
    #if VDO_USE_ROTATE_BUFFER
    if(((DX_HANDLE)GxVideo_GetDevice(DOUT1)) == gDevLCDObj)
    {
        isLCD = 1;
    }
    #endif
    dev1size = GxVideo_GetDeviceSize(DOUT1);
    dev1Ratio = GxVideo_GetDeviceAspect(DOUT1);
    BorderW = dev1size.w/dev1Ratio.w*dev1Ratio.h*BorderH*ExpandRatio*10/dev1size.h;
    BorderW = ALIGN_ROUND(BorderW,10)/10;
    DBG_IND("[tsr] dev1size w=%d,h=%d dev1Ratio w=%d,h=%d, BorderW=%d\r\n",dev1size.w,dev1size.h,dev1Ratio.w,dev1Ratio.h,BorderW);
    DBG_IND("[tsr] DispCord x=%d,y=%d, w=%d,h=%d \r\n",DispCord.x,DispCord.y,DispCord.w,DispCord.h);

    //Tsrnumber = TSR_GetRsltTS (TsrInfo,&DispCord);
    Tsrnumber = NvtCv_TSDDSP_GetRsltTS(TsrInfo,&DispCord);

    if (Tsrnumber > MAX_FDNUM)
    {
        Tsrnumber = MAX_FDNUM;
    }
    if (0)//SysGetFlag(FL_FD)==FD_OFF)
    {
        uiRectColor = _OSD_INDEX_TRANSPART;
    }
    else
    {
        uiRectColor = _OSD_INDEX_WHITE;
    }

    DBG_IND("[tsr]FDFrame_OnDraw color=%d, \r\n",uiRectColor);

    pDispObj = disp_getDisplayObject(DISP_1);

    for (i=0;i<MAX_FDNUM;i++)
    {
        DispLyr.SEL.SET_FDEN.FD_NUM = DISPFD_NUM0<<i;
        DispLyr.SEL.SET_FDEN.bEn = FALSE;
        pDispObj->dispLyrCtrl(DISPLAYER_FD, DISPLAYER_OP_SET_FDEN, &DispLyr);
    }
    if(uiRectColor != _OSD_INDEX_TRANSPART)
    {
        for (i=0;i<Tsrnumber;i++)
        {
            // draw FD frame
            DBG_IND("[tsr] %d ( %3d , %3d ; %3d , %3d )\r\n",
                        i,
                        TsrInfo[i].uiStx,
                        TsrInfo[i].uiSty,
                        TsrInfo[i].uiWidth,
                        TsrInfo[i].uiHeight);

            pDispObj = disp_getDisplayObject(DISP_1);
            DispLyr.SEL.SET_FDSIZE.FD_NUM = DISPFD_NUM0<<i;
            #if VDO_USE_ROTATE_BUFFER
            if(isLCD)
            {
                UINT32              in_hsz, in_vsz;
                in_hsz = dev1size.h;
                in_vsz = dev1size.w;
                DispLyr.SEL.SET_FDSIZE.uiFDX     = TsrInfo[i].uiSty;
                DispLyr.SEL.SET_FDSIZE.uiFDY     = in_vsz - TsrInfo[i].uiWidth - TsrInfo[i].uiStx;
                DispLyr.SEL.SET_FDSIZE.uiFDW     = TsrInfo[i].uiHeight;
                DispLyr.SEL.SET_FDSIZE.uiFDH     = TsrInfo[i].uiWidth;
                DispLyr.SEL.SET_FDSIZE.uiFDBORD_W = BorderH;
                DispLyr.SEL.SET_FDSIZE.uiFDBORD_H = BorderW;


                DBG_IND("[tsr] rotate %d( %3d , %3d ; %3d , %3d )\r\n",
                        i,
                        DispLyr.SEL.SET_FDSIZE.uiFDX,
                        DispLyr.SEL.SET_FDSIZE.uiFDY,
                        DispLyr.SEL.SET_FDSIZE.uiFDW,
                        DispLyr.SEL.SET_FDSIZE.uiFDH);
            }
            else
            #endif
            {
                DispLyr.SEL.SET_FDSIZE.uiFDX = TsrInfo[i].uiStx*ExpandRatio;
                DispLyr.SEL.SET_FDSIZE.uiFDY = TsrInfo[i].uiSty;
                DispLyr.SEL.SET_FDSIZE.uiFDW = TsrInfo[i].uiWidth*ExpandRatio;
                DispLyr.SEL.SET_FDSIZE.uiFDH = TsrInfo[i].uiHeight;
                DispLyr.SEL.SET_FDSIZE.uiFDBORD_W = BorderW;
                DispLyr.SEL.SET_FDSIZE.uiFDBORD_H = BorderH;

            }
            DBG_IND("[fd] BorderW %d BorderH %d \r\n",DispLyr.SEL.SET_FDSIZE.uiFDBORD_W,DispLyr.SEL.SET_FDSIZE.uiFDBORD_H);
            pDispObj->dispLyrCtrl(DISPLAYER_FD, DISPLAYER_OP_SET_FDSIZE, &DispLyr);

            DispLyr.SEL.SET_FDCOLOR.FD_NUM = DISPFD_NUM0<<i;
            DispLyr.SEL.SET_FDCOLOR.uiFDCRY = 0xFF;
            DispLyr.SEL.SET_FDCOLOR.uiFDCRCb = 0x80;
            DispLyr.SEL.SET_FDCOLOR.uiFDCRCr = 0x80;
            pDispObj->dispLyrCtrl(DISPLAYER_FD, DISPLAYER_OP_SET_FDCOLOR, &DispLyr);

            DispLyr.SEL.SET_FDEN.FD_NUM = DISPFD_NUM0<<i;
            DispLyr.SEL.SET_FDEN.bEn = TRUE;
            pDispObj->dispLyrCtrl(DISPLAYER_FD, DISPLAYER_OP_SET_FDEN, &DispLyr);
        }
    }
    pDispObj->load(TRUE);
    return NVTEVT_CONSUME;
}
#endif
//#NT#2016/07/06#CC Chao -end

#if (TIMELAPSE_LPR_FUNCTION == ENABLE)
INT32 UIFlowWndMovie_TimelapseLPR_Draw(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UIScreen ScreenObj = *paramArray;
    extern char gStrStartTitle[];
    extern char gStrStartDateTime[];
    extern char gStrNextTitle[];
    extern char gStrNextDateTime[];

    if ((MovieTLLPR_GetStatus() & TL_STATE_MASK) == TL_STATE_RECORD)
    {
        GxGfx_Text(((DC**)ScreenObj)[GxGfx_OSD], 70, 65, gStrStartTitle);
        GxGfx_Text(((DC**)ScreenObj)[GxGfx_OSD], 80, 95, gStrStartDateTime);
        GxGfx_Text(((DC**)ScreenObj)[GxGfx_OSD], 70, 125, gStrNextTitle);
        GxGfx_Text(((DC**)ScreenObj)[GxGfx_OSD], 80, 155, gStrNextDateTime);
    }
    return NVTEVT_CONSUME;
}
#endif

//#NT#2016/10/17#Bin Xiao -begin
//#NT# Support Face Tracking Grading(FTG)
#if MOVIE_FTG_FUNC
INT32 UIFlowWndMovie_FTG_Draw(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    extern  URECT      gMovieOsdDispCord;
    URECT              DispCord = {0,0,OSD_W,OSD_H};
    static  ftg_face   FTGInfo[ftg_num_max];
    UIScreen           ScreenObj = *paramArray;
    INT32              i, FTGnumber = 0;
    UINT32             id;
    URECT              rect = {0};
    char               string[10];

    DispCord = gMovieOsdDispCord;
    //DBG_DUMP("x=%d, y=%d, w=%d, h=%d\r\n", DispCord.x, DispCord.y, DispCord.w, DispCord.h);
    FTGnumber = ftg_getrsltface(FTGInfo, &DispCord);
	//DBG_ERR("FTGnumber = %d\r\n", FTGnumber);

#if 1
    GxGfx_SetShapeStroke(LINEBRUSH_SQUARE|LINEWEIGHT(1), FILLSTYLE_FILL);
    GxGfx_SetShapeColor(CLRID_IDX_WHITE, CLRID_IDX_WHITE, NULL);

    GxGfx_SetTextStroke((const FONT*)gDemoKit_Font, TEXTFONTSTYLE_DEFAULT, TEXTFONTSIZE_DEFAULT);
    GxGfx_SetTextLayout(TEXTLAYOUT_DEFAULT, TEXTALIGN_DEFAULT, TEXTLINEHEIGHT_DEFAULT, TEXTLETTERSPACE_DEFAULT, TEXTINDENTSPACE_DEFAULT);
    GxGfx_SetTextColor(CLRID_IDX_WHITE, NULL, NULL);

    for(i = 0; i < FTGnumber; i++)
    {
        rect.x = FTGInfo[i].stx;
        rect.y = FTGInfo[i].sty;
        rect.w = FTGInfo[i].width;
        rect.h = FTGInfo[i].height;
        id      = FTGInfo[i].id;

        GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD],  rect.x,  rect.y,
            rect.x + rect.w, rect.y);
        GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD],  rect.x,  rect.y,
            rect.x, rect.y + rect.h);
        GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD],  rect.x + rect.w,  rect.y,
            rect.x + rect.w, rect.y + rect.h);
        GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD],  rect.x,  rect.y + rect.h,
            rect.x + rect.w, rect.y + rect.h);

        sprintf( string, "%d", id );

        GxGfx_TextPrint(((DC**)ScreenObj)[GxGfx_OSD], (INT32)(rect.x + (rect.w>>1)), (INT32)(rect.y - 5),
                        string);
    }

#endif
    return NVTEVT_CONSUME;
}
#endif
//#NT#2016/10/17#Bin Xiao -end


//#NT#2016/03/02#Lincy Lin -begin
//#NT#Support object tracking function
//---------------------UIFlowWndMovie_ALG_DrawCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie_ALG_Draw)
CTRL_LIST_END
//----------------------UIFlowWndMovie_ALG_DrawCtrl Event---------------------------
INT32 UIFlowWndMovie_ALG_Draw_OnRedraw(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(UIFlowWndMovie_ALG_Draw)
EVENT_ITEM(NVTEVT_REDRAW,UIFlowWndMovie_ALG_Draw_OnRedraw)
EVENT_END

INT32 UIFlowWndMovie_ALG_Draw_OnRedraw(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    #if (MOVIE_FD_FUNC_== ENABLE) && (MOVIE_DDD_FUNC == DISABLE)
    UIFlowWndMovie_FD_Draw(pCtrl,paramNum,paramArray);
    #endif
    #if (MOVIE_OT_FUNC == ENABLE)
    UIFlowWndMovie_OT_Draw(pCtrl,paramNum,paramArray);
    #endif
    #if (MOVIE_DDD_FUNC == ENABLE)
    UIFlowWndMovie_DDD_Draw(paramArray);
    #endif
    #if (MOVIE_TD_FUNC == ENABLE)
    UIFlowWndMovie_TD_Draw(pCtrl,paramNum,paramArray);
    #endif
    #if (MOVIE_TWD_FUNC == ENABLE)
    UIFlowWndMovie_TWD_Draw(pCtrl,paramNum,paramArray);
    #endif
    #if (MOVIE_TZD_FUNC == ENABLE)
    UIFlowWndMovie_TZD_Draw(pCtrl,paramNum,paramArray);
    #endif
    #if (MOVIE_FTG_FUNC == ENABLE)
    UIFlowWndMovie_FTG_Draw(pCtrl,paramNum,paramArray);
    #endif
    #if ((_ADAS_FUNC_ == ENABLE)&&(_ADAS_DSP_FUNC_ ==ENABLE))
    UIFlowWndMovie_ADASDsp_Draw(pCtrl,paramNum,paramArray);
    #endif
    #if (MOVIE_TSR_FUNC_ == ENABLE)
    UIFlowWndMovie_TSR_OSD_Draw(pCtrl,paramNum,paramArray);
    //UIFlowWndMovie_TSR_FD_Draw(pCtrl,paramNum,paramArray);
    #endif
    #if (TIMELAPSE_LPR_FUNCTION == ENABLE)
    UIFlowWndMovie_TimelapseLPR_Draw(pCtrl,paramNum,paramArray);
    #endif
    return NVTEVT_CONSUME;
}

#if MOVIE_FD_FUNC_ || MOVIE_OT_FUNC || MOVIE_TD_FUNC|| MOVIE_FTG_FUNC
static void UIFlowWndMovie_ClrFDRect(void)
{
    UINT32 i;
    DISPLAYER_PARAM   DispLyr = {0} ;
    PDISP_OBJ         pDispObj = NULL;

    pDispObj = disp_getDisplayObject(DISP_1);
    for (i=0;i<MAX_FDNUM;i++)
    {
        DispLyr.SEL.SET_FDEN.FD_NUM = DISPFD_NUM0<<i;
        DispLyr.SEL.SET_FDEN.bEn = FALSE;
        pDispObj->dispLyrCtrl(DISPLAYER_FD, DISPLAYER_OP_SET_FDEN, &DispLyr);
    }
    pDispObj->load(TRUE);
}
#endif

static void UIFlowWndMovie_ALG_ClearDraw(void)
{
    #if MOVIE_FD_FUNC_ || MOVIE_OT_FUNC || MOVIE_TD_FUNC|| MOVIE_FTG_FUNC
    UIFlowWndMovie_ClrFDRect();
    #endif
}
//#NT#2016/06/08#Lincy Lin -end


CTRL_LIST_BEGIN(UIFlowWndMovie_ADAS_Alert_Display)
CTRL_LIST_ITEM(UIFlowWndMovie_StatusICN_LDWS_Alert)
CTRL_LIST_ITEM(UIFlowWndMovie_StatusICN_FCWS_Alert)
CTRL_LIST_ITEM(UIFlowWndMovie_StatusICN_SNG_Alert)
CTRL_LIST_END

//----------------------UIFlowWndMovie_ADAS_Alert_DisplayCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_ADAS_Alert_Display)
EVENT_END

//----------------------UIFlowWndMovie_StatusICN_LDWS_AlertCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_StatusICN_LDWS_Alert)
EVENT_END

//----------------------UIFlowWndMovie_StatusICN_FCWS_AlertCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_StatusICN_FCWS_Alert)
EVENT_END

//----------------------UIFlowWndMovie_StatusICN_SNG_AlertCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_StatusICN_SNG_Alert)
EVENT_END

#if defined(YQCONFIG_ANDROID_SYSTEM_SUPPORT)
EVENT_BEGIN(UIFlowWndMovie_Static_Speed)
EVENT_END
EVENT_BEGIN(UIFlowWndMovie_Static_Distance)
EVENT_END
#endif
