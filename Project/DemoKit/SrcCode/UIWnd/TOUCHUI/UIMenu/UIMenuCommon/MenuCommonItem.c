//This source code is generated by UI Designer Studio.

#include "UIFramework.h"
#include "UIFrameworkExt.h"
#include "UIGraphics.h"
#include "NVTToolCommand.h"
#include "MenuCommonItemRes.c"
#include "MenuCommonItem.h"
#include "PrjCfg.h"
#include "UIFlow.h"

#define __MODULE__          MenuCommonItem
//#define __DBGLVL__ 0        //OFF mode, show nothing
#define __DBGLVL__ 1        //ERROR mode, show err, wrn only
//#define __DBGLVL__ 2        //TRACE mode, show err, wrn, ind, msg and func and ind, msg and func can be filtering by __DBGFLT__ settings
#define __DBGFLT__ "*"      //*=All
#include "DebugModule.h"

//---------------------MenuCommonItemCtrl Debug Definition -----------------------------
#define _MENUCOMMONITEM_ERROR_MSG        1
#define _MENUCOMMONITEM_TRACE_MSG        0

#if (_MENUCOMMONITEM_ERROR_MSG&(PRJ_DBG_LVL>=PRJ_DBG_LVL_ERR))
#define MenuCommonItemErrMsg(...)            debug_msg ("^R MenuCommonItem: "__VA_ARGS__)
#else
#define MenuCommonItemErrMsg(...)
#endif

#if (_MENUCOMMONITEM_TRACE_MSG&(PRJ_DBG_LVL>=PRJ_DBG_LVL_TRC))
#define MenuCommonItemTraceMsg(...)          debug_msg ("^B MenuCommonItem: "__VA_ARGS__)
#else
#define MenuCommonItemTraceMsg(...)
#endif

//---------------------MenuCommonItemCtrl Global Variables -----------------------------
#define ITEMS_PER_PAGE          4
#define MAX_SUPPORTED_PAGE      5                                       // It is according to the page indicator point

#define SEARCH_PREV_PAGE        0
#define SEARCH_NEXT_PAGE        1

#define TITLE_UPPER_LEFT_X     10
#define TITLE_UPPER_LEFT_Y      5
#define TITLE_WIDTH           300
#define TILE_HEIGHT            28

static INT32  g_TouchPressX;
static INT32  g_TouchPressY;
static INT32  g_PanelOffset;
static INT32  g_MenuMoved;
static INT32  g_TotalItemCount;
static INT32  g_PageItemIndex[MAX_SUPPORTED_PAGE][ITEMS_PER_PAGE];      // Store the enabled item index
static INT32  g_PageCurrent;

static TM_MENU* g_pTouchItemMenu = 0;

VControl* MenuCommonItem_PrevGroup[ITEMS_PER_PAGE]=
{
    &MenuCommonItem_BTN0Ctrl,
    &MenuCommonItem_BTN1Ctrl,
    &MenuCommonItem_BTN2Ctrl,
    &MenuCommonItem_BTN3Ctrl
};

VControl* MenuCommonItem_CurrGroup[ITEMS_PER_PAGE]=
{
    &MenuCommonItem_BTN4Ctrl,
    &MenuCommonItem_BTN5Ctrl,
    &MenuCommonItem_BTN6Ctrl,
    &MenuCommonItem_BTN7Ctrl
};

VControl* MenuCommonItem_NextGroup[ITEMS_PER_PAGE]=
{
    &MenuCommonItem_BTN8Ctrl,
    &MenuCommonItem_BTN9Ctrl,
    &MenuCommonItem_BTN10Ctrl,
    &MenuCommonItem_BTN11Ctrl
};

VControl* MenuCommonItem_Indicator[MAX_SUPPORTED_PAGE]=
{
    &MenuCommonItem_Point0Ctrl,
    &MenuCommonItem_Point1Ctrl,
    &MenuCommonItem_Point2Ctrl,
    &MenuCommonItem_Point3Ctrl,
    &MenuCommonItem_Point4Ctrl,
};

//---------------------MenuCommonItemCtrl Prototype Declaration  -----------------------

//---------------------MenuCommonItemCtrl Public API  ----------------------------------

//---------------------MenuCommonItemCtrl Private API  ---------------------------------
static void MenuCommonItem_SetCurrentMenu(TM_MENU* pMenu)
{
    g_pTouchItemMenu = pMenu;
}

static TM_MENU* MenuCommonItem_GetCurrentMenu(void)
{
    return g_pTouchItemMenu;
}

static INT32 MenuCommonItem_UpdateIndex(TM_MENU* pMenu)
{
    INT32 i, index, *pIdx;
    TM_PAGE* pPage;

    pIdx = (INT32*)g_PageItemIndex;

    // Initialize all components of g_PageItemIndex to -1. -1 means no valid item.
    for(i = 0; i < MAX_SUPPORTED_PAGE * ITEMS_PER_PAGE; i ++)
    {
        pIdx[i] = -1;
    }

    i = 0;
    pPage = &pMenu->pPages[0];

    // Scan all the items and store the enabled items to g_PageItemIndex
    while (index < pPage->Count)
    {
        if(((&pPage->pItems[index])->Status & TM_ITEM_STATUS_MASK) == TM_ITEM_ENABLE)
        {
            pIdx[i] = index;
            i ++;
            if (i >= MAX_SUPPORTED_PAGE * ITEMS_PER_PAGE)
            {
                break;
            }
        }
        index ++;
    }
    // The return value means total active items.
    return i;
}

static INT32 MenuCommonItem_FindDispPage(INT32 CurrentPage, UINT32 action)
{
    INT32 index;

    index = CurrentPage;

    // Protection, it mean no valid items in g_PageItemIndex.
    if (g_PageItemIndex[index][0] == -1)
        return index;

    // Find previous valid page
    if (action == SEARCH_PREV_PAGE)
    {
        do
        {
            if (index)
                index --;
            else
                index = MAX_SUPPORTED_PAGE - 1;
        } while (g_PageItemIndex[index][0] == -1);
    }
    // Find next valid page
    else if (action == SEARCH_NEXT_PAGE)
    {
        do
        {
            index = (index + 1) % MAX_SUPPORTED_PAGE;
        } while (g_PageItemIndex[index][0] == -1);
    }
    return index;
}

static void MenuCommonItem_UpdateContent(TM_MENU* pMenu)
{
    TM_PAGE*    pPage;
    TM_ITEM*    pItem;
    INT32       i, index;

    pPage = &pMenu->pPages[pMenu->SelPage];

    // Protection, it mean no valid items in g_PageItemIndex.
    if (g_PageItemIndex[g_PageCurrent][0] ==  -1)
        return;

    // Update current display page
    for (i = 0; i < ITEMS_PER_PAGE; i ++)
    {
        if (g_PageItemIndex[g_PageCurrent][i] != -1)
        {
            pItem= &pPage->pItems[g_PageItemIndex[g_PageCurrent][i]];
            UxButton_SetItemData(MenuCommonItem_CurrGroup[i], 0, BTNITM_STRID, pItem->TextId);
            UxButton_SetItemData(MenuCommonItem_CurrGroup[i], 0, BTNITM_ICONID, pItem->IconId);
            UxCtrl_SetShow(MenuCommonItem_CurrGroup[i], TRUE);
        }
        else
        {
            UxCtrl_SetShow(MenuCommonItem_CurrGroup[i], FALSE);
        }
    }

    // Update prev display page
    index = MenuCommonItem_FindDispPage(g_PageCurrent, SEARCH_PREV_PAGE);

    for (i = 0; i < ITEMS_PER_PAGE; i ++)
    {
        if (g_PageItemIndex[index][i] != -1)
        {
            pItem= &pPage->pItems[g_PageItemIndex[index][i]];
            UxButton_SetItemData(MenuCommonItem_PrevGroup[i], 0, BTNITM_STRID, pItem->TextId);
            UxButton_SetItemData(MenuCommonItem_PrevGroup[i], 0, BTNITM_ICONID, pItem->IconId);
            UxCtrl_SetShow(MenuCommonItem_PrevGroup[i], TRUE);
        }
        else
        {
            UxCtrl_SetShow(MenuCommonItem_PrevGroup[i], FALSE);
        }
    }

    // Update next display page
    index = MenuCommonItem_FindDispPage(g_PageCurrent, SEARCH_NEXT_PAGE);

    for (i = 0; i < ITEMS_PER_PAGE; i ++)
    {
        if (g_PageItemIndex[index][i] != -1)
        {
            pItem= &pPage->pItems[g_PageItemIndex[index][i]];
            UxButton_SetItemData(MenuCommonItem_NextGroup[i], 0, BTNITM_STRID, pItem->TextId);
            UxButton_SetItemData(MenuCommonItem_NextGroup[i], 0, BTNITM_ICONID, pItem->IconId);
            UxCtrl_SetShow(MenuCommonItem_NextGroup[i], TRUE);
        }
        else
        {
            UxCtrl_SetShow(MenuCommonItem_NextGroup[i], FALSE);
        }
    }

    // Update title
    UxMenu_SetItemData(&MenuCommonItem_TitleCtrl, 0, MNUITM_STRID,  pPage->TextId);
}

// Keep the title at same position even menu is sliding
void MenuCommonItem_DrawTitle(void)
{
    Ux_RECT rect;
    rect.x1 = TITLE_UPPER_LEFT_X - g_PanelOffset;
    rect.y1 = TITLE_UPPER_LEFT_Y;
    rect.x2 = rect.x1 + TITLE_WIDTH;
    rect.y2 = rect.y1 + TILE_HEIGHT;
    UxCtrl_SetPos(&MenuCommonItem_TitleCtrl, rect);
}

// Keep the indicator at same position even menu is sliding
void MenuCommonItem_DrawPoint(void)
{
    INT32 TotalPage;
    INT32 i;
    Ux_RECT rect;

    INT32 TopLeftX[MAX_SUPPORTED_PAGE][MAX_SUPPORTED_PAGE] =
        //{{157,  -1,  -1,  -1,  -1},
        {{ -1,  -1,  -1,  -1,  -1},         // Do not show indicator if only one page
         {147, 167,  -1,  -1,  -1},
         {137, 157, 177,  -1,  -1},
         {127, 147, 167, 187,  -1},
         {117, 137, 157, 177, 197}};
    INT32 TopLeftY = 220;
    INT32 IndicatorSize = 6;

    // Calculate how many indicator will be showed
    TotalPage = g_TotalItemCount / ITEMS_PER_PAGE;
    if (g_TotalItemCount % ITEMS_PER_PAGE)
    {
        TotalPage ++;
    }

    // The first indicator is highlighted, others are gray. So according to g_PageCurrent, swap the corresponding coordinate.
    i = TopLeftX[TotalPage - 1][g_PageCurrent];
    TopLeftX[TotalPage - 1][g_PageCurrent] = TopLeftX[TotalPage - 1][0];
    TopLeftX[TotalPage - 1][0] = i;

    // Set the position of each indicator and show status
    for (i = 0; i < MAX_SUPPORTED_PAGE; i ++)
    {
        if (TopLeftX[TotalPage - 1][i] == -1)
        {
            UxCtrl_SetShow(MenuCommonItem_Indicator[i], FALSE);
        }
        else
        {
            rect.x1 = TopLeftX[TotalPage - 1][i] - g_PanelOffset;
            rect.y1 = TopLeftY;
            rect.x2 = rect.x1 + IndicatorSize;
            rect.y2 = rect.y1 + IndicatorSize;
            UxCtrl_SetPos(MenuCommonItem_Indicator[i], rect);
            UxCtrl_SetShow(MenuCommonItem_Indicator[i], TRUE);
        }
    }
}

static INT32 MenuCommonItem_SelectItem(TM_MENU* pMenu)
{
    TM_PAGE*    pPage;
    TM_ITEM*    pItem;

    pPage = &pMenu->pPages[pMenu->SelPage];
    pItem = &pPage->pItems[pPage->SelItem];

    if (pItem->Count != 0 && pItem->SysFlag != 0)
    {
        Ux_OpenWindow(&MenuCommonOptionCtrl, 1, pMenu);
    }
    else if (pItem->ItemId == IDM_VERSION)
    {
        Ux_OpenWindow(&MenuCommonOptionCtrl, 1, pMenu);
    }
    else if (pItem->pOptions != 0)                  // custom process
    {
        pMenu->Status = TMS_ON_CUSTOM;
        TM_ITEM_CALLBACK(pItem, TMM_CONFIRM_OPTION,pItem->ItemId);              // execute custom pPage flow
    }
   return NVTEVT_CONSUME;
}

static BOOL MenuCommonItem_CheckReOpenItem(void)
{
    BOOL bReOpen = FALSE;
    if(UI_GetData(FL_MOVIE_SIZE_MENU) != UI_GetData(FL_MOVIE_SIZE))
    {
        // Set resolution on mode open to avoid wrong preview image.
        UI_SetData(FL_MOVIE_SIZE, UI_GetData(FL_MOVIE_SIZE_MENU));
        bReOpen = TRUE;
    }

    if(UI_GetData(FL_MOVIE_HDR_MENU) != UI_GetData(FL_MOVIE_HDR))
    {
        if(UI_GetData(FL_MOVIE_HDR_MENU)==MOVIE_HDR_ON)
        {
            UI_SetData(FL_MOVIE_WDR, MOVIE_WDR_OFF);
            UI_SetData(FL_MOVIE_WDR_MENU, MOVIE_WDR_OFF);
            UI_SetData(FL_MovieRSCIndex, MOVIE_RSC_OFF);
            UI_SetData(FL_MovieRSCIndex_MENU, MOVIE_RSC_OFF);
        }
        UI_SetData(FL_MOVIE_HDR, UI_GetData(FL_MOVIE_HDR_MENU));
        bReOpen = TRUE;
    }

    if(UI_GetData(FL_MOVIE_WDR_MENU) != UI_GetData(FL_MOVIE_WDR))
    {

        if(UI_GetData(FL_MOVIE_WDR_MENU)==MOVIE_WDR_ON)
        {
            UI_SetData(FL_MOVIE_HDR, MOVIE_HDR_OFF);
            UI_SetData(FL_MOVIE_HDR_MENU, MOVIE_HDR_OFF);
        }
        UI_SetData(FL_MOVIE_WDR, UI_GetData(FL_MOVIE_WDR_MENU));
        bReOpen = TRUE;
    }

    if(UI_GetData(FL_MovieRSCIndex_MENU) != UI_GetData(FL_MovieRSCIndex))
    {

        if(UI_GetData(FL_MovieRSCIndex_MENU)==MOVIE_RSC_ON)
        {
            UI_SetData(FL_MOVIE_HDR, MOVIE_HDR_OFF);
            UI_SetData(FL_MOVIE_HDR_MENU, MOVIE_HDR_OFF);
        }
        UI_SetData(FL_MovieRSCIndex, UI_GetData(FL_MovieRSCIndex_MENU));
        bReOpen = TRUE;
    }

    if(UI_GetData(FL_DUAL_CAM_MENU) != UI_GetData(FL_DUAL_CAM))
    {

        Ux_PostEvent(NVTEVT_EXE_DUALCAM, 1, UI_GetData(FL_DUAL_CAM_MENU));

        #if (PIP_VIEW_FASTSWITCH == DISABLE) //when PIP_VIEW_FASTSWITCH enabled, NVTEVT_EXE_DUALCAM will not ReOpen inside.
        bReOpen = FALSE; // because in NVTEVT_EXE_DUALCAM, NVTEVT_EXE_MOVIE_DUALCAM will invoke ReOpen
        #endif
    }

//#NT#2016/09/13#KCHong#[0109190][0106941][0105955][0104994][0099778] -begin
//#NT#Check whether FC/LD/Timelapse is changed no matter _ADAS_FUNC_ is enabled or not (Also merge the comments for reading)
#if 1	//(_ADAS_FUNC_ == ENABLE)
	if (UI_GetData(FL_MOVIE_LDWS) != UI_GetData(FL_MOVIE_LDWS_MENU)) {
		UI_SetData(FL_MOVIE_LDWS, UI_GetData(FL_MOVIE_LDWS_MENU));
		bReOpen = TRUE;
	}

	if (UI_GetData(FL_MOVIE_FCW) != UI_GetData(FL_MOVIE_FCW_MENU)) {
		UI_SetData(FL_MOVIE_FCW, UI_GetData(FL_MOVIE_FCW_MENU));
		bReOpen = TRUE;
	}

	if (UI_GetData(FL_MOVIE_TIMELAPSE_REC) != UI_GetData(FL_MOVIE_TIMELAPSE_REC_MENU)) {
		if ((UI_GetData(FL_MOVIE_TIMELAPSE_REC) == MOVIE_TIMELAPSEREC_OFF) &&
			(UI_GetData(FL_MOVIE_LDWS) == MOVIE_LDWS_ON || UI_GetData(FL_MOVIE_FCW) == MOVIE_FCW_ON)) {
			bReOpen = TRUE;
		}
		UI_SetData(FL_MOVIE_TIMELAPSE_REC, UI_GetData(FL_MOVIE_TIMELAPSE_REC_MENU));
	}
#endif
//#NT#2016/09/13#KCHong#[0109190][0106941][0105955][0104994][0099778] -end

    return bReOpen;
}

//---------------------MenuCommonItemCtrl Control List---------------------------
CTRL_LIST_BEGIN(MenuCommonItem)
CTRL_LIST_ITEM(MenuCommonItem_Title)
CTRL_LIST_ITEM(MenuCommonItem_BTN0)
CTRL_LIST_ITEM(MenuCommonItem_BTN1)
CTRL_LIST_ITEM(MenuCommonItem_BTN2)
CTRL_LIST_ITEM(MenuCommonItem_BTN3)
CTRL_LIST_ITEM(MenuCommonItem_BTN4)
CTRL_LIST_ITEM(MenuCommonItem_BTN5)
CTRL_LIST_ITEM(MenuCommonItem_BTN6)
CTRL_LIST_ITEM(MenuCommonItem_BTN7)
CTRL_LIST_ITEM(MenuCommonItem_BTN8)
CTRL_LIST_ITEM(MenuCommonItem_BTN9)
CTRL_LIST_ITEM(MenuCommonItem_BTN10)
CTRL_LIST_ITEM(MenuCommonItem_BTN11)
CTRL_LIST_ITEM(MenuCommonItem_Point0)
CTRL_LIST_ITEM(MenuCommonItem_Point1)
CTRL_LIST_ITEM(MenuCommonItem_Point2)
CTRL_LIST_ITEM(MenuCommonItem_Point3)
CTRL_LIST_ITEM(MenuCommonItem_Point4)
CTRL_LIST_END

//----------------------MenuCommonItemCtrl Event---------------------------
INT32 MenuCommonItem_OnOpen(VControl *, UINT32, UINT32 *);
INT32 MenuCommonItem_OnClose(VControl *, UINT32, UINT32 *);
INT32 MenuCommonItem_OnChildClose(VControl *, UINT32, UINT32 *);
INT32 MenuCommonItem_OnTouchPanelPress(VControl *, UINT32, UINT32 *);
INT32 MenuCommonItem_OnTouchPanelMove(VControl *, UINT32, UINT32 *);
INT32 MenuCommonItem_OnTouchPanelRelease(VControl *, UINT32, UINT32 *);
INT32 MenuCommonItem_OnTouchPanelSlideUp(VControl *, UINT32, UINT32 *);
INT32 MenuCommonItem_OnTouchPanelSlideDown(VControl *, UINT32, UINT32 *);
INT32 MenuCommonItem_OnRedraw(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(MenuCommonItem)
EVENT_ITEM(NVTEVT_OPEN_WINDOW,MenuCommonItem_OnOpen)
EVENT_ITEM(NVTEVT_CLOSE_WINDOW,MenuCommonItem_OnClose)
EVENT_ITEM(NVTEVT_CHILD_CLOSE,MenuCommonItem_OnChildClose)
EVENT_ITEM(NVTEVT_PRESS,MenuCommonItem_OnTouchPanelPress)
EVENT_ITEM(NVTEVT_MOVE,MenuCommonItem_OnTouchPanelMove)
EVENT_ITEM(NVTEVT_RELEASE,MenuCommonItem_OnTouchPanelRelease)
EVENT_ITEM(NVTEVT_SLIDE_UP,MenuCommonItem_OnTouchPanelSlideUp)
EVENT_ITEM(NVTEVT_SLIDE_DOWN,MenuCommonItem_OnTouchPanelSlideDown)
EVENT_ITEM(NVTEVT_REDRAW,MenuCommonItem_OnRedraw)
EVENT_END

INT32 MenuCommonItem_OnOpen(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    TM_MENU*    pMenu;
    Ux_RECT     rect;

    if(paramNum == 1)
    {
        // Step 1: Parsing target menu items
        MenuCommonItem_SetCurrentMenu((TM_MENU*)paramArray[0]);
        pMenu = MenuCommonItem_GetCurrentMenu();
        pMenu->Status = TMS_ON_OPTION;
        pMenu->SelPage = 0;
        g_PageCurrent = 0;
        g_TotalItemCount = MenuCommonItem_UpdateIndex(pMenu);

        // Step 2: Update content
        MenuCommonItem_UpdateContent(pMenu);

        // Step 3: Update position, always use 2nd display window to show active area.
        //      |--------------------------------|
        //      |   prev   |   curr   |   next   |
        //      |   page   |   page   |   page   |
        //      |--------------------------------|
        //                 |<-------->|
        //      slide right  display    slide left
        //
        rect.x1 = (-1) * DISPLAY_OSD_W;
        rect.y1 = 0;
        rect.x2 = rect.x1 + 3 * DISPLAY_OSD_W - 1;
        rect.y2 = DISPLAY_OSD_H - 1;
        g_PanelOffset = rect.x1;
        g_MenuMoved = FALSE;
        UxCtrl_SetPos((VControl *)&MenuCommonItemCtrl, rect);
        UI_SetDisplayPalette(LAYER_OSD1,0,256,gDemoKit_PaletteOption_Palette);

        // Step 4: Open window
        Ux_DefaultEvent(pCtrl,NVTEVT_OPEN_WINDOW, paramNum, paramArray);
    }
    return NVTEVT_CONSUME;
}

INT32 MenuCommonItem_OnClose(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    Ux_DefaultEvent(pCtrl,NVTEVT_CLOSE_WINDOW,paramNum,paramArray);

    //#NT#2016/08/19#Lincy Lin#[0106935] -begin
    //#NT# Support change WDR, SHDR, RSC setting will change mode after exit menu
    BOOL bReOpenMovie = MenuCommonItem_CheckReOpenItem();
    BOOL bReOpenPhoto = FlowPhoto_CheckReOpenItem();

    if(bReOpenMovie || bReOpenPhoto)
    //#NT#2016/08/19#Lincy Lin -end
    {
        Ux_PostEvent(NVTEVT_SYSTEM_MODE, 1, System_GetState(SYS_STATE_CURRMODE));
    }
    return NVTEVT_CONSUME;
}

INT32 MenuCommonItem_OnChildClose(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    Ux_DefaultEvent(pCtrl,NVTEVT_CHILD_CLOSE,paramNum,paramArray);
    return NVTEVT_CONSUME;
}

INT32 MenuCommonItem_OnTouchPanelPress(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    // Store press position
    g_TouchPressX = paramArray[0];
    g_TouchPressY = paramArray[1];
    g_MenuMoved = FALSE;
    return NVTEVT_CONSUME;
}

INT32 MenuCommonItem_OnTouchPanelMove(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    INT32 uiPosX;
    INT32 uiPosY;
    Ux_RECT rect;

    // If items more than 1 page, then support slide move function
    if (g_TotalItemCount > ITEMS_PER_PAGE)
    {
        uiPosX = paramArray[0];
        uiPosY = paramArray[1];
        g_MenuMoved = TRUE;

        UxCtrl_GetPos((VControl *)&MenuCommonItemCtrl, &rect);
        rect.x1 = (-1) * DISPLAY_OSD_W + uiPosX - g_TouchPressX;
        rect.x2 = rect.x1 + 3 * DISPLAY_OSD_W - 1;
        g_PanelOffset = rect.x1;
        UxCtrl_SetPos((VControl *)&MenuCommonItemCtrl, rect);
        UxCtrl_SetDirty(&MenuCommonItemCtrl, TRUE);
        Ux_RedrawAllWind();
        // Flush repeat NVTEVT_MOVE in event queue
        //Ux_FlushEventByRange(NVTEVT_MOVE, NVTEVT_MOVE);		// Use GxTouch_SetCtrl(GXTCH_MOVE_REPEAT_RATE, 3) to reduce move event
    }
    return NVTEVT_CONSUME;
}

INT32 MenuCommonItem_OnTouchPanelRelease(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    TM_MENU* pMenu;
    TM_PAGE* pPage;
    INT32 uiPosX;
    INT32 uiPosY;
    Ux_RECT rect;

    uiPosX = paramArray[0];
    uiPosY = paramArray[1];
    pMenu = MenuCommonItem_GetCurrentMenu();
    pPage = &pMenu->pPages[pMenu->SelPage];

    // Unlock MenuCommonModeCtrl otherwise the window cannot receive touch event anymore.
    UxCtrl_SetLock (pCtrl, FALSE);

    // If slide left more than 1/4 DISPLAY_OSD_W, change to previous page
    if ((g_TouchPressX - uiPosX) > (DISPLAY_OSD_W/4))
    {
        g_PageCurrent = MenuCommonItem_FindDispPage(g_PageCurrent, SEARCH_NEXT_PAGE);
        pPage->SelItem = g_PageItemIndex[g_PageCurrent][0];
        MenuCommonItem_UpdateContent(MenuCommonItem_GetCurrentMenu());
    }
    // If slide right more than 1/4 DISPLAY_OSD_W, change to next page
    else if ((uiPosX - g_TouchPressX) > (DISPLAY_OSD_W/4))
    {
        g_PageCurrent = MenuCommonItem_FindDispPage(g_PageCurrent, SEARCH_PREV_PAGE);
        pPage->SelItem = g_PageItemIndex[g_PageCurrent][0];
        MenuCommonItem_UpdateContent(MenuCommonItem_GetCurrentMenu());
    }
    // Reset display position to 2nd display window.
    rect.x1 = (-1) * DISPLAY_OSD_W;
    rect.y1 = 0;
    rect.x2 = rect.x1 + 3 * DISPLAY_OSD_W - 1;
    rect.y2 = DISPLAY_OSD_H - 1;
    g_PanelOffset = rect.x1;
    //g_MenuMoved = FALSE;          // Cannot clean this flag otherwise CLICK event will refer to wrong status.
    UxCtrl_SetPos((VControl *)&MenuCommonItemCtrl, rect);
    UxCtrl_SetDirty(&MenuCommonItemCtrl, TRUE);
    Ux_RedrawAllWind();
    Ux_FlushEventByRange(NVTEVT_MOVE, NVTEVT_MOVE);
    return NVTEVT_CONSUME;
}

INT32 MenuCommonItem_OnTouchPanelSlideUp(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    Ux_CloseWindow (pCtrl, 0);
    return NVTEVT_CONSUME;
}

INT32 MenuCommonItem_OnTouchPanelSlideDown(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    Ux_CloseWindow (pCtrl, 0);
    return NVTEVT_CONSUME;
}

INT32 MenuCommonItem_OnRedraw(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    MenuCommonItem_DrawTitle();
    MenuCommonItem_DrawPoint();
    Ux_DefaultEvent(pCtrl,NVTEVT_REDRAW,paramNum,paramArray);
    return NVTEVT_CONSUME;
}

//----------------------MenuCommonItem_TitleCtrl Event---------------------------
EVENT_BEGIN(MenuCommonItem_Title)
EVENT_END

//----------------------MenuCommonItem_BTN0Ctrl Event---------------------------
EVENT_BEGIN(MenuCommonItem_BTN0)
EVENT_END

//----------------------MenuCommonItem_BTN1Ctrl Event---------------------------
EVENT_BEGIN(MenuCommonItem_BTN1)
EVENT_END

//----------------------MenuCommonItem_BTN2Ctrl Event---------------------------
EVENT_BEGIN(MenuCommonItem_BTN2)
EVENT_END

//----------------------MenuCommonItem_BTN3Ctrl Event---------------------------
EVENT_BEGIN(MenuCommonItem_BTN3)
EVENT_END

//----------------------MenuCommonItem_BTN4Ctrl Event---------------------------
//#NT#2017/04/24#KCHong#[0118496] -begin
//#NT#With new UIControl.a (svn23144 or later, should pass press and release event to parents for current UI design)
INT32 MenuCommonItem_BTN4_OnTouchPanelPress(VControl *, UINT32, UINT32 *);
INT32 MenuCommonItem_BTN4_OnTouchPanelRelease(VControl *, UINT32, UINT32 *);
INT32 MenuCommonItem_BTN4_OnTouchPanelClick(VControl *, UINT32, UINT32 *);
INT32 MenuCommonItem_BTN4_OnTouchPanelMove(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(MenuCommonItem_BTN4)
EVENT_ITEM(NVTEVT_PRESS,MenuCommonItem_BTN4_OnTouchPanelPress)
EVENT_ITEM(NVTEVT_RELEASE,MenuCommonItem_BTN4_OnTouchPanelRelease)
EVENT_ITEM(NVTEVT_CLICK,MenuCommonItem_BTN4_OnTouchPanelClick)
EVENT_ITEM(NVTEVT_MOVE,MenuCommonItem_BTN4_OnTouchPanelMove)
EVENT_END

INT32 MenuCommonItem_BTN4_OnTouchPanelPress(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    g_MenuMoved = FALSE;
    Ux_DefaultEvent(pCtrl, NVTEVT_PRESS, paramNum, paramArray);
	return NVTEVT_PASS;
}

INT32 MenuCommonItem_BTN4_OnTouchPanelRelease(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    Ux_DefaultEvent(pCtrl, NVTEVT_RELEASE, paramNum, paramArray);
	return NVTEVT_PASS;
}
//#NT#2017/04/24#KCHong -end

INT32 MenuCommonItem_BTN4_OnTouchPanelClick(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    TM_MENU*    pMenu;
    TM_PAGE*    pPage;

    if(!g_MenuMoved)
    {
        pMenu = MenuCommonItem_GetCurrentMenu();
        pPage = &pMenu->pPages[pMenu->SelPage];
        pPage->SelItem = g_PageItemIndex[g_PageCurrent][0];
        MenuCommonItem_SelectItem(pMenu);
    }
    return NVTEVT_CONSUME;
}

INT32 MenuCommonItem_BTN4_OnTouchPanelMove(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    // If items more than 1 page, then support slide move function
    if (g_TotalItemCount > ITEMS_PER_PAGE)
    {
        // If button is locked, release itself and set MenuCommonModeCtrl as locked VControl (then only MenuCommonModeCtrl can receive event)
        if (UxCtrl_GetLock() == pCtrl)
        {
            Ux_DefaultEvent(pCtrl, NVTEVT_RELEASE, paramNum, paramArray);
            UxCtrl_SetLock (&MenuCommonItemCtrl, TRUE);
            Ux_SendEvent(&MenuCommonItemCtrl, NVTEVT_MOVE, 2, (paramArray[0] + g_PanelOffset), paramArray[1]);
        }
    }
    return NVTEVT_CONSUME;
}

//----------------------MenuCommonItem_BTN5Ctrl Event---------------------------
//#NT#2017/04/24#KCHong#[0118496] -begin
//#NT#With new UIControl.a (svn23144 or later, should pass press and release event to parents for current UI design)
INT32 MenuCommonItem_BTN5_OnTouchPanelPress(VControl *, UINT32, UINT32 *);
INT32 MenuCommonItem_BTN5_OnTouchPanelRelease(VControl *, UINT32, UINT32 *);
INT32 MenuCommonItem_BTN5_OnTouchPanelClick(VControl *, UINT32, UINT32 *);
INT32 MenuCommonItem_BTN5_OnTouchPanelMove(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(MenuCommonItem_BTN5)
EVENT_ITEM(NVTEVT_PRESS,MenuCommonItem_BTN5_OnTouchPanelPress)
EVENT_ITEM(NVTEVT_RELEASE,MenuCommonItem_BTN5_OnTouchPanelRelease)
EVENT_ITEM(NVTEVT_CLICK,MenuCommonItem_BTN5_OnTouchPanelClick)
EVENT_ITEM(NVTEVT_MOVE,MenuCommonItem_BTN5_OnTouchPanelMove)
EVENT_END

INT32 MenuCommonItem_BTN5_OnTouchPanelPress(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    g_MenuMoved = FALSE;
    Ux_DefaultEvent(pCtrl, NVTEVT_PRESS, paramNum, paramArray);
	return NVTEVT_PASS;
}

INT32 MenuCommonItem_BTN5_OnTouchPanelRelease(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    Ux_DefaultEvent(pCtrl, NVTEVT_RELEASE, paramNum, paramArray);
	return NVTEVT_PASS;
}
//#NT#2017/04/24#KCHong -end

INT32 MenuCommonItem_BTN5_OnTouchPanelClick(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    TM_MENU*    pMenu;
    TM_PAGE*    pPage;

    if(!g_MenuMoved)
    {
        pMenu = MenuCommonItem_GetCurrentMenu();
        pPage = &pMenu->pPages[pMenu->SelPage];
        pPage->SelItem = g_PageItemIndex[g_PageCurrent][1];
        MenuCommonItem_SelectItem(pMenu);
    }
    return NVTEVT_CONSUME;
}

INT32 MenuCommonItem_BTN5_OnTouchPanelMove(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    // If items more than 1 page, then support slide move function
    if (g_TotalItemCount > ITEMS_PER_PAGE)
    {
        // If button is locked, release itself and set MenuCommonModeCtrl as locked VControl (then only MenuCommonModeCtrl can receive event)
        if (UxCtrl_GetLock() == pCtrl)
        {
            Ux_DefaultEvent(pCtrl, NVTEVT_RELEASE, paramNum, paramArray);
            UxCtrl_SetLock (&MenuCommonItemCtrl, TRUE);
            Ux_SendEvent(&MenuCommonItemCtrl, NVTEVT_MOVE, 2, (paramArray[0] + g_PanelOffset), paramArray[1]);
        }
    }
    return NVTEVT_CONSUME;
}

//----------------------MenuCommonItem_BTN6Ctrl Event---------------------------
//#NT#2017/04/24#KCHong#[0118496] -begin
//#NT#With new UIControl.a (svn23144 or later, should pass press and release event to parents for current UI design)
INT32 MenuCommonItem_BTN6_OnTouchPanelPress(VControl *, UINT32, UINT32 *);
INT32 MenuCommonItem_BTN6_OnTouchPanelRelease(VControl *, UINT32, UINT32 *);
INT32 MenuCommonItem_BTN6_OnTouchPanelClick(VControl *, UINT32, UINT32 *);
INT32 MenuCommonItem_BTN6_OnTouchPanelMove(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(MenuCommonItem_BTN6)
EVENT_ITEM(NVTEVT_PRESS,MenuCommonItem_BTN6_OnTouchPanelPress)
EVENT_ITEM(NVTEVT_RELEASE,MenuCommonItem_BTN6_OnTouchPanelRelease)
EVENT_ITEM(NVTEVT_CLICK,MenuCommonItem_BTN6_OnTouchPanelClick)
EVENT_ITEM(NVTEVT_MOVE,MenuCommonItem_BTN6_OnTouchPanelMove)
EVENT_END

INT32 MenuCommonItem_BTN6_OnTouchPanelPress(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    g_MenuMoved = FALSE;
    Ux_DefaultEvent(pCtrl, NVTEVT_PRESS, paramNum, paramArray);
	return NVTEVT_PASS;
}

INT32 MenuCommonItem_BTN6_OnTouchPanelRelease(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    Ux_DefaultEvent(pCtrl, NVTEVT_RELEASE, paramNum, paramArray);
	return NVTEVT_PASS;
}
//#NT#2017/04/24#KCHong -end

INT32 MenuCommonItem_BTN6_OnTouchPanelClick(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    TM_MENU*    pMenu;
    TM_PAGE*    pPage;

    if(!g_MenuMoved)
    {
        pMenu = MenuCommonItem_GetCurrentMenu();
        pPage = &pMenu->pPages[pMenu->SelPage];
        pPage->SelItem = g_PageItemIndex[g_PageCurrent][2];
        MenuCommonItem_SelectItem(pMenu);
    }
    return NVTEVT_CONSUME;
}

INT32 MenuCommonItem_BTN6_OnTouchPanelMove(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    // If items more than 1 page, then support slide move function
    if (g_TotalItemCount > ITEMS_PER_PAGE)
    {
        // If button is locked, release itself and set MenuCommonModeCtrl as locked VControl (then only MenuCommonModeCtrl can receive event)
        if (UxCtrl_GetLock() == pCtrl)
        {
            Ux_DefaultEvent(pCtrl, NVTEVT_RELEASE, paramNum, paramArray);
            UxCtrl_SetLock (&MenuCommonItemCtrl, TRUE);
            Ux_SendEvent(&MenuCommonItemCtrl, NVTEVT_MOVE, 2, (paramArray[0] + g_PanelOffset), paramArray[1]);
        }
    }
    return NVTEVT_CONSUME;
}

//----------------------MenuCommonItem_BTN7Ctrl Event---------------------------
//#NT#2017/04/24#KCHong#[0118496] -begin
//#NT#With new UIControl.a (svn23144 or later, should pass press and release event to parents for current UI design)
INT32 MenuCommonItem_BTN7_OnTouchPanelPress(VControl *, UINT32, UINT32 *);
INT32 MenuCommonItem_BTN7_OnTouchPanelRelease(VControl *, UINT32, UINT32 *);
INT32 MenuCommonItem_BTN7_OnTouchPanelClick(VControl *, UINT32, UINT32 *);
INT32 MenuCommonItem_BTN7_OnTouchPanelMove(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(MenuCommonItem_BTN7)
EVENT_ITEM(NVTEVT_PRESS,MenuCommonItem_BTN7_OnTouchPanelPress)
EVENT_ITEM(NVTEVT_RELEASE,MenuCommonItem_BTN7_OnTouchPanelRelease)
EVENT_ITEM(NVTEVT_CLICK,MenuCommonItem_BTN7_OnTouchPanelClick)
EVENT_ITEM(NVTEVT_MOVE,MenuCommonItem_BTN7_OnTouchPanelMove)
EVENT_END

INT32 MenuCommonItem_BTN7_OnTouchPanelPress(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    g_MenuMoved = FALSE;
    Ux_DefaultEvent(pCtrl, NVTEVT_PRESS, paramNum, paramArray);
	return NVTEVT_PASS;
}

INT32 MenuCommonItem_BTN7_OnTouchPanelRelease(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    Ux_DefaultEvent(pCtrl, NVTEVT_RELEASE, paramNum, paramArray);
	return NVTEVT_PASS;
}
//#NT#2017/04/24#KCHong -end

INT32 MenuCommonItem_BTN7_OnTouchPanelClick(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    TM_MENU*    pMenu;
    TM_PAGE*    pPage;

    if(!g_MenuMoved)
    {
        pMenu = MenuCommonItem_GetCurrentMenu();
        pPage = &pMenu->pPages[pMenu->SelPage];
        pPage->SelItem = g_PageItemIndex[g_PageCurrent][3];
        MenuCommonItem_SelectItem(pMenu);
    }
    return NVTEVT_CONSUME;
}

INT32 MenuCommonItem_BTN7_OnTouchPanelMove(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    // If items more than 1 page, then support slide move function
    if (g_TotalItemCount > ITEMS_PER_PAGE)
    {
        // If button is locked, release itself and set MenuCommonModeCtrl as locked VControl (then only MenuCommonModeCtrl can receive event)
        if (UxCtrl_GetLock() == pCtrl)
        {
            Ux_DefaultEvent(pCtrl, NVTEVT_RELEASE, paramNum, paramArray);
            UxCtrl_SetLock (&MenuCommonItemCtrl, TRUE);
            Ux_SendEvent(&MenuCommonItemCtrl, NVTEVT_MOVE, 2, (paramArray[0] + g_PanelOffset), paramArray[1]);
        }
    }
    return NVTEVT_CONSUME;
}

//----------------------MenuCommonItem_BTN8Ctrl Event---------------------------
EVENT_BEGIN(MenuCommonItem_BTN8)
EVENT_END

//----------------------MenuCommonItem_BTN9Ctrl Event---------------------------
EVENT_BEGIN(MenuCommonItem_BTN9)
EVENT_END

//----------------------MenuCommonItem_BTN10Ctrl Event---------------------------
EVENT_BEGIN(MenuCommonItem_BTN10)
EVENT_END

//----------------------MenuCommonItem_BTN11Ctrl Event---------------------------
EVENT_BEGIN(MenuCommonItem_BTN11)
EVENT_END

//---------------------MenuCommonItem_Point0Ctrl Control List---------------------------
CTRL_LIST_BEGIN(MenuCommonItem_Point0)
CTRL_LIST_END

//----------------------MenuCommonItem_Point0Ctrl Event---------------------------
EVENT_BEGIN(MenuCommonItem_Point0)
EVENT_END

//---------------------MenuCommonItem_Point1Ctrl Control List---------------------------
CTRL_LIST_BEGIN(MenuCommonItem_Point1)
CTRL_LIST_END

//----------------------MenuCommonItem_Point1Ctrl Event---------------------------
EVENT_BEGIN(MenuCommonItem_Point1)
EVENT_END

//---------------------MenuCommonItem_Point2Ctrl Control List---------------------------
CTRL_LIST_BEGIN(MenuCommonItem_Point2)
CTRL_LIST_END

//----------------------MenuCommonItem_Point2Ctrl Event---------------------------
EVENT_BEGIN(MenuCommonItem_Point2)
EVENT_END

//---------------------MenuCommonItem_Point3Ctrl Control List---------------------------
CTRL_LIST_BEGIN(MenuCommonItem_Point3)
CTRL_LIST_END

//----------------------MenuCommonItem_Point3Ctrl Event---------------------------
EVENT_BEGIN(MenuCommonItem_Point3)
EVENT_END

//---------------------MenuCommonItem_Point4Ctrl Control List---------------------------
CTRL_LIST_BEGIN(MenuCommonItem_Point4)
CTRL_LIST_END

//----------------------MenuCommonItem_Point4Ctrl Event---------------------------
EVENT_BEGIN(MenuCommonItem_Point4)
EVENT_END

